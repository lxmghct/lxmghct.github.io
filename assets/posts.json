[
  {
    "title": "linux umount报错目标忙",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/30/linux-umount%E6%8A%A5%E9%94%99%E7%9B%AE%E6%A0%87%E5%BF%99.html",
    "date": "2024-07-30 06:00:00 +0000",
    "content": "我在Kylin10系统上挂载了一个目录，然后想要卸载这个目录，但是执行umount命令时报错：\n\numount: /mnt: 目标忙\n\n\n这是因为有进程在使用这个目录，可以使用fuser命令查看：\n\nfuser -mv /mnt\n\n\n然后可以使用kill命令杀死这个进程：\n\nkill -9 1234\n\n"
  },
  {
    "title": "nginx配置上传文件大小限制",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/29/nginx%E9%85%8D%E7%BD%AE%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6.html",
    "date": "2024-07-29 05:30:00 +0000",
    "content": "前端上传文件报错：\nthe server responded with a status of 413(Request Entity Too Large)\n\n\n解决方法是在 nginx 配置文件中添加 client_max_body_size 配置项，如下：\nhttp{\n    client_max_body_size 50M;\n}\n\n"
  },
  {
    "title": "HBuilderX启动微信小程序报错：Cannot read property ‘forceUpdate‘ of undefined",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/26/HBuilderX%E5%90%AF%E5%8A%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99.html",
    "date": "2024-07-26 11:30:00 +0000",
    "content": "报错1\n[ app.json 文件内容错误] app.json: 未找到 [\"sitemapLocation\"] 对应的 sitemap.json 文件(env: Windows,mp,1.05.2203070; lib: 3.5.0)\n\n\n解决方法：在微信开发者工具中重新编译小程序，如果还是报错就在啊HBuilderX中重新启动微信小程序。具体原因未知。\n\n报错2\nCannot read property ‘forceUpdate‘ of undefined\n\n参考: https://blog.csdn.net/qq_40907752/article/details/107710357\n\n解决方法：如果微信开发者工具是游客模式，则使用自己的微信登录，并在manifest.json中把自己创建的小程序id填入。\n"
  },
  {
    "title": "使用vscode开发UE5.3",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/25/%E4%BD%BF%E7%94%A8vscode%E5%BC%80%E5%8F%91UE5.3.html",
    "date": "2024-07-25 07:30:00 +0000",
    "content": "参考链接：\n\nUE官方文档: 为虚幻引擎设置VS Code\n\nB站视频: 为虚幻引擎设置VS Code\n\n1. 配置UE5.3\n使用UE5.3打开任意项目，然后在编辑器中点击编辑->编辑器偏好设置->源代码，将源代码编辑器设置为Visual Studio Code。\n\n配置好后重启UE，然后新创建的项目将会使用vscode作为源代码编辑器，并且项目根目录的.vscode文件夹中会生成一些配置文件。\n\n2. 安装vscode插件\n在vscode中安装以下插件：\n\n  Unreal Engine 4 Snippets (该插件对UE5也适用)\n  C/C++\n\n\n3. 配置.vscode文件夹\n编辑项目根目录的.vscode/c_cpp_properties.json文件，可以参考开头的官方文档中的配置。下面是我使用的配置，这里面的includePath和defines是按开头的视频里添加的，不加似乎也可以运行。\n{\n  \"configurations\": [\n    {\n      \"name\": \"testEditor Editor Win64 Development (test)\",\n      \"compilerPath\": \"D:\\\\IDE\\\\Microsoft Visual Studio\\\\2022\\\\Community\\\\VC\\\\Tools\\\\MSVC\\\\14.35.32215\\\\bin\\\\Hostx64\\\\x64\\\\cl.exe\",\n      \"cStandard\": \"c17\",\n      \"cppStandard\": \"c++20\",\n      \"intelliSenseMode\": \"msvc-x64\",\n      \"compileCommands\": \"D:\\\\projects\\\\Unreal Projects\\\\test\\\\.vscode\\\\compileCommands_test.json\",\n      \"includePath\": [\n        \"${workspaceFolder}\\\\Plugins**\",\n        \"${workspaceFolder}\\\\Source**\",\n        \"${workspaceFolder}\\\\Intermediate**\"\n      ],\n      \"defines\": [\n        \"UNICODE\",\n        \"_UNICODE\",\n        \"__UNREAL__\",\n        \"UBT_COMPILED_PLATFORM=Windows\",\n        \"WITH_ENGINE=1\",\n        \"WITH_UNREAL_DEVELOPER_TOOLS=1\",\n        \"WITH_APPLICATION_CORE=1\",\n        \"WITH_COREUOBJECT=1\"\n      ]\n    },\n    {\n      \"name\": \"Win32\",\n      \"compilerPath\": \"D:\\\\IDE\\\\Microsoft Visual Studio\\\\2022\\\\Community\\\\VC\\\\Tools\\\\MSVC\\\\14.35.32215\\\\bin\\\\Hostx64\\\\x64\\\\cl.exe\",\n      \"cStandard\": \"c17\",\n      \"cppStandard\": \"c++20\",\n      \"intelliSenseMode\": \"msvc-x64\",\n      \"compileCommands\": \"D:\\\\projects\\\\Unreal Projects\\\\test\\\\.vscode\\\\compileCommands_Default.json\"\n    }\n  ],\n  \"version\": 4\n}\n\n\n4. 在vscode中运行项目\n点击vscode左侧的运行和调试，顶部的运行配置中选择Launch testEditor (Development)(工作区)（我的项目名是test），然后点击绿色的三角形按钮或者按F5运行项目。\n\n"
  },
  {
    "title": "nginx安装在root下的权限问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/21/nginx%E5%AE%89%E8%A3%85%E5%9C%A8root%E4%B8%8B%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98.html",
    "date": "2024-07-21 11:30:00 +0000",
    "content": "问题描述\n\nnginx报403错误：\n2024/07/21 15:59:37 [error] 577147#0: *1 \"/root/dev/nginx/html/index.html\" is forbidden (13: Permission denied), client: xxx.xxx.xxx.xxx, server: localhost, request: \"GET / HTTP/1.1\", host: \"xxx.xxx.xxx.xxx:8080\"\n\n\n403 Forbidden 错误通常表示 Nginx 服务器无法访问请求的文件或目录。错误的原因是权限被拒绝（13: Permission denied），可能是文件权限问题。\n\n解决方法\n确保 Nginx 进程用户（通常是 www-data、nginx 或 apache）对 /root/dev/nginx/html/index.html 文件和它所在的目录具有读取权限。使用 chmod 和 chown 命令来调整权限和所有者。例如：\n\nsudo chown -R www-data:www-data /root/dev/nginx/html\nsudo chmod -R 755 /root/dev/nginx/html\n\n但是上述方法仍然无法解决问题，因为root目录自身的权限问题。所以最终解决方法是将nginx安装在非root目录下，比如 /usr/local/nginx。\n"
  },
  {
    "title": "spring判断swagger model中的required字段",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/20/spring%E5%88%A4%E6%96%ADswagger-model%E4%B8%AD%E7%9A%84required%E5%AD%97%E6%AE%B5.html",
    "date": "2024-07-20 13:30:00 +0000",
    "content": "swagger的@ApiModelProperty注解中有一个required字段，用来标识字段是否必填。在后端接口中，我们可能需要判断swagger model中的required字段是否为空。采用的方法是通过反射获取对象的所有字段，然后检查字段是否有@ApiModelProperty注解，如果有则判断required字段是否为true，如果为true则检查字段是否为空。\n\n    /**\n     * 检查swagger的required字段\n     * @param obj 对象\n     * @return boolean\n     */\n    public static boolean checkRequiredFields(Object obj) {\n        // 获取对象的所有字段\n        Field[] fields = obj.getClass().getDeclaredFields();\n        for (Field field : fields) {\n            // 检查字段是否有@ApiModelProperty注解\n            ApiModelProperty annotation = field.getAnnotation(ApiModelProperty.class);\n            if (annotation != null && annotation.required()) {\n                field.setAccessible(true);\n                try {\n                    // 检查字段是否为空\n                    Object value = field.get(obj);\n                    if (value == null) {\n                        return false;\n                    }\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n"
  },
  {
    "title": "neo4j获取某个查询结果的索引",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/20/neo4j%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E7%B4%A2%E5%BC%95.html",
    "date": "2024-07-20 11:30:00 +0000",
    "content": "我想在 neo4j 中获取某个查询结果的索引，比如我想获取某个 personName 在所有查询结果中的索引。返回所有数据后再在程序中进行处理是一种方法，但是如果查询结果较大，这种方法就不太适用了。下面是在 spring-data-neo4j 中的实现。\n\n\n    @Query(\"MATCH (p:BaseNode:Person) \" +\n            \"WITH p ORDER BY p.nodeId \" +\n            \"WITH COLLECT(p) AS persons \" +\n            \"UNWIND RANGE(0, SIZE(persons) - 1) AS idx \" +\n            \"WITH persons[idx] AS person, idx \" +\n            \"WHERE person.name = {personName} \" +\n            \"RETURN idx\")\n    Integer getPersonIndex(String personName);\n\n"
  },
  {
    "title": "neo4j截取字符串",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/18/neo4j%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2.html",
    "date": "2024-07-18 02:30:00 +0000",
    "content": "我想在 neo4j 中将文章的前50个字符作为摘要保存到关系中，如果前50个字符中有句号或者问号，就截取到句号或者问号的位置。下面是在 spring-data-neo4j 中的实现。\n\n    @Query(\"UNWIND {linkList} AS link \" +\n            \"MATCH (a:BaseNode:Article {nodeId: link.articleId}) \" +\n            \"MATCH (n:BaseNode:Document {nodeId: link.documentId}) \" +\n            \"MERGE (n)-[r:reference]->(a) \" +\n            \"WITH n, r, a, substring(a.content, 0, 50) AS initialSnippet, \" +\n            \"replace(replace(substring(a.content, 0, 50), '。', '|'), '？', '|') AS markedSnippet \" +\n            \"WITH n, r, a, initialSnippet, markedSnippet, split(markedSnippet, '|')[0] AS summaryEnd \" +\n            \"SET r.summary = CASE WHEN summaryEnd IS NULL THEN initialSnippet ELSE substring(initialSnippet, 0, size(summaryEnd) + 1) END\")\n    void linkArticleToDocument(List<Map<String, Integer>> linkList);\n\n\n实现思路是先将文章的前50个字符保存到initialSnippet中，然后将其中的句号和问号替换为|，然后使用split函数按|分割并取第一个元素。\n"
  },
  {
    "title": "UE5创建项目时报错No available Windows SDKs found",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/17/UE5%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%8A%A5%E9%94%99No-available-Windows-SDKs-found.html",
    "date": "2024-07-17 07:00:00 +0000",
    "content": "问题描述\n我在使用UE5.3创建一个空白的游戏项目时，报了下面的错：\n\nRunning D:/IDE/Epic Games/UE_5.3/Engine/Build/BatchFiles/Build.bat  -projectfiles -project=\"D:/projects/Unreal Projects/tank/tank.uproject\" -game -rocket -progress\nUsing bundled DotNet SDK version: 6.0.302\nRunning UnrealBuildTool: dotnet \"..\\..\\Engine\\Binaries\\DotNET\\UnrealBuildTool\\UnrealBuildTool.dll\" -projectfiles -project=\"D:/projects/Unreal Projects/tank/tank.uproject\" -game -rocket -progress\nLog file: C:\\Users\\lxm\\AppData\\Local\\UnrealBuildTool\\Log_GPF.txt\n\nSome Platforms were skipped due to invalid SDK setup: Win64.\nSee the log file for detailed information\n\n\nGenerating VisualStudio project files:\nDiscovering modules, targets and source code for project...\nNo available Windows SDKs found\nWindows SDK must be installed in order to build this target.\n\n\n解决方法\n打开Microsoft Visual Studio Installer，修改安装，找到单个组件中的Windows 10 SDK，安装即可。\n\n"
  },
  {
    "title": "nginx配置proxy_pass时出现no live upstreams while connecting to upstream",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/15/nginx%E9%85%8D%E7%BD%AEproxy_pass%E6%97%B6%E5%87%BA%E7%8E%B0no-live-upstreams-while-connecting-to-upstream.html",
    "date": "2024-07-15 06:00:00 +0000",
    "content": "1. 问题描述\n在 nginx 配置文件中有如下配置项:\n    location /api {\n        proxy_pass    http://localhost:8090;\n    }\n\n前端访问 /api 时，有时候能正常访问，但有时候会出现 502 Bad Gateway 错误，查看 nginx 日志发现如下错误:\nno live upstreams while connecting to upstream\n\n\n已确认过8090端口的服务是正常的，但是 nginx 有时候会出现这个错误。\n\n2. 解决方法\n参考https://stackoverflow.com/questions/49767001/how-to-solve-nginx-no-live-upstreams-while-connecting-to-upstream-client\n\n将 proxy_pass 中的localhost改为127.0.0.1即可解决问题。原因暂未深入研究。\n\n根据 stackoverflow 上的回答来看，当在proxy_pass中使用localhost时，Nginx会依赖操作系统的DNS解析机制来解析这个主机名。localhost在不同的环境下可能解析为IPv4地址（127.0.0.1）或者IPv6地址（::1）。这取决于系统的DNS配置和优先级设置。当localhost解析为::1（IPv6地址）时，如果Nginx配置或后端服务没有正确处理IPv6请求或者绑定到IPv6端口，可能会导致连接失败。所以改成127.0.0.1可以让Nginx总是使用IPv4地址。\n"
  },
  {
    "title": "使用windows命令行连接neo4j",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/07/09/%E4%BD%BF%E7%94%A8windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9E%E6%8E%A5neo4j.html",
    "date": "2024-07-09 08:00:00 +0000",
    "content": "1. CMD命令提示符连接neo4j(bat脚本)\n使用下面的脚本可以连接到neo4j数据库，并执行cypher查询，将结果保存到一个文件中。\n\n@echo off\nsetlocal enabledelayedexpansion\n\nrem Neo4j credentials and host\nset NEO4J_USER=neo4j\nset NEO4J_PASSWORD=neo4j_password\nset NEO4J_HOST=localhost\nset NEO4J_PORT=7475\n\nrem Backend URL\nset BACKEND_URL=http://localhost:8089/audit/publishAuditNodes?auditNodeIds=\n\nrem Temp file to store result\nset RESULT_FILE=cypher_result.json\n\nrem Cypher query\nset CYPHER_QUERY=MATCH (n:Person) ^\nWHERE n.name CONTAINS 'test' ^\nRETURN n\n\nrem Send Cypher request\nset CYPHER_REQUEST=curl -u %NEO4J_USER%:%NEO4J_PASSWORD% -H \"Content-Type: application/json\" -d \"{\\\"statements\\\":[{\\\"statement\\\":\\\"!CYPHER_QUERY!\\\"}]}\" http://%NEO4J_HOST%:%NEO4J_PORT%/db/data/transaction/commit\n\n!CYPHER_REQUEST! > %RESULT_FILE%\n\n\n\n如果需要进一步对数据处理，可能需要另外安装jq工具。注意CMD命令的SET /p命令有长度限制（1024个字符），如果查询结果过长，想要保存到变量中得另外处理比如使用数组（参考: http://www.bathome.net/thread-17887-1-1.html），这种情况就会比较麻烦。\n\n2. 使用powershell连接neo4j\npowershell 相比命令提示符更加强大，且没有上面的长度限制。可以使用下面的脚本连接neo4j。\n\n比如我现在想从 neo4j 中读取出一些数据并传递给另一个后端服务，可以使用下面的脚本。当数据量较大时如果使用bat脚本就会出现下面的nodeIds被截断的情况，而powershell脚本则不会有这个问题。\n\n# Neo4j credentials and host\n$NEO4J_USER = \"neo4j\"\n$NEO4J_PASSWORD = \"1qaz@WSX\"\n$NEO4J_HOST = \"localhost\"\n$NEO4J_PORT = 7475\n\n# Backend URL\n$BACKEND_URL = \"http://localhost:8089/audit/publish?nodeIds=\"\n\n# Cypher query\n$CYPHER_QUERY = @\"\nMATCH (n:Audit{label: 'Relationship', status: 3})\nWITH n, apoc.convert.fromJsonMap(n.info) AS info\nWHERE info.source = 'CBDB'\nRETURN COLLECT(DISTINCT n.nodeId) AS nodeIds\n\"@\n\n# Send Cypher request\n$CYPHER_REQUEST = @{\n    Uri = \"http://${NEO4J_HOST}:${NEO4J_PORT}/db/data/transaction/commit\"\n    Method = \"POST\"\n    Headers = @{\n        \"Content-Type\" = \"application/json\"\n    }\n    Body = @{\n        statements = @(@{statement = $CYPHER_QUERY})\n    } | ConvertTo-Json\n    Credential = [PSCredential]::new($NEO4J_USER, (ConvertTo-SecureString $NEO4J_PASSWORD -AsPlainText -Force))\n}\n\n$response = Invoke-RestMethod @CYPHER_REQUEST\n\n# Read nodeIds from response\ntry {\n    $nodeIds = $response.results[0].data[0].row[0] -join ','\n    # Output nodeIds\n    Write-Output \"NodeIds: $nodeIds\"\n    \n    # Send POST request to backend\n    $BACKEND_REQUEST = @{\n        Uri = \"$BACKEND_URL$nodeIds\"\n        Method = \"POST\"\n    }\n    Invoke-RestMethod @BACKEND_REQUEST\n} catch {\n    Write-Output \"Error parsing response: $_\"\n}\n\n"
  },
  {
    "title": "饥荒切换离线与在线模式",
    "url": "/%E5%85%B6%E4%BB%96%E5%AE%9E%E8%B7%B5/2024/07/02/%E9%A5%A5%E8%8D%92%E5%88%87%E6%8D%A2%E7%A6%BB%E7%BA%BF%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%A8%A1%E5%BC%8F.html",
    "date": "2024-07-02 15:30:00 +0000",
    "content": "在游戏饥荒中，如果已经以离线或者在线模式创建了世界，就无法直接在游戏中切换离线与在线模式（比如有的时候想在没有网络的环境下玩之前创建的在线模式世界）。但是可以通过修改存档文件来实现。\n\n存档路径: C:\\Users\\xxx\\Documents\\Klei\\DoNotStarveTogether\\xxxxxxx\\\n\n\n  进入需要修改的存档文件夹，比如Cluster_1。\n  打开Master/save/shardindex，修改server选项中的online_mode为true(在线模式)或false(离线模式)。\n  打开Caves/save/shardindex，同上修改server选项中的online_mode。\n  注意根目录下的cluster.ini文件中的offline_cluster的值对最终的结果没有影响，改不改都可以。\n\n"
  },
  {
    "title": "用户权限管理系统设计",
    "url": "/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/2024/06/16/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html",
    "date": "2024-06-16 14:30:00 +0000",
    "content": "1. 需求分析\n设计一个用户权限管理系统，模型为RBAC（Role-Based Access Control），按用户-角色-权限的层次结构进行权限管理。该项目的主要功能有：\n\n\n  权限管理部分\n    \n      用户管理：用户的增删改查\n      角色管理：角色的增删改查，给用户分配角色\n      权限管理：给角色分配权限\n    \n  \n  权限控制部分\n    \n      每次请求都需要校验用户的权限，只有拥有相应权限的用户才能访问相应资源\n      用户的权限状态应当实时更新，比如退出登录、长时间未操作、修改密码等敏感信息、角色或权限变更等情况都应当立即生效并使旧的权限信息失效\n    \n  \n  可以应用于一般项目\n\n\n2. 技术选型\n\n  前端\n    \n      Vue + ElementUI 用于快速搭建页面\n      axios 用于前后端交互\n      vuex 用于状态管理\n      vue-router 用于路由管理\n    \n  \n  后端\n    \n      Spring Boot 用于快速搭建后端\n      Spring Security 用于权限控制\n      Gateway 用于统一进行权限校验，路由转发\n      Eureka 用于服务注册与发现\n      JWT 用于用户认证\n      MyBatis 用于数据库操作\n      MySQL 用于存储数据\n      Redis 用于存储用户的token黑名单等信息\n    \n  \n  其他说明\n    \n      上述几个技术栈在本项目中使用的版本为: vue 2.x, jdk 1.8, spring boot 2.x, mysql 8.x, redis 3.x\n    \n  \n\n\n3. 系统设计\n3.1 数据库设计\n3.1.1 mysql\n包括用户表、角色表、权限表、用户角色关联表、角色权限关联表等，属于比较常规的设计，以下是需要说明的几点：\n\n  数据库遵循只增不删的原则，即删除操作只做逻辑删除，不做物理删除。所以user和role表中都有一个字段status，用于标记是否删除\n  权限表中的数据直接写死，不提供修改的接口，且在后端代码中以常量的形式存在，可以方便使用例如@PreAuthorize(\"hasAuthority('XXX')\")这样的注解来进行权限校验\n  考虑到可能会有多个系统，所以在权限表中增加了一个字段platform，用于标记权限所属的系统，判断用户是否有权限进入某个系统则是通过判断用户是否有该系统的权限来实现\n\n\n3.1.2 redis\n本项目采用jwt作为用户认证的方式，在快要过期的时候会给前端返回一个新的token，而自然过期的token由于可以直接使用jwt的verify方法来校验，所以不需要存储在redis中。在用户修改密码、权限或角色被修改、用户退出登录等情况下，需要立即使旧的token失效，这时候就需要将旧的token或者其他信息存储在redis中，以便在校验token的时候进行判断。基于此，本项目在redis中存储了以下几个信息：\n\n\n  token黑名单：\n    \n      存储内容：存储了所有已经失效的token，主要是退出登录的token。\n      存储方式：使用0号库，key为失效的token，value为空字符串\n      过期时间：token的自然过期时间减去当前时间\n      使用方式：在校验token的时候，先判断token是否在黑名单中，如果在则说明用户试图使用一个已经失效的token，直接返回401\n    \n  \n  需要刷新权限的用户：\n    \n      存储内容：存储了所有需要刷新权限的用户的id（修改了密码、管理员修改了用户的角色或权限）\n      存储方式：使用1号库，key为用户id，value为(当前时间+token默认过期时长)\n      过期时间：token默认过期时长\n      使用方式：在校验token的时候，先判断用户是否在需要刷新权限的用户中，如果在则判断当前的token过期时间是否小于value，如果小于则说明该token是在权限更新前签发的，需要重新签发一个新的token给用户\n    \n  \n  刷新token表(可选，当用户一次发送多个请求又恰好需要更换token时，可以避免重复签发token)：\n    \n      存储内容：存储了即将过期的token\n      存储方式：使用2号库，key为即将过期的token，value为新的token\n      过期时间：旧token的自然过期时间减去当前时间\n      使用方式：判断用户token是否即将过期，如果是则判断用户的token是否在刷新token表中，如果在则直接将value作为新的token返回给用户，否则生成一个新的token并存储在刷新token表中\n    \n  \n\n\n3.2 后端设计\n系统的整体流程如下图所示：\n\n\n\n  \n    网关gateway会校验并解析用户的token，如果token在3.1.2中的黑名单中则直接返回401，如果user_id在3.1.2中的需要刷新权限的用户中且判断为需要刷新权限则根据具体需求签发新的token给用户或者直接返回401强制用户重新登录。如果token即将过期，则请求依旧传递到下游服务，不过会在请求头中添加新的token并返回给前端。如果token已经过期，则说明用户长时间未登录或长时间未操作，直接返回401强制用户重新登录。校验完token后，gateway会将token解析出来的用户信息传递给下游服务，如果没有token也是传递给下游服务（毕竟有些接口不需要登录就可以访问）。\n  \n  \n    从gateway传递过来的用户信息会最先到达Security的过滤器，在这里会根据用户信息设置权限，设置用户信息上下文，没有登录则设置一个匿名用户。如果匿名用户试图访问不在白名单中的接口则直接返回401。为了提高性能，这些权限都是从上一步的token解析出来的，不需要查询数据库（jwt有签名可以有效防止token中的内容伪造）。\n  \n  \n    在Security的过滤器之后，请求会到达具体的controller，一般的请求默认权限是登录用户可以访问，如果需要允许匿名用户访问则需要在controller或者方法上添加@PermitAll注解，或者在Security的配置类中添加http.authorizeRequests().antMatchers(\"/xxx\").permitAll()。如果需要特定权限才能访问，则需要在controller或者方法上添加@PreAuthorize注解，例如@PreAuthorize(\"hasAuthority('XXX')\")。\n  \n\n\n3.3 前端设计\n3.3.1 动态路由\n根据用户具体的角色和权限信息来生成对应的路由，不具有特定权限的用户或者游客则访问不到对应的页面。具体的实现方式是在前端请求登录接口成功后，将用户的角色和权限信息存储在vuex中，然后根据这些信息生成对应的路由（路由列表事先写好了各自需要的权限），最后将这些路由添加到vue-router中。这样就可以实现动态路由的功能。\n前端项目基于vue-element-admin进行开发，其中已经实现了动态路由的功能，所以这个部分只需要根据具体需求进行修改即可。\n\n3.3.2 权限刷新\n用户首次登录时会签发一个token给用户，将token保存在localStorage中，每次请求都会将token放在请求头中(axios的请求拦截器中设置)，后端会校验token的合法性。在本项目中约定后端返回401状态码时，前端会清除用户信息并退回到登录页面。返回403状态码时，前端会刷新页面重新获取用户信息保存到vuex中，然后重新发起请求。这样就可以实现权限实时更新的功能。\n\n4. 接入其他系统\n本项目的权限管理系统可以应用于一般的项目，源代码见5源代码。如果需要将本项目接入到其他系统中，需要进行以下几个步骤。\n\n4.1 后端\n\n  依赖项版本核对\n    \n      确保spring boot版本一致\n      确保根目录的pom.xml中各依赖项版本与目标项目一致或尽量接近\n      如果版本没有问题且依赖项没有冲突，则可以将当前管理后端移入目标后端中，否则需要作为一个独立的后端模块运行。\n    \n  \n  将各子模块复制到目标后端项目中\n    \n      将gateway（网关模块），common（公用模块）user（用户管理模块）移入目标后端项目。如果依赖项版本不兼容则忽略此步骤，将本项目作为一个独立的后端模块运行即可。\n    \n  \n  修改网关配置\n    \n      将各子模块都注册到同一个eureka服务，并在gateway中的配置路由转发（当后端版本不兼容时该步骤也可以进行）。具体配置可以参考gateway模块的application.yml文件。\n    \n  \n  修改数据库配置\n    \n      按具体需求调整用户表中的字段，并预置好若干角色和权限。\n      后端的common模块中有一些角色和权限的常量（在enum或constants包中），可以根据具体需求进行修改。\n    \n  \n  配置security\n    \n      使用公共模块common中的security工具类给各子模块配置好过滤器，并使用security的注解(@PreAuthorize, @PermitAll)给每个接口配置权限。\n    \n  \n\n\n4.2 前端\n\n  本项目管理系统前端\n    \n      根据后端的调整，修改api接口的地址和参数\n      根据用户表、角色表、权限表的调整，修改前端src/views/user目录下的用户管理、角色管理、权限管理的页面中的表单结构和表格结构\n      根据权限的调整，修改src/router/index.js中的路由表，在其中的meta中添加权限字段，根据权限动态生成路由\n    \n  \n  接入的其他系统的前端\n    \n      可参考本项目管理前端的方式，根据前端使用的具体技术栈来根据需求选择性的实现动态路由和权限刷新的功能\n    \n  \n\n\n5. 源代码\n本项目的源代码已经上传到github，地址为：https://github.com/lxmghct/user-role-admin\n"
  },
  {
    "title": "neo4j报错Property values can only be of primitive types or arrays thereof",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/06/14/neo4j%E6%8A%A5%E9%94%99Property-values-can-only-be-of-primitive-types-or-arrays-thereof.html",
    "date": "2024-06-14 11:30:00 +0000",
    "content": "报错内容：”Property values can only be of primitive types or arrays thereof”\n\n报错代码如下：\n@Query(\"UNWIND {auditNodes} AS auditNode \" +\n        \"MERGE (n:Audit:BaseNode {nodeId: auditNode.nodeId}) \" +\n        \"ON CREATE SET n = auditNode \" +\n        \"ON MATCH SET n += auditNode{.*, createTime: n.createTime, createBy: n.createBy, editors: n.editors} \" +\n        \"WITH n \" +\n        \"SET n.editors = CASE WHEN n.editors IS NULL THEN [{userId}] ELSE \" +\n        \"CASE WHEN NOT {userId} IN n.editors THEN n.editors + {userId} ELSE n.editors END END\")\nvoid saveAuditNodes(List<AuditNode> auditNodes, Integer userId);\n\n\n原因：neo4j 中不支持直接将含NULL的数组赋值给属性，上述代码中userId可能为NULL，所以会报错。\n\n解决方案：在进入查询前先对userId进行判空处理，或者在查询语句中将[{userId}] 改为 [] + {userId}，这种情况下userId为NULL时，该赋值语句会被忽略。即使列表中有内容比如[1,2,3] + NULL，也会被忽略（该语句完全不执行，1,2,3也不会被添加到列表中）。\n"
  },
  {
    "title": "判断ip是内网还是外网",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/06/02/%E5%88%A4%E6%96%ADip%E6%98%AF%E5%86%85%E7%BD%91%E8%BF%98%E6%98%AF%E5%A4%96%E7%BD%91.html",
    "date": "2024-06-02 04:30:00 +0000",
    "content": "内网IP的范围\nClass A: 10.0.0.0 到 10.255.255.255\nClass B: 172.16.0.0 到 172.31.255.255\nClass C: 192.168.0.0 到 192.168.255.255\n\npublic class IpChecker {\n\n    private static final Pattern PRIVATE_IP_PATTERN = Pattern.compile(\n            \"^(10\\\\.([0-9]{1,3}\\\\.){2}[0-9]{1,3})|\" +\n                    \"(172\\\\.(1[6-9]|2[0-9]|3[01])\\\\.([0-9]{1,3}\\\\.){1}[0-9]{1,3})|\" +\n                    \"(192\\\\.168\\\\.([0-9]{1,3}\\\\.){1}[0-9]{1,3})$\"\n    );\n\n    public static boolean isPrivateIP(String ip) {\n        return PRIVATE_IP_PATTERN.matcher(ip).matches();\n    }\n\n}\n\n"
  },
  {
    "title": "python剪辑音频",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/05/26/python%E5%89%AA%E8%BE%91%E9%9F%B3%E9%A2%91.html",
    "date": "2024-05-26 04:30:00 +0000",
    "content": "1. 安装 ffmpeg\n前往官网下载 ffmpeg，https://ffmpeg.org/download.html。配置好环境变量。\n\n2. 安装 pydub, simpleaudio\npip install pydub simpleaudio\n\n\n3. 剪辑音频\nfrom pydub import AudioSegment\n\ndef clip_audio(file_path, output_path, start_time_ms, end_time_ms):\n    # 加载音频文件\n    audio = AudioSegment.from_wav(file_path)\n    \n    # 剪辑指定时间段的音频\n    clipped_audio = audio[start_time_ms:end_time_ms]\n    \n    # 保存剪辑后的音频文件\n    clipped_audio.export(output_path, format=\"wav\")\n\n# 示例使用\ninput_wav = \"input.wav\"  # 输入WAV文件路径\noutput_wav = \"clipped_output.wav\"  # 输出剪辑后文件路径\nstart_time = 5 * 1000  # 起始时间（毫秒）\nend_time = 35 * 1000  # 结束时间（毫秒）\nclip_audio(input_wav, output_wav, start_time, end_time)\n\n"
  },
  {
    "title": "neo4j数据备份报错",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/05/25/neo4j%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E6%8A%A5%E9%94%99.html",
    "date": "2024-05-25 02:30:00 +0000",
    "content": "问题描述\n在使用 neo4j 3.5 版本时，停止数据库后并使用neo4j-admin备份数据库时，报错如下：\ncommand failed: Active logical log detected, this might be a source of inconsistencies.\nPlease recover database.\nTo perform recovery please start database in single mode and perform clean shutdown.\n\n\n解决方法\n\n  确保数据库已经停止\n  在单用户模式下启动数据库，修改neo4j.conf文件，添加或修改如下配置：\n    dbms.mode=single\n    \n  \n  重启数据库后再停止，然后注释掉dbms.mode=single配置，再进行备份操作（该方法尝试过但还是报错）。而在dbms.mode=single模式下，直接使用neo4j-admin备份数据库则可以成功。\n\n"
  },
  {
    "title": "redis存储ip段问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/05/24/redis%E5%AD%98%E5%82%A8ip%E6%AE%B5%E9%97%AE%E9%A2%98.html",
    "date": "2024-05-24 01:45:00 +0000",
    "content": "问题描述\n有个需求是根据 ip 来获取对应的用户，从而让 ip 地址匹配的用户进行自动登录等操作。想到的解决方式是将 ip -> userId 的映射关系存储到 redis 中，然后根据 ip 获取对应的 userId。\n\nip 工具类如下：\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class IpUtils {\n\n    public static List<String> parseIpRange(String ipRange) {\n        List<String> ips = new ArrayList<>();\n        String[] parts = ipRange.split(\";\");\n        for (String part : parts) {\n            if (part.contains(\"-\")) {\n                String[] range = part.split(\"-\");\n                String startIp = range[0].trim();\n                String endIp = range[1].trim();\n                List<String> rangeIps = generateRangeIps(startIp, endIp);\n                ips.addAll(rangeIps);\n            } else {\n                ips.add(part.trim());\n            }\n        }\n        return ips;\n    }\n\n    private static List<String> generateRangeIps(String startIp, String endIp) {\n        List<String> ips = new ArrayList<>();\n        String[] startParts = startIp.split(\"\\\\.\");\n        String[] endParts = endIp.split(\"\\\\.\");\n        Integer[] intStartParts = Arrays.stream(startParts).map(Integer::parseInt).toArray(Integer[]::new);\n        Integer[] intEndParts = Arrays.stream(endParts).map(Integer::parseInt).toArray(Integer[]::new);\n\n        do {\n            ips.add(String.join(\".\", Arrays.stream(intStartParts).map(String::valueOf).toArray(String[]::new)));\n            plusIp(intStartParts);\n        } while (compareIp(intStartParts, intEndParts) <= 0);\n\n        for (int i = 0; i < 4; i++) {\n            if (!intStartParts[i].equals(intEndParts[i])) {\n                break;\n            }\n        }\n\n        return ips;\n    }\n\n    private static int compareIp(Integer[] ip1, Integer[] ip2) {\n        for (int i = 0; i < 4; i++) {\n            if (!ip1[i].equals(ip2[i])) {\n                return ip1[i] - ip2[i];\n            }\n        }\n        return 0;\n    }\n\n    private static void plusIp(Integer[] ip) {\n        ip[3]++;\n        for (int i = 3; i > 0; i--) {\n            if (ip[i] > 255) {\n                ip[i] = 0;\n                ip[i - 1]++;\n            }\n        }\n    }\n\n}\n\n\njedis 工具类如下：\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.Pipeline;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\nimport java.util.Map;\n\n@Component\npublic class JedisUtils {\n\n    private final JedisPool jedisPool;\n\n    private static JedisUtils self;\n\n    // 过期时间为2小时\n    public static final int EXPIRE_SECONDS = 7200;\n\n    @Autowired\n    public JedisUtils(JedisPool jedisPool) {\n        this.jedisPool = jedisPool;\n    }\n\n    @PostConstruct\n    public void init() {\n        self = this;\n    }\n\n    /**\n     * 批量删除redis中的key\n     *\n     * @param keys key列表\n     */\n    public static void batchDeleteKey(List<String> keys) {\n        try (Jedis jedis = self.jedisPool.getResource()) {\n            Pipeline pipeline = jedis.pipelined();\n            for (String key : keys) {\n                pipeline.del(key);\n            }\n            pipeline.sync();\n        }\n    }\n\n    /**\n     * 批量插入redis中的key-value\n     *\n     * @param keyValues key-value列表\n     */\n    public static void batchInsertKeyValues(Map<String, String> keyValues) {\n        try (Jedis jedis = self.jedisPool.getResource()) {\n            Pipeline pipeline = jedis.pipelined();\n            for (Map.Entry<String, String> entry : keyValues.entrySet()) {\n                pipeline.setex(entry.getKey(), EXPIRE_SECONDS, entry.getValue());\n            }\n            pipeline.sync();\n        }\n    }\n\n    /**\n     * 使用lua脚本清空所有数据并批量插入新数据，确保原子性\n     *\n     * @param keyValues key-value列表\n     */\n    public static void flushAllAndBatchInsertKeyValues(Map<String, String> keyValues) {\n        try (Jedis jedis = self.jedisPool.getResource()) {\n            StringBuilder scriptBuilder = new StringBuilder();\n            scriptBuilder.append(\"redis.call('FLUSHDB');\");\n            for (Map.Entry<String, String> entry : keyValues.entrySet()) {\n                scriptBuilder.append(\"redis.call('SETEX', '\")\n                        .append(entry.getKey()).append(\"', \")\n                        .append(EXPIRE_SECONDS).append(\", '\")\n                        .append(entry.getValue()).append(\"');\");\n            }\n            jedis.eval(scriptBuilder.toString());\n        }\n    }\n\n}\n\n\n\n使用示例：\npublic class Main {\n\n    public static void main(String[] args) {\n        String ipRange = \"192.168.2.2-192.168.3.4;192.168.3.3\";\n        String userId = \"123\"\n        List<String> ips = IpUtils.parseIpRange(ipRange);\n        Map<String, String> keyValues = new HashMap<>();\n        for (String ip : ips) {\n            keyValues.put(ip, userId);\n        }\n        JedisUtils.flushAllAndBatchInsertKeyValues(keyValues);\n    }\n\n}\n\n\n但上述代码存在一个问题，如果 ip 段很大，比如 10.0.0.1-192.168.0.1，那么生成的 ip 列表会非常大，约(192-10) * 256^3 数量级达到了上亿，这样的数据量无论是生成还是存储都是非常大的开销。因此需要优化存储方式。\n\n优化方案\n由原来的存储每个 ip 改为存储 ip 段，startIp -> endIp:userId，这样可以减少存储的数据量。为了提高性能，使用有序集合 zset 来存储 startIp，同时 ip 采用整数形式存储，通过或运算将 ip 转换为整数，这样可以方便比较大小。\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.Pipeline;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n@Component\npublic class IpRangeStore {\n\n    private final JedisPool jedisPool;\n\n    private static IpRangeStore self;\n\n    // 过期时间为2小时\n    public static final int EXPIRE_SECONDS = 7200;\n\n    @Autowired\n    public IpRangeStore(JedisPool jedisPool) {\n        this.jedisPool = jedisPool;\n    }\n\n    @PostConstruct\n    public void init() {\n        self = this;\n    }\n\n    /**\n     * 批量添加ip段\n     *\n     * @param ipUserIdMap  ip段-用户id映射\n     * @param deleteOrigin 是否删除原数据\n     */\n    public static void batchAddIpRanges(Map<String, String> ipUserIdMap, boolean deleteOrigin) {\n        try (Jedis jedis = self.jedisPool.getResource()) {\n            Pipeline pipeline = jedis.pipelined();\n            if (deleteOrigin) {\n                pipeline.del(\"ip_ranges\");\n            }\n            for (Map.Entry<String, String> entry : ipUserIdMap.entrySet()) {\n                String ipString = entry.getKey();\n                if (ipString.contains(\"-\")) {\n                    String[] ipRange = ipString.split(\"-\");\n                    long start = ipToLong(ipRange[0]);\n                    long end = ipToLong(ipRange[1]);\n                    pipeline.zadd(\"ip_ranges\", start, end + \":\" + entry.getValue());\n                } else {\n                    long ip = ipToLong(ipString);\n                    pipeline.zadd(\"ip_ranges\", ip, ip + \":\" + entry.getValue());\n                }\n            }\n            pipeline.expire(\"ip_ranges\", EXPIRE_SECONDS);\n            pipeline.sync();\n        }\n    }\n\n    /**\n     * 批量删除指定IP\n     *\n     * @param ips 要删除的IP列表\n     */\n    public static void batchDeleteIpRanges(List<String> ips) {\n        try (Jedis jedis = self.jedisPool.getResource()) {\n            Pipeline pipeline = jedis.pipelined();\n            for (String ip : ips) {\n                pipeline.zrem(\"ip_ranges\", ip);\n            }\n            pipeline.sync();\n        }\n    }\n\n    public static Integer findUserIdByIp(String ipAddress) {\n        try (Jedis jedis = self.jedisPool.getResource()) {\n            String userId = findUserIdByIp(ipAddress, jedis);\n            return userId == null ? null : Integer.parseInt(userId);\n        }\n    }\n\n    private static long ipToLong(String ipAddress) {\n        String[] ipParts = ipAddress.split(\"\\\\.\");\n        long ip = 0;\n        for (String ipPart : ipParts) {\n            ip <<= 8;\n            ip |= Integer.parseInt(ipPart);\n        }\n        return ip;\n    }\n\n    private static String findUserIdByIp(String ipAddress, Jedis jedis) {\n        long ip = ipToLong(ipAddress);\n        // 查询ip_ranges中离ip最近且小于等于ip的ip段\n        Set<String> results = jedis.zrevrangeByScore(\"ip_ranges\", ip, 0, 0, 1);\n        if (!results.isEmpty()) {\n            String result = results.iterator().next();\n            String[] parts = result.split(\":\");\n            if (Long.parseLong(parts[0]) >= ip) {\n                return parts[1];\n            }\n        }\n        return null;\n    }\n\n}\n\n"
  },
  {
    "title": "提取rtf文件中的高亮文本",
    "url": "/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/2024/04/22/%E6%8F%90%E5%8F%96rtf%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%AB%98%E4%BA%AE%E6%96%87%E6%9C%AC.html",
    "date": "2024-04-22 07:30:00 +0000",
    "content": "1. 问题描述\n我最近需要处理一个 rtf 格式的命名实体识别的数据集，其中包含了一些高亮文本，不同的颜色代表不同的实体类型。我需要提取这些高亮文本，以便后续处理。\n\nrtf 文件中的内容如图所示：\n\n\n而 rtf 的格式比较复杂，下面是使用文本编辑器打开的 rtf 文件的内容：\n\n{\\rtf1\\ansi\\ansicpg936\\deff0\\deflang1033\\deflangfe2052{\\fonttbl{\\f0\\fnil\\fprq2\\fcharset134 \\'cb\\'ce\\'cc\\'e5;}{\\f1\\fswiss\\fcharset238{\\*\\fname Arial;}Arial CE;}}\n{\\colortbl ;\\red0\\green0\\blue0;\\red255\\green255\\blue255;\\red34\\green177\\blue76;\\red255\\green242\\blue0;\\red237\\green28\\blue36;\\red214\\green214\\blue214;\\red185\\green122\\blue87;\\red63\\green72\\blue204;\\red255\\green174\\blue201;\\red163\\green73\\blue164;}\n\\viewkind4\\uc1\\pard\\lang2052\\f0\\fs30\\par\n\n\\'d7\\'d3\\'d3\\'ce\\'a3\\'ba\\cf5\\highlight6\\'bf\\'d7\\'d7\\'d3\\cf0\\highlight0\\'b5\\'c4\\'d6\\'f8\\'c3\\'fb\\'b5\\'dc\\'d7\\'d3\\'a3\\'ac\\'d0\\'d5\\'d1\\'d4\\'a3\\'ac\\'c3\\'fb\\'d9\\'c8\\'a3\\'ac\\'d7\\'d6\\'d7\\'d3\\'d3\\'ce\\'a3\\'ac\\'d2\\'e0\\'b3\\'c6\\ldblquote\\'d1\\'d4\\'d3\\'ce\\rdblquote\\ldblquote\\'ca\\'e5\\'ca\\'cf\\rdblquote\\'a3\\'ac\\cf4\\highlight7\\'b4\\'ba\\'c7\\'ef\\cf0\\highlight0\\'c4\\'a9\\cf8\\highlight9\\b\\'ce\\'e2\\'b9\\'fa\\cf0\\highlight0\\b0\\'c8\\'cb\\'a3\\'ac\\'d3\\'eb\\cf5\\highlight6\\'d7\\'d3\\'cf\\'c4\\cf0\\highlight0\\'a1\\'a2\\cf5\\highlight6\\b\\'d7\\'d3\\'d5\\'c5\\cf0\\highlight0\\b0\\'c6\\'eb\\'c3\\'fb\\'a3\\'ac\\ldblquote\\cf3\\highlight4\\ul\\b\\'bf\\'d7\\'c3\\'c5\\'ca\\'ae\\'d5\\'dc\\cf0\\highlight0\\ulnone\\b0\\rdblquote\\'d6\\'ae\\'d2\\'bb\\'a3\\'ac\\'d4\\'f8\\'ce\\'aa\\cf8\\highlight9\\b\\'ce\\'e4\\'b3\\'c7\\cf2\\highlight10\\'d4\\'d7\\cf0\\highlight0\\b0\\'a1\\'a3\\'d7\\'c8\\'ba\\'f1\\'a3\\'ba\\'d7\\'cc\\'c8\\'f3\\'d4\\'f3\\'b1\\'bb\\'a1\\'a3\\'d7\\'c8\\'a3\\'ac\\'cd\\'a8\\ldblquote\\'d7\\'cc\\rdblquote\\'a1\\'a3\\fs18\\par\n}\n\n\n可以看到如果直接读取 rtf 文件的内容，工作量会比较大。所以需要借助一些工具来处理 rtf 文件。\n\n2. 方法探索\n一开始根据 chatgpt 的建议使用了 Python 的 Rtf15Reader 或者 PyRTF 来处理 rtf 文件，其中使用了 Rtf15Reader 的部分代码如下：\n\nfrom pyth.plugins.rtf15.reader import Rtf15Reader\nfrom pyth.plugins.plaintext.writer import PlaintextWriter\ndoc = Rtf15Reader.read(rtf_content)\ntext = PlaintextWriter.write(doc).getvalue()\n\n\n但是这两个库都无法正确从我目前使用的 rtf 文件中提取高亮文本，由于我对 rtf 文件的格式也不是很了解，所以我也不知道这两个库无法正确处理的原因。\n\n3. 解决方案\n由于直接处理不好处理，所以我打算把 rtf 文件转换成 html 文件，然后再从 html 文件中提取高亮文本，毕竟自己对 html 文件比较了解，更容易提取出其中的高亮文本。\n\n3.1. rtf 转 html\n\n转换方式是使用 Python 的 win32 模块来调用 Word 来打开 rtf 文件并保存为 html 文件。\n\nimport os\nimport win32com.client as win32\nimport codecs\nimport shutil\n\n# 创建一个Word应用对象\nword = win32.gencache.EnsureDispatch('Word.Application')\n\n# 获取文件夹中的所有文件\nrtf_folder = 'rtf'\nhtml_folder = 'html'\n\nif not os.path.exists(html_folder):\n    os.makedirs(html_folder)\n\ncurrent_folder = os.path.dirname(os.path.abspath(__file__))\n\n# 先获取一下rtf文件夹的所有文件，防止word打开时出现文件夹中有临时文件的情况\n# 不然有可能会报错: pywintypes.com_error: (-2147352567, '发生意外。', (0, 'Microsoft Word', '很抱歉，找不到您的文件。该项目是否已移动、重命名或删除?\\r (D:\\\\projects\\\\python\\\\...\\\\rtf\\\\~$015.rtf)', 'wdmain11.chm', 24654, -2146823114), None)\nrtf_files = os.listdir(rtf_folder)\n\nfor filename in rtf_files:\n    # 检查文件是否是RTF文件\n    if filename.endswith('.rtf'):\n        # 获取文件的完整路径\n        rtf_path = os.path.join(current_folder, rtf_folder, filename)\n        # 打开RTF文件\n        doc = word.Documents.Open(rtf_path)\n        # 另存为HTML\n        wdFormatHTML = 8 # Word的HTML格式常数\n        html_path = os.path.join(current_folder, html_folder, filename.replace('.rtf', '.html'))\n        try:\n            doc.SaveAs(html_path, FileFormat=wdFormatHTML)\n            # 关闭文档\n            doc.Close()\n            # 以UTF-8编码保存HTML文件\n            with codecs.open(html_path, 'r', 'gbk') as file:\n                content = file.read()\n            with codecs.open(html_path, 'w', 'utf-8') as file:\n                file.write(content)\n        except Exception as e:\n            print('Error File:', filename)\n            print(e)\n            # 移除错误的html文件, 包括xxx.html和xxx.files目录\n            os.remove(html_path)\n            shutil.rmtree(html_path.replace('.html', '.files'), ignore_errors=True)\n            continue\n\n# 关闭Word应用\nword.Quit()\n\n\n上述代码中有两个需要注意的地方：\n\n  由于 Word 打开 rtf 文件时会生成一些临时文件，如果直接使用os.listdir获取文件列表，可能会读取到这些临时文件从而导致报错，所以需要先获取文件列表，然后再处理文件。\n  由于 Word 保存 html 文件时默认使用 gbk 编码，不方便后续处理，所以需要读取后再以 utf-8 编码保存。此时如果使用浏览器打开 html 文件，可能会出现乱码，但是不影响后续处理。\n\n\n3.2. 提取高亮文本\n读取上一步生成的 html 文件，解析带有background属性的span标签，提取其中的文本。html 的格式大概如下：\n\n<div class=\"WordSection1\">\n    <p class=\"MsoNormal\">\n        <span>other text</span>\n        <!-- 高亮文本在b标签内 -->\n        <b>\n            <span style=\"...\"></span>\n        </b>\n    </p>\n</div>\n\n在读取 html 方面，js 具有一定优势，所以采用 nodejs 来处理 html 文件。cheerio 是一个类似 jQuery 的库，可以方便地解析 html 文件。\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst cheerio = require(\"cheerio\");\n\nfunction parseHtmlFile(filePath) {\n  const content = fs.readFileSync(filePath, \"utf-8\");\n  const $ = cheerio.load(content);\n\n  let wordIndex = 0;\n  let allText = \"\";\n  // 高亮颜色与类型的对应关系\n  const colorMap = {\n    silver: \"人物\",\n    yellow: \"知识点\",\n    aqua: \"朝代\",\n    red: \"文献\",\n    lime: \"事件\",\n    gray: \"官职\",\n    fuchsia: \"地名\",\n  };\n  const resultMap = {};\n\n  $(\".MsoNormal\")\n    .children()\n    .each((i, elem) => {\n      // 依次遍历子元素\n      const text = $(elem).text();\n      allText += text;\n      if (elem.name === \"b\") {\n        // 找到高亮文本\n        const span = $(elem).find(\"span\");\n        const style = span.attr(\"style\");\n        const match = style.match(/background:(.*?)(;|$)/); // (;|$) 匹配分号或者字符串结尾\n        if (match) {\n          let color = match[1];\n          color = colorMap[color] || color;\n          const spanText = span.text();\n          if (!resultMap[color]) {\n            resultMap[color] = [];\n          }\n          resultMap[color].push({\n            text: spanText,\n            start: wordIndex,\n            end: wordIndex + spanText.length,\n          });\n        }\n      }\n      wordIndex += text.length;\n    });\n\n  return {\n    content: allText,\n    resultMap: resultMap,\n  };\n}\n\nfunction parseHtmlFilesInDirectory(dirPath) {\n  const files = fs.readdirSync(dirPath);\n  const results = [];\n\n  for (const file of files) {\n    if (path.extname(file) === \".html\") {\n      const filePath = path.join(dirPath, file);\n      const result = parseHtmlFile(filePath);\n      results.push({ file, result });\n    }\n  }\n\n  return results;\n}\n\nconst dirPath = \"html\";\nconst results = parseHtmlFilesInDirectory(dirPath);\n\n/**\n * 输出示例结果\n * @param {*} results\n */\nfunction getExampleOutput(results) {\n  const outputDir = \"html-output\";\n  if (!fs.existsSync(outputDir)) {\n    fs.mkdirSync(outputDir);\n  }\n  // 写入到文件, utf-8 编码格式\n  // fs.writeFileSync('result.json', JSON.stringify(results, null, 2), 'utf-8');\n  for (const { file, result } of results) {\n    fs.writeFileSync(\n      path.join(outputDir, file.replace(\".html\", \".json\")),\n      JSON.stringify(result, null, 2),\n      \"utf-8\"\n    );\n  }\n}\n\n/**\n * 输出doccano格式结果, jsonl格式\n * {\"id\": 1, \"text\": \"text\", \"labels\": [[0, 4, \"label\"]]}\n * @param {*} results\n */\nfunction getDoccanoOutput(results) {\n  const doccanoOutputDir = \"doccano-output\";\n  if (!fs.existsSync(doccanoOutputDir)) {\n    fs.mkdirSync(doccanoOutputDir);\n  }\n  const jsonlData = [];\n  for (const { file, result } of results) {\n    const id = file.replace(\".html\", \"\");\n    const { content, resultMap } = result;\n    const labels = [];\n    for (const key in resultMap) {\n      const items = resultMap[key];\n      for (const item of items) {\n        labels.push([item.start, item.end, key]);\n      }\n    }\n    // 按照起始位置排序\n    labels.sort((a, b) => a[0] - b[0]);\n    jsonlData.push({\n      id,\n      text: content,\n      label: labels,\n      Comments: [],\n    });\n  }\n  fs.writeFileSync(\n    path.join(doccanoOutputDir, \"data.jsonl\"),\n    jsonlData.map((item) => JSON.stringify(item)).join(\"\\n\"),\n    \"utf-8\"\n  );\n}\n\n// getExampleOutput(results);\ngetDoccanoOutput(results);\n\n\n检测背景色采用了正则表达式，匹配background属性的值，然后根据颜色值来判断高亮文本的类型。上面的colorMap是颜色值与类型的对应关系，是通过事先输出所有的颜色和对应的文本，从而分析出来的。\n"
  },
  {
    "title": "spring gateway统一配置过滤器",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2024/04/21/spring-gateway%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8.html",
    "date": "2024-04-21 15:30:00 +0000",
    "content": "在使用spring gateway时，我想给每个转发的路由都添加几个过滤器，但是不想每个路由都添加一遍，所以想到了统一配置过滤器。\n\n下面是application.yml配置文件的内容，由于在其他地方统一配置了过滤器，所以这里不需要再写filters字段。\n\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: test\n          uri: lb://test\n          predicates:\n              - Path=/api/test/**\n        - id: user\n          uri: lb://user\n          predicates:\n              - Path=/api/user/**\n\n\n这里假定已经配置好了PreGatewayFilterFactory和PostGatewayFilterFactory两个过滤器：\n// filter/PreGatewayFilterFactory.java\npublic class PreGatewayFilterFactory extends AbstractGatewayFilterFactory<PreGatewayFilterFactory.Config> {\n    // ...\n}\n\n// filter/PostGatewayFilterFactory.java\npublic class PostGatewayFilterFactory extends AbstractGatewayFilterFactory<PostGatewayFilterFactory.Config> {\n    // ...\n}\n\n\n下面是统一配置过滤器的代码：\n// config/GatewayFilterConfig.java\nimport org.springframework.cloud.gateway.filter.FilterDefinition;\nimport org.springframework.cloud.gateway.route.RouteDefinitionLocator;\nimport org.springframework.cloud.gateway.route.RouteLocator;\nimport org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class GatewayConfig {\n\n    private final RouteDefinitionLocator routeDefinitionLocator;\n\n    public GatewayConfig(RouteDefinitionLocator routeDefinitionLocator) {\n        this.routeDefinitionLocator = routeDefinitionLocator;\n    }\n\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n        // 获取所有在application.yml中配置的路由定义\n        routeDefinitionLocator.getRouteDefinitions().subscribe(routeDefinition -> {\n            // 为每个路由添加几个额外的过滤器\n            routeDefinition.getFilters().add(new FilterDefinition(\"Pre\"));\n            routeDefinition.getFilters().add(new FilterDefinition(\"Post\"));\n            // 去掉路径中的前两个段\n            routeDefinition.getFilters().add(new FilterDefinition(\"RewritePath=/(?<segment1>[^/]*)/(?<segment2>[^/]*)/(?<segment3>.*)$, /$\\\\{segment3}\"));\n        });\n        return builder.routes().build();\n    }\n}\n\n\n上述代码添加了Pre和Post两个过滤器，以及一个RewritePath过滤器，用来去掉路径中的前两个段。这样就可以在application.yml中配置路由，然后在GatewayConfig中统一添加过滤器。\n"
  },
  {
    "title": "gateway转发请求时security缓存问题",
    "url": "/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/2024/04/20/gateway%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82%E6%97%B6security%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98.html",
    "date": "2024-04-20 15:00:00 +0000",
    "content": "1. 问题描述\n我在使用Spring Cloud Gateway转发请求时，发现请求到下游服务时，Security的上下文并没有更新，导致请求的用户信息不正确。\n\n例如: 连续以未登录和登录的状态请求同一个接口，会导致登录时的接口依旧获取不到用户信息，获取到的是未登录时的信息\n\n原因是第一次请求时，Security过滤器拦截了请求，但请求的上下文被缓存了，第二次请求时，Security过滤器不再拦截，通过过滤器后，直接从缓存中获取了未登录时的上下文\n\n2. 解决方法\n给请求的url添加一个随机参数，这样每次请求的url都不一样，就不会从缓存中获取上下文了。以下是一个Gateway的过滤器示例，给请求的url添加了一个随机id参数。\n\npackage com.example.gateway.filter;\n\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\nimport org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.stereotype.Component;\n\nimport java.net.URI;\nimport java.util.UUID;\n\n@Component\npublic class PreGatewayFilterFactory extends AbstractGatewayFilterFactory<PreGatewayFilterFactory.Config> {\n\n    public PreGatewayFilterFactory() {\n        super(Config.class);\n    }\n\n    @Override\n    public GatewayFilter apply(Config config) {\n        return (exchange, chain) -> {\n            ServerHttpRequest request = exchange.getRequest();\n            ServerHttpRequest.Builder builder = request.mutate();\n\n            // 添加随机id，否则传递到下游服务的Security后会被缓存，同一个请求反复发送会导致后续Servlet上下文被缓存不会更新\n            String url = request.getURI().toString();\n            builder.uri(URI.create(url + (url.contains(\"?\") ? \"&\" : \"?\") +\n                    \"random-id=\" + UUID.randomUUID().toString().substring(0, 8)));\n            // 其他逻辑\n            // ...\n            return chain.filter(exchange.mutate().request(builder.build()).build());\n        };\n    }\n\n}\n\n"
  },
  {
    "title": "mvn package时报错：jar中没有主清单属性",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/04/19/mvn-package%E6%97%B6%E6%8A%A5%E9%94%99-jar%E4%B8%AD%E6%B2%A1%E6%9C%89%E4%B8%BB%E6%B8%85%E5%8D%95%E5%B1%9E%E6%80%A7.html",
    "date": "2024-04-19 03:00:00 +0000",
    "content": "解决方法：在 pom.xml 中添加 spring-boot-maven-plugin 插件。\n\n<plugins>\n    <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n    </plugin>\n</plugins>\n\n"
  },
  {
    "title": "git在不影响原提交时间的情况下修改提交顺序",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/04/17/git%E5%9C%A8%E4%B8%8D%E5%BD%B1%E5%93%8D%E5%8E%9F%E6%8F%90%E4%BA%A4%E6%97%B6%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BF%AE%E6%94%B9%E6%8F%90%E4%BA%A4%E9%A1%BA%E5%BA%8F.html",
    "date": "2024-04-17 13:00:00 +0000",
    "content": "问题描述\n在使用 git 进行版本控制时，有时候为了让提交记录更加清晰，我们需要调整提交的顺序。如果直接使用git rebase -i命令进行交互式 rebase，完成 rebase 并提交到 github 后，会导致受影响的提交记录的提交时间被修改，这是因为 git rebase 实际上是创建了新的提交对象，而不是简单地重新排列现有的提交。因此，每次 rebase 都会产生新的提交 ID，并将当前时间作为提交时间。\n\n解决方案\n如果希望在修改提交顺序的同时保留原始提交时间，可以使用rebase --committer-date-is-author-date选项。\n\n完整步骤\n修改提交顺序的完整步骤如下：\n\n1. 确保工作目录干净\n确保工作目录没有未提交的更改，可以使用 git status 来检查。\n\n2. 执行 rebase\ngit rebase -i --committer-date-is-author-date <commit-id>\n\n其中<commit-id>是需要调整的提交记录的前一个提交记录的 ID。\n或者也可以使用HEAD~n来指定最近的 n 个提交记录。\ngit rebase -i --committer-date-is-author-date HEAD~n\n\n\n3. 编辑 rebase 列表\n执行上述命令后，会打开一个编辑器，列出了需要 rebase 的提交记录。在编辑器中，可以调整提交记录的顺序，删除不需要的提交记录，或者修改提交记录的操作方式。\n\n比如：\npick ca61b2e Create test.md\npick b2d85fd Update test.md\npick fda1c25 Create test1.md\n\n可以用 vim 的快捷键快速调整提交记录的顺序，先按dd删除一行，然后按p粘贴到需要的位置。\n\n4. 保存并退出编辑器\n保存并退出编辑器后，git 会自动执行 rebase 操作。如果有冲突需要解决，按照提示解决冲突后，使用git rebase --continue继续 rebase。\n\n5. 推送到远程仓库\n完成 rebase 后，使用git push -f强制推送到远程仓库。\n"
  },
  {
    "title": "spring boot使用feign请求在接收返回的数据时报错问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/04/09/spring-boot%E4%BD%BF%E7%94%A8feign%E8%AF%B7%E6%B1%82%E5%9C%A8%E6%8E%A5%E6%94%B6%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E6%97%B6%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98.html",
    "date": "2024-04-09 08:30:00 +0000",
    "content": "我在 spring boot 项目中使用 feign 请求在另一个系统中创建用户时，用户成功创建，并且在 return 语句前都没有问题，但是在接收返回的数据时报错了。错误信息如下：\n\nfeign.RetryableException: Incomplete output stream executing POST http://localhost:8094/user/batchCreateUser\n\tat feign.FeignException.errorExecuting(FeignException.java:213)\n\tat feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:115)\n\tat feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:80)\n\tat feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:103)\n\tat com.sun.proxy.$Proxy157.batchCreateUser(Unknown Source)\n\tat com.hc.display.controller.UserManageController.createAnnotationUser(UserManageController.java:226)\n\tat com.hc.display.controller.UserManageController.addOneUser(UserManageController.java:53)\n\tat com.hc.display.controller.UserManageController$$FastClassBySpringCGLIB$$43114b6c.invoke(<generated>)\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:295)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688)\n\tat com.hc.display.controller.UserManageController$$EnhancerBySpringCGLIB$$a254db94.addOneUser(<generated>)\n\n\n其中批量创建用户的代码如下：\n\n/**\n * 批量创建用户\n *\n * @param users 用户信息列表\n */\n@PostMapping(\"/batchCreateUser\")\npublic ResponseVO<String> batchCreateUser(@RequestBody List<UserCreateDTO> users) {\n    List<UserNode> userNodes = new ArrayList<>();\n    for (UserCreateDTO user : users) {\n        userNodes.add(new UserNode(user.getUserId(), user.getUserName()));\n    }\n    userNodeService.batchCreateUser(userNodes);\n    return ResponseVO.success();\n}\n\n\n其中的 UserCreateDTO 定义如下：\n@ApiModel(\"UserCreateDTO\")\npublic class UserCreateDTO {\n    @ApiParam(value = \"用户userId(用户在MySQL中的id)\", required = true)\n    private Integer userId;\n    @ApiParam(value = \"用户名\", required = true)\n    private String userName;\n    public Integer getUserId() {\n        return userId;\n    }\n    public String getUserName() {\n        return userName;\n    }\n}\n\n\nfeign 的配置类如下：\n\n@Component\n@FeignClient(name = \"annotation\", url = \"http://localhost:8094\")\npublic interface AnnotationInterfaces {\n\n    @PostMapping(value = \"/user/batchCreateUser\", consumes = MediaType.APPLICATION_JSON_VALUE)\n    ResponseVO<String> batchCreateUser(@RequestBody List<?> users);\n}\n\n返回值类型的 ResponseVO 在两个系统中都是相同的。而且其他的 feign 接口也是用了 ResponseVO 作为返回值类型，也没有问题。经过多次尝试发现，只有当传递的参数使用了@RequestBody注解时，才会出现这个问题。而且在另一个系统中，用户已经创建成功了，只是返回值的问题。见https://github.com/spring-cloud/spring-cloud-openfeign/issues/228\n\n找到了一篇类似的文章：https://blog.csdn.net/Thinkingcao/article/details/109161139，提到使用Apache HttpClient替换Feign原生httpclient，但是没有成功。\n\n最后这个问题的原因也没有找到，而我采取的方式是忽略这个错误，因为用户已经创建成功了，只是返回值的问题。如果有人知道这个问题的原因，欢迎留言告诉我。\n\ntry {\n    annotationInterfaces.batchCreateUser(annoUserList);\n} catch (RetryableException e) {\n    if (!e.getMessage().startsWith(\"Incomplete output stream executing POST\")) {\n        e.printStackTrace();\n        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n        return ResponseVO.error(\"无法连接标注系统后台，无法在标注系统中创建用户\");\n    }\n}\n\n把这个错误单独处理，不影响用户的使用。\n"
  },
  {
    "title": "vue2判断生产与开发环境的一个小问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/03/27/vue2%E5%88%A4%E6%96%AD%E7%94%9F%E4%BA%A7%E4%B8%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98.html",
    "date": "2024-03-27 11:00:00 +0000",
    "content": "vue2 在config/index.js 中如果是开发环境，则 process.env.NODE_ENV === undefined，如果是生产环境，则 process.env.NODE_ENV === 'production'。所以如果想在 config/index.js 中判断是否是开发环境，不能写成 process.env.NODE_ENV === 'development'，而是 process.env.NODE_ENV !== 'production'。而在进入主程序入口文件 main.js 以及之后的文件中，process.env.NODE_ENV === 'development' 和 process.env.NODE_ENV === 'production' 都是可以判断的。\n"
  },
  {
    "title": "spring禁用security",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/03/21/spring%E7%A6%81%E7%94%A8security.html",
    "date": "2024-03-21 11:00:00 +0000",
    "content": "在spring boot项目中，如果引入了spring-boot-starter-security依赖，会默认启用security。有时候调试的时候不想启用security，可以在启动类上加上@SpringBootApplication(exclude = {SecurityAutoConfiguration.class, ManagementWebSecurityAutoConfiguration.class})注解禁用security。\n"
  },
  {
    "title": "Ubuntu饥荒开服",
    "url": "/%E5%85%B6%E4%BB%96%E5%AE%9E%E8%B7%B5/2024/03/16/Ubuntu%E9%A5%A5%E8%8D%92%E5%BC%80%E6%9C%8D.html",
    "date": "2024-03-16 11:30:00 +0000",
    "content": "记录一下自己使用Ubuntu 22.04开饥荒联机版服务器的过程。\n\n1. 下载steamcmd\nwget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz\ntar -xvzf steamcmd_linux.tar.gz\n\n\n2. 安装依赖\n如果直接运行./steamcmd.sh一般会报下面的错：\n./steamcmd.sh: line 37: /root/games/steamcmd/linux32/steamcmd: No such file or directory\n\n我使用的是Ubuntu 22.04, 安装依赖如下：\nsudo add-apt-repository multiverse\nsudo dpkg --add-architecture i386\nsudo apt update\nsudo apt install libstdc++6 libgcc1 libcurl4-gnutls-dev:i386 lib32z1\n\n\n3. 运行\n./steamcmd.sh\n\n如果运行成功，会自动开始下载更新，下载完成后会出现Steam>提示符。\n\n接着输入下面的命令：\nforce_install_dir ../dontstarvetogether\nlogin anonymous\napp_update 343050 validate\nquit\n\napp_update 343050 validate表示安装饥荒联机版，343050是饥荒联机版的appid。\n注意先用force_install_dir指定安装目录，然后login anonymous登录，不然会出现警告：\nSteam>force_install_dir ../dontstarvetogether\nPlease use force_install_dir before logon!\n\n如果后面需要更新饥荒服务端，重新执行这几个命令即可。\n\n4. 创建世界\n进入饥荒联机版创建一个世界，然后退出游戏，会在C:/Users/{用户名}/Documents/Klei/DoNotStarveTogether/{id}/目录下生成一个cluster_1文件夹，将这个文件夹拷贝到服务器上的~/.klei/DoNotStarveTogether/目录下。可以使用任意文件传输工具，我使用的是vscode的remote ssh插件，直接拖拽文件即可。也可以用scp命令：\nscp -r cluster_1 root@{服务器ip}:~/.klei/DoNotStarveTogether/\n\n\n5. 获取服务器令牌和klie账号id\n从饥荒联机版游戏首页左下角的账号进入到klei的账号界面，然后进入饥荒游戏服务器页面，或者直接访问https://accounts.klei.com/account/game/servers?game=DontStarveTogether\n\n\n创建服务器，然后复制服务器票据。\n\n\n6. 修改配置文件\n进入服务器的~/.klei/DoNotStarveTogether/cluster_1目录。\n\n\n  在该目录下创建一个cluster_token.txt文件，内容为上一步获取的服务器票据。\n  在该目录下创建一个adminlist.txt文件，内容为你的klei账号id。如果需要添加多个管理员，其他人的klei账号id也同样方式获取，然后一行一个id写入adminlist.txt文件。\n获取方式为：从饥荒联机版游戏首页左下角的账号进入到klei的账号界面，或者直接访问https://accounts.klei.com/account/info获取服务器令牌。\n\n  修改cluster.ini文件，修改cluster_name(服务器名称)、cluster_password(服务器密码)、max_players(最大玩家数)等参数。\n```ini\n[GAMEPLAY]\ngame_mode = survival\nmax_players = 6\npvp = false\npause_when_empty = true\n\n\n[NETWORK]\nlan_only_cluster = false\ncluster_password = my_password\ncluster_description = \ncluster_name = 饥荒服务器名称\noffline_cluster = false\ncluster_language = zh\ncluster_cloud_id = CCF1ED350800900F\n\n[MISC]\nconsole_enabled = true\n\n[SHARD]\nshard_enabled = true\nbind_ip = 127.0.0.1\nmaster_ip = 127.0.0.1\nmaster_port = 10888\ncluster_key = defaultPass\n\n## 7. 创建启动脚本\n可以直接获取官网的启动脚本：\n```shell\nwget https://accounts.klei.com/assets/gamesetup/linux/run_dedicated_servers.sh\n\n内容如下:\n#!/bin/bash\n\nsteamcmd_dir=\"$HOME/steamcmd\"\ninstall_dir=\"$HOME/dontstarvetogether_dedicated_server\"\ncluster_name=\"MyDediServer\"\ndontstarve_dir=\"$HOME/.klei/DoNotStarveTogether\"\n\nfunction fail()\n{\n\techo Error: \"$@\" >&2\n\texit 1\n}\n\nfunction check_for_file()\n{\n\tif [ ! -e \"$1\" ]; then\n\t\tfail \"Missing file: $1\"\n\tfi\n}\n\ncd \"$steamcmd_dir\" || fail \"Missing $steamcmd_dir directory!\"\n\ncheck_for_file \"steamcmd.sh\"\ncheck_for_file \"$dontstarve_dir/$cluster_name/cluster.ini\"\ncheck_for_file \"$dontstarve_dir/$cluster_name/cluster_token.txt\"\ncheck_for_file \"$dontstarve_dir/$cluster_name/Master/server.ini\"\ncheck_for_file \"$dontstarve_dir/$cluster_name/Caves/server.ini\"\n\n./steamcmd.sh +force_install_dir \"$install_dir\" +login anonymous +app_update 343050 validate +quit\n\ncheck_for_file \"$install_dir/bin64\"\n\ncd \"$install_dir/bin64\" || fail\n\nrun_shared=(./dontstarve_dedicated_server_nullrenderer_x64)\nrun_shared+=(-console)\nrun_shared+=(-cluster \"$cluster_name\")\nrun_shared+=(-monitor_parent_process $$)\n\n\"${run_shared[@]}\" -shard Caves  | sed 's/^/Caves:  /' &\n\"${run_shared[@]}\" -shard Master | sed 's/^/Master: /'\n\n\n修改前面四个变量值为自己设置的目录，比如我的是：\n# steamcmd安装目录\nsteamcmd_dir=\"$HOME/games/steamcmd\"\n# 饥荒服务器安装目录\ninstall_dir=\"$HOME/games/dontstarvetogether\"\n# 存档目录名称\ncluster_name=\"Cluster_1\"\n# 存档位置\ndontstarve_dir=\"$HOME/.klei/DoNotStarveTogether\"\n\n然后给脚本添加执行权限：\nchmod +x run_dedicated_servers.sh\n\n\n注意，官方给的脚本每次启动时都会检查更新，如果不想检查更新，可以把执行./steamcmd.sh的那一行注释掉，然后手动更新一次即可。注意更新的时候如果加了模组，那么模组设置文件dedicated_server_mods_setup.lua会被覆盖。所以我对这部分稍微修改了一下：\n# 检查更新\nif [ $# -ge 1 ] && [ \"$1\" -eq 1 ]; then\n    # 备份dedicated_server_mods_setup.lua文件\n    if [ -f \"$install_dir/mods/dedicated_server_mods_setup.lua\" ]; then\n        cp \"$install_dir/mods/dedicated_server_mods_setup.lua\" \"$install_dir/mods/dedicated_server_mods_setup.lua.bak\"\n    fi\n    \n    # 执行steamcmd.sh\n    ./steamcmd.sh +force_install_dir \"$install_dir\" +login anonymous +app_update 343050 validate +quit\n    \n    # 恢复备份的dedicated_server_mods_setup.lua文件\n    if [ -f \"$install_dir/mods/dedicated_server_mods_setup.lua.bak\" ]; then\n        mv \"$install_dir/mods/dedicated_server_mods_setup.lua.bak\" \"$install_dir/mods/dedicated_server_mods_setup.lua\"\n    fi\nfi\n\n可以在执行脚本时加上参数1，表示检查更新，不加参数表示不检查更新。更新时候会先备份dedicated_server_mods_setup.lua文件，然后更新完成后再恢复备份的文件。\n\n8. 添加模组\n找到自己存档的modoverrides.lua文件，比如我的是~/.klei/DoNotStarveTogether/cluster_1/目录下的Master和Caves目录下的modoverrides.lua文件，如果创建世界的时候添加了模组，里面会有模组的配置信息，比如我这里添加了两个模组：\nreturn {\n  [\"workshop-1998081438\"]={ configuration_options={ StackMode=true, StackRadius=10 }, enabled=true },\n  [\"workshop-378160973\"]={\n    configuration_options={\n      ENABLEPINGS=true,\n      FIREOPTIONS=2,\n      OVERRIDEMODE=false,\n      SHAREMINIMAPPROGRESS=true,\n      SHOWFIREICONS=true,\n      SHOWPLAYERICONS=true,\n      SHOWPLAYERSOPTIONS=2 \n    },\n    enabled=true \n  } \n}\n\n这里面的1998081438和378160973是模组的id，也可以在https://steamcommunity.com/app/322330/workshop/搜索模组，然后在url中找到模组的id。\n\n然后进入到饥荒服务器安装目录~/games/dontstarvetogether/mods目录，修改dedicated_server_mods_setup.lua文件，添加模组id：\nServerModSetup(\"1998081438\")\nServerModSetup(\"378160973\")\n\n\n注意, 如果加了模组，那么Master和Caves目录下的modoverrides.lua文件中的模组配置都要配置好，不然在切换世界的时候会直接卡死。\n\n9. 启动服务器\n./run_dedicated_servers.sh\n\n一般来说需要给服务器开放以下端口：\n\n  udp 10999 主世界, 在Master/server.ini文件中设置\n  udp 10998 洞穴, 在Caves/server.ini文件中设置\n  udp+tcp 10888 洞穴连接主世界, 在cluster.ini文件中设置\n\n\n经过我自己测试，只开放10999和10998两个端口似乎也可以正常运行。\n\n服务器的命令可以在(https://dontstarve.huijiwiki.com/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0)[https://dontstarve.huijiwiki.com/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0]找到。\n\n常用命令：\n\n  c_shutdown(是否保存) 关闭服务器, true表示保存存档。\n  c_save() 保存进度。\n  c_rollback(天数) 回滚存档。\n  c_reset() 相当于c_rollabck(0)，回滚到30秒前保存的存档。\n  c_regenerateshard() 重新生成本世界\n  c_regenerateworld() 重新生成服务器的所有世界\n  c_skip(天数) 跳过天数\n\n\n10. 连接服务器\n可以直接在服务器列表中搜索到自己的服务器，名称就是上面在cluster.ini文件中设置的cluster_name。\n如果想直接通过ip连接，可以用下面几种方式(端口号是主世界的端口号):\n\n  在游戏中按~键打开控制台，然后输入c_connect(\"xx.xx.xx.xx\", 10999, \"000\")，其中xx.xx.xx.xx是服务器ip，10999是主世界端口，000是服务器密码。\n  也可以在steam启动时添加启动参数+connect xx.xx.xx.xx:10999 +password “000”\n  找到电脑上饥荒的启动路径，比如我的是E:\\games\\Steam\\steamapps\\common\\Don't Starve Together\\bin64\\dontstarve_steam_x64.exe，然后把这个exe创建快捷方式，然后右键属性，在目标后面添加 +connect 47.120.61.78:10999 +password \"000\"，然后双击这个快捷方式就可以直接连接到服务器了。这种方法记得要先启动steam。\n\n\n"
  },
  {
    "title": "使用RestTemplate转发请求",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/03/15/%E4%BD%BF%E7%94%A8RestTemplate%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82.html",
    "date": "2024-03-15 13:00:00 +0000",
    "content": "我想自己实现一个简单的网关，用于转发请求。由于在项目中已经使用了spring-boot-start-web，此时如果再加入spring-cloud-gateway，会导致很多问题，所以我打算自己写一个简单的网关用于转发请求。\n\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\nimport org.springframework.web.util.UriComponentsBuilder;\nimport springfox.documentation.annotations.ApiIgnore;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.*;\n\n@RestController\n@ApiIgnore\npublic class RouterController {\n\n    @RequestMapping(value = \"/test/**\")\n    public void forwardNeo4jRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String forwardUrl = \"http://localhost:8088/\" + request.getRequestURI().substring(7);\n        forwardRequest(forwardUrl, request, response);\n    }\n\n    private void forwardRequest(String forwardUrl, HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // 获取请求方法\n        HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n        if (httpMethod == null) {\n            throw new IllegalArgumentException(\"Invalid HTTP method: \" + request.getMethod());\n        }\n        // 获取header\n        Enumeration<String> headerNames = request.getHeaderNames();\n        HttpHeaders headers = new HttpHeaders();\n        while (headerNames.hasMoreElements()) {\n            String headerName = headerNames.nextElement();\n            String headerValue = request.getHeader(headerName);\n            headers.add(headerName, headerValue);\n        }\n        // 获取请求体\n        BufferedReader reader = request.getReader();\n        StringBuilder requestBody = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            requestBody.append(line);\n        }\n        // 获取请求参数\n        Map<String, String[]> parameterMap = request.getParameterMap();\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n            String[] list = entry.getValue();\n            for (String s : list) {\n                params.add(entry.getKey(), s);\n            }\n        }\n        // 构建uri\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(forwardUrl);\n        if (params.size() > 0) {\n            builder.queryParams(params);\n        }\n        URI uri = builder.build().encode().toUri();\n        // 构建请求实体\n        RequestEntity<?> requestEntity;\n        requestEntity = new RequestEntity<>(requestBody.toString(), headers, httpMethod, uri);\n        // 发送请求\n        RestTemplate restTemplate = new RestTemplate();\n        ResponseEntity<String> responseEntity = restTemplate.exchange(requestEntity, String.class);\n        // 设置响应\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setStatus(responseEntity.getStatusCodeValue());\n        response.setContentType(Objects.requireNonNull(responseEntity.getHeaders().getContentType()).toString());\n        response.getWriter().write(Objects.requireNonNull(responseEntity.getBody()));\n    }\n}\n\n\n使用/test/**来匹配 test 开头的请求，然后将请求转发到http://localhost:8088/。转发的过程中，需要将请求方法、请求头、请求体、请求参数都转发过去。\n"
  },
  {
    "title": "swagger2配置Authorization",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/03/13/swagger2%E9%85%8D%E7%BD%AEAuthorization.html",
    "date": "2024-03-13 07:00:00 +0000",
    "content": "import springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.service.ApiKey;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spi.service.contexts.SecurityContext;\nimport springfox.documentation.spring.web.plugins.Docket;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SwaggerUtils {\n\n    public static Docket createDefaultRestApi(ApiInfo apiInfo) {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo)\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.example\"))\n                .paths(PathSelectors.any())\n                .build()\n                .securitySchemes(securitySchemes())\n                .securityContexts(securityContexts());\n    }\n\n    private static List<ApiKey> securitySchemes() {\n        List<ApiKey> apiKeyList = new ArrayList<>();\n        apiKeyList.add(new ApiKey(\"Authorization\", \"Authorization\", \"header\"));\n        return apiKeyList;\n    }\n\n    private static List<SecurityContext> securityContexts() {\n        List<SecurityContext> securityContexts = new ArrayList<>();\n        securityContexts.add(SecurityContext.builder().build());\n        return securityContexts;\n    }\n}\n\n\n"
  },
  {
    "title": "python将图片中某种颜色修改为其他颜色",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/02/18/python%E5%B0%86%E5%9B%BE%E7%89%87%E4%B8%AD%E6%9F%90%E7%A7%8D%E9%A2%9C%E8%89%B2%E4%BF%AE%E6%94%B9%E4%B8%BA%E5%85%B6%E4%BB%96%E9%A2%9C%E8%89%B2.html",
    "date": "2024-02-18 14:00:00 +0000",
    "content": "def replace_color_in_images1(directory, old_color, threshold, new_color):\n    '''\n    将目录中所有图片中的某种颜色替换为其他颜色\n    :param directory: 图片所在目录\n    :param old_color: 要替换的颜色\n    :param threshold: 颜色阈值\n    :param new_color: 替换后的颜色\n    '''\n    old_r, old_g, old_b = old_color\n    for filename in os.listdir(directory):\n        if filename.endswith(\".jpg\") or filename.endswith(\".png\"):\n            img_path = os.path.join(directory, filename)\n            img = Image.open(img_path)\n            data = img.load()\n\n            for y in range(img.size[1]):\n                for x in range(img.size[0]):\n                    r, g, b = data[x, y]\n                    if abs(r - old_r) < threshold and abs(g - old_g) < threshold and abs(b - old_b) < threshold:\n                        data[x, y] = new_color\n            img.save(img_path)\n\n# 使用示例\nreplace_color_in_images1(\"images\", (0, 0, 0), 10, (0, 0, 255))\n\n"
  },
  {
    "title": "mariadb备份报错Unknown table 'column_statistics'",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/26/mariadb%E5%A4%87%E4%BB%BD%E6%8A%A5%E9%94%99Unknown-table-'column_statistics'.html",
    "date": "2024-01-26 14:30:00 +0000",
    "content": "参考https://tecadmin.net/mysqldump-unknown-table-column_statistics-in-information_schema/\n\n在 mariadb 中使用mysqldump备份时报错：\nmysqldump: Unknown table 'column_statistics' in information_schema\n\n\n这是因为在 mariadb 10.2.2 版本中引入了column_statistics表，而mysqldump是 mysql 的备份工具，不支持 mariadb 的新特性，无法识别column_statistics表。\n\n解决方式是在备份时添加--column-statistics=0参数：\nmysqldump --column-statistics=0 --opt -u root -p database_name > backup.sql\n\n\n在 spring 中进行自动备份时，为解决上述问题，如果只在特定版本的 mariadb 中出现问题，则根据需要手动添加--column-statistics=0参数；如果不确定 mariadb 版本，或者要兼容多个版本，则可以在备份前先检查 mariadb 版本，然后根据版本添加--column-statistics=0参数。\n\n检查 mariadb 版本：\n@Select(\"select version()\")\nString getDatabaseVersion();\n\n获取到的版本号格式为10.6.11-MariaDB。\n\n自动备份代码：\n```java\n\n@Service\npublic class LogScheduledTask {\n\n@Autowired\nprivate LogService logService;\n\n@Value(\"${spring.datasource.url}\")\nprivate String databaseUrl;\n\n@Value(\"${spring.datasource.username}\")\nprivate String databaseUsername;\n\n@Value(\"${spring.datasource.password}\")\nprivate String databasePassword;\n\n@Scheduled(cron = \"0 0 1 * * ?\")\npublic void backup() {\n    String mariadbVersion = logService.getDatabaseVersion();\n    String cmd1 = \"cmd /c mysqldump \";\n    String cmd2 = \"cmd /c mysqldump --column-statistics=0 \";\n    String backupPath = \"backup/\" + new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()) + \".sql\";\n    String cmdParams = \"--opt -u \" + databaseUsername + \" --password=\" + databasePassword + \" -h\" + databaseHost + \" test > \" + backupPath;\n    try {\n        String cmd;\n        if (compareVersion(mariadbVersion.split(\"-\")[0], \"10.2.2\") >= 0) {\n            cmd = cmd2 + cmdParams;\n        } else {\n            cmd = cmd1 + cmdParams;\n        }\n        Process process = Runtime.getRuntime().exec(cmd);\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            logService.saveLog(\"备份成功\");\n        } else {\n            logService.saveLog(\"备份失败\");\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\nprivate int compareVersion(String version1, String version2) {\n    if (version1 == null || version2 == null) {\n        return 0;\n    }\n    String[] versionArray1 = version1.split(\"\\\\.\");//注意此处为正则匹配，不能用\".\"；\n    String[] versionArray2 = version2.split(\"\\\\.\");\n    int idx = 0;\n    int minLength = Math.min(versionArray1.length, versionArray2.length);//取最小长度值\n    int diff = 0;\n    while (idx < minLength && (diff = Integer.parseInt(versionArray1[idx]) - Integer.parseInt(versionArray2[idx])) == 0) {\n        ++idx;\n    }\n    //如果已经分出大小，则直接返回，如果未分出大小，则再比较位数，有子版本的为大；\n    diff = (diff != 0) ? diff : versionArray1.length - versionArray2.length;\n    return diff;\n} }\n\n"
  },
  {
    "title": "neo4j 3.5 reduce的使用",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2024/01/23/neo4j-3.5-reduce%E7%9A%84%E4%BD%BF%E7%94%A8.html",
    "date": "2024-01-23 15:00:00 +0000",
    "content": "在 neo4j 中，reduce函数可以用来对一个集合中的元素进行迭代处理，最终返回一个值。官方文档地址：https://neo4j.com/docs/cypher-manual/3.5/functions/list/\n\n语法\n\nreduce(acc = init, x IN list | expression)\n\n\n项目中的使用1\n我需要匹配某个人物关联的所有文章，并把所有文章的标题作为该人物的content，使用分号分隔。具体的 cypher 语句如下：\n\nMATCH (p:Person)\nOPTIONAL MATCH (p)-[:content]->(a:Article)\nWITH p, collect(DISTINCT a.title) as titles\nSET p.content = reduce(acc = \"\", x IN titles | acc + x + \";\")\n\n\n项目中的使用2\n有一个比较复杂的需求，在 neo4j 中存储了实体(Entity)、属性值(Value)等节点，通过 Entity 与 Value 之间的 HAS 关系表示实体拥有这个属性。现在要求根据实体的名称或者属性值的名称查询实体，允许同时查询实体名称以及多个属性值的名称，允许分页查询，并且允许对某个属性值进行排序。先给出最终的 cypher 语句：\n\n@Query(\"MATCH (t:BaseNode:Task {nodeId: {taskId}})-[:INCLUDE]->(d:Document)<-[:LOCATION]-(e:Entity)-[:TYPE]->(:BaseNode:Label {nodeId: {labelId}}) WHERE e.name CONTAINS {entityName}\\n\" +\n        \"AND (SIZE({attributeList}) = 0 OR ALL(attr IN {attributeList} WHERE ANY(a1 IN [(e)-[:HAS]->(v:Value {attributeId: attr.attributeId}) | v.value] WHERE toString(a1) CONTAINS attr.searchContent)))\\n\" +\n        \"WITH e\\n\" +\n        \"OPTIONAL MATCH (e)-[r:HAS]->(v:Value)\\n\" +\n        \"WITH e, COLLECT({key: r.name, value: v.value}) AS values\\n\" +\n        \"WITH e, apoc.coll.sortMaps(values, 'key') AS sortedValues\\n\" +\n        \"WITH e, REDUCE(acc = [], v IN sortedValues | acc + CASE\\n\" +\n        \"    WHEN v.key = acc[SIZE(acc) - 1][0] THEN [[v.key, acc[SIZE(acc) - 1][1] + ' ' + v.value]]\\n\" +\n        \"    ELSE [[v.key, v.value]] END) AS values\\n\" +\n        \"WITH e, apoc.map.fromPairs(values) AS mergedProperties\\n\" +\n        \"WITH apoc.map.merge(e, mergedProperties) AS entity\\n\" +\n        \"WITH entity,\\n\" +\n        \"CASE WHEN {orderMethod} = 'asc' THEN apoc.map.get(entity, {orderBy}, '') ELSE '' END AS ascParam,\\n\" +\n        \"CASE WHEN {orderMethod} = 'desc' THEN apoc.map.get(entity, {orderBy}, '') ELSE '' END AS descParam\\n\" +\n        \"RETURN entity, ascParam, descParam\\n\" +\n        \"ORDER BY ascParam ASC, descParam DESC\\n\" +\n        \"SKIP {start} LIMIT {length}\")\nList<Map<String, Object>> searchEntityByAttribute(Long taskId, Long labelId, String entityName, Integer start, Integer length, String orderBy, String orderMethod, List<AttributeSearchVO> attributeList);\n\n\n下面是对代码的部分说明以及难点分析：\n\n\n  \n    其他说明：labelId, taskId等参数是该项目的具体需求，用于确定查询的范围以及实体的类别等，这里不过多解释。\n  \n  \n    因为需要对若干属性值进行查询，所以传入了一个List<AttributeSearchVO> attributeList来表示需要查询的属性，其中AttributeSearchVO是一个自定义的类，存储了属性id、名称等信息。根据属性进行查询优两种情况，如果不想对属性查询，则传入空列表，在 cypher 中使用SIZE({attributeList}) = 0来判断；如果需要对属性进行查询，则使用ALL(attr IN {attributeList} WHERE ANY(a1 IN [(e)-[:HAS]->(v:Value {attributeId: attr.attributeId}) | v.value] WHERE toString(a1) CONTAINS attr.searchContent))来判断，这是一个比较复杂的查询条件，先用了[(e)-[:HAS]->(v:Value {attributeId: attr.attributeId}) | v.value]来获取实体拥有的所有属性值，然后用ANY来判断是否有属性值的值包含了搜索内容，并使用ALL来判断是否所有属性值都满足条件。\n  \n  \n    虽然在数据库中实体与属性值是分别在不同节点存储并使用 HAS 关系连接的，但是在查询返回给前端时需要将实体与属性值合并为一个对象。\n先将属性值合并成一个 map 类型。但是并没有什么方法能够一步到位。参考了 apoc 的官网后，打算使用 apoc.map.fromPairs 来将属性值合并成一个 map 类型。但是在使用时发现，apoc.map.fromPairs只能将一个二维数组转换为 map 类型，那么这就需要先将属性值转换为二维数组。由于数据的特殊性，一个实体即使是属性名相同的属性，也可能会有多个。比如一个实体可能会有两个”释义”属性，那么这两个属性值就需要合并。\n正因为可能有多个同名属性的原因，所以需要先对属性的 key 进行排序，让相邻的 key 放在一起，这样就方便在后面的REDUCE函数中判断是否需要合并属性值。这里就分成了几步：先使用COLLECT将属性值收集到一个数组中，然后使用apoc.coll.sortMaps对属性值进行排序，最后使用REDUCE函数对排序后的属性值进行合并。在REDUCE函数中，通过acc[SIZE(acc) - 1]来获取上一个元素，0和1分别表示 key 和 value，如果当前 key 与上一个 key 相同，则将当前 value 通过空格拼接到上一个 value 后面，否则直接添加到数组中。\n最后使用apoc.map.fromPairs将合并后的属性值转换为 map 类型。这一步完成后，再使用apoc.map.merge将实体与属性值合并。\n  \n  \n    最后根据排序方式对实体进行排序。但是在 spring-data-neo4j 中，并不能直接以参数的方式传入排序方式，所以这里采用了一个比较巧妙的方式，预先把升序和降序排序语句都放在了 cypher 语句中，ORDER BY ascParam ASC, descParam DESC，然后只需要使用CASE WHEN来设置升序和降序的参数即可，如果不需要排序，则返回空字符串。\n  \n\n"
  },
  {
    "title": "spring设置neo4j时间类型属性问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/23/spring%E8%AE%BE%E7%BD%AEneo4j%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E9%97%AE%E9%A2%98.html",
    "date": "2024-01-23 14:00:00 +0000",
    "content": "在使用 spring-data-neo4j 时，如果要设置一个时间类型的属性，可以使用java.util.Date，不过有时候存储到 neo4j 后会自动变为时间戳，有时候可能并不想要这样的效果。\n\n可以在需要存储的类中，使用@com.fasterxml.jackson.annotation.JsonFormat注解来指定时间的格式，如下：\n\nimport com.fasterxml.jackson.annotation.JsonFormat;\n\nimport java.util.Date;\n\npublic class EntityNode {\n    private Long nodeId;\n    private String name;\n    @JsonFormat(pattern = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", timezone = \"GMT+8\")\n    private Date createTime;\n    // getter and setter\n}\n\n注意这里的pattern必须是 ISO 8601 格式，不能用一般的”yyyy-MM-dd HH:mm:ss”格式，否则会作为普通字符串存储，再次获取时就会报错：\norg.apache.commons.beanutils.ConversionException: DateConverter does not support default String to 'Date' conversion.\n\n\n对于某些并不在特定类中的时间属性，可以将时间转化为 ISO 8601 格式的字符串，然后存储到 neo4j 中，下面是我写的一个工具类：\n\n\nimport org.apache.commons.beanutils.ConvertUtils;\nimport org.apache.commons.beanutils.converters.DateConverter;\nimport org.apache.commons.beanutils.converters.DateTimeConverter;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class TimeUtils {\n\n    /**\n     * 将时间转换为字符串\n     * @param date 时间\n     */\n    public static String getTimeFormattedString(Date date) {\n        // 保存到neo4j时，要减去8小时\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.add(Calendar.HOUR, -8);\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n        return sdf.format(calendar.getTime());\n    }\n\n    public static void initTimeFormat() {\n        DateTimeConverter dtConverter = new DateConverter();\n        dtConverter.setPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n        ConvertUtils.register(dtConverter, Date.class);\n    }\n\n}\n\n\n\n上述类需要在首次使用时调用initTimeFormat方法，可以把它放在程序入口处调用。然后就可以使用getTimeFormattedString方法来将时间转化为字符串，然后存储到 neo4j 中。\n"
  },
  {
    "title": "spring使用neo4j的属性拷贝出现空值问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/16/spring%E4%BD%BF%E7%94%A8neo4j%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8B%B7%E8%B4%9D%E5%87%BA%E7%8E%B0%E7%A9%BA%E5%80%BC%E9%97%AE%E9%A2%98.html",
    "date": "2024-01-16 12:00:00 +0000",
    "content": "我有一个需求是把某个 map 类型的所有 key-value 都赋值给某一个节点，但是要忽略 map 中的某几个字段。neo4j 官方文档有对 map 类型的数据相关操作进行说明：\n\nhttps://neo4j.com/docs/cypher-manual/current/values-and-types/maps/\n\n参考上面的文档，我打算使用map{.*, key1: null, key2: null}的方式来实现，具体的 cypher 语句如下：\n\nMERGE (n:Attribute {nodeId: $attr.nodeId})\nON CREATE SET n += $attr{.*, children: null}\n\n\n一般情况这种方法可以实现。但在使用时发现该节点的其他字段也被设置为了 null，因为该 map 的某些字段确实是 null。这样就会导致 neo4j 返回的节点对象中，该节点的其他字段也被设置为了 null。\n\n一个解决方法是定义一个类来存储 map 中的字段，然后使用com.fasterxml.jackson.annotation.JsonInclude注解来忽略 null 值。\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class Attribute {\n    private Long nodeId;\n    private String name;\n    private String value;\n    private String children;\n    // getter and setter\n}\n\n"
  },
  {
    "title": "neo4j空节点创建关系失败问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/16/neo4j%E7%A9%BA%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA%E5%85%B3%E7%B3%BB%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98.html",
    "date": "2024-01-16 11:00:00 +0000",
    "content": "在 neo4j 中，如果在创建关系之前使用了OPTIONAL MATCH，那么如果OPTIONAL MATCH没有匹配到节点，就会出现给不存在的节点创建关系的情况。如果不做任何处理，neo4j 会报错：\n\n\"Failed to create relationship `  UNNAMED403`, node `n1` is missing. If you prefer to simply ignore rows where a relationship node is missing, set 'cypher.lenient_create_relationship = true' in neo4j.conf\"\n\n\n解决方法在该报错信息中已经给出了，即在neo4j.conf中设置cypher.lenient_create_relationship = true。\n"
  },
  {
    "title": "swagger2的apimodel错乱问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/14/swagger2%E7%9A%84apimodel%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98.html",
    "date": "2024-01-14 09:00:00 +0000",
    "content": "我在使用 swagger2 时，遇到了一个问题：A 类中有一个内部类 B，C 类中有一个内部类 D，而 B 和 D 的类名是相同的，两个内部类都使用了@io.swagger.annotations.ApiModel注解，但是在 swagger-ui 中，B 或 D 其中一个类会被显示为另一个类的属性，即使修改了ApiModel的value和description属性也无效。\n\n目前除了避免类名重复，暂时没有找到其他解决方式。\n"
  },
  {
    "title": "git强制拉取某个分支覆盖本地代码",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/14/git%E5%BC%BA%E5%88%B6%E6%8B%89%E5%8F%96%E6%9F%90%E4%B8%AA%E5%88%86%E6%94%AF%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81.html",
    "date": "2024-01-14 07:30:00 +0000",
    "content": "\n  将远程仓库的代码拉取到本地\n    git fetch --all\n# 或者\ngit fetch origin\n    \n  \n  强制拉取远程仓库的某个分支覆盖本地代码\n    git reset --hard origin/branch_name\n    \n  \n\n"
  },
  {
    "title": "spring接收neo4j数据格式转换问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/13/spring%E6%8E%A5%E6%94%B6neo4j%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98.html",
    "date": "2024-01-13 10:30:00 +0000",
    "content": "我在使用 spring-data-neo4j 时，写了下面的查询语句：\n\n@Query(\"UNWIND {labelIdList} AS labelId\\n\" +\n        \"MATCH (n:BaseNode:Label {nodeId: labelId})-[:INCLUDE](a:Attribute)\\n\" +\n        \"WITH n.nodeId AS labelId, COLLECT(a) AtempAttributeList\\n\" +\n        \"UNWIND tempAttributeList AS attribute\\n\" +\n        \"MATCH (attribute)-[:INCLUDE]->(sub:Attribute)\\n\" +\n        \"WITH labelId, attribute, COLLECT(sub) AS subList\\n\" +\n        \"WITH labelId, COLLECT({root: attribute, children: subList} AS attributeList\\n\" +\n        \"RETURN labelId, attributeList\")\nList<Map<String, Object>> getLabelAttributeList(List<Long> labelIdList);\n\n\n以该查询语句为例，spring 在接收 neo4j 返回的数据时，一般返回的数据格式有以下几个规律：\n\n1. 节点类型\n如果 neo4j 中某个类型的节点已经在 spring 中用@org.neo4j.ogm.annotation.NodeEntity标注了，那么 spring 会自动将 neo4j 返回的节点数据转换为 spring 中的节点对象。而没有用@NodeEntity标注的节点，spring 会将其转换为org.neo4j.driver.internal.InternalNode对象。\n如果要把没使用@NodeEntity注解的InternalNode转换为 spring 中的节点对象，有好几种方式，这里以org.apache.commons.beanutils.BeanUtils为例（注意不是org.springframework.beans.BeanUtils）：\n\n<!-- 引入 commons-beanutils 依赖 -->\n<dependency>\n    <groupId>commons-beanutils</groupId>\n    <artifactId>commons-beanutils</artifactId>\n    <version>1.9.3</version>\n</dependency>\n\n\nInternalNode internalNode = (InternalNode) yourObject;\nMap<String, Object> nodeProperties = new HashMap<>(internalNode.asMap());\nYourClass yourClassInstance = new YourClass();\nBeanUtils.populate(yourClassInstance, nodeProperties);\nyourClassInstance.setGraphId(internalNode.id());\n\n\n2. Map 类型\n\n  而对于其他的类型，比如上面的RETURN labelId, attributeList和COLLECT({root: attribute, children: subList}，返回的类型会被自动转化为UnmodifiableMap，所以可以用Map<String, Object>来接收。注意这里的UnmodifiableMap是java.util.Collections$UnmodifiableMap，它是一个私有类，所以不能直接使用。而idea 自动补全的UnmodifiableMap一般都是其他包下的类，不能用来接收 neo4j 返回的数据。\n\n\n3. 列表类型\n如果返回的数据是一个列表，如果是最终用RETURN得到的列表，那么用java.util.List来接收没有任何问题。但如果是用COLLECT得到的列表，那么再用List来接收就会报错:\n\"message\": \"[Ljava.util.Collections$UnmodifiableMap; cannot be cast to java.util.List\"\n\n这是因为COLLECT得到的列表是一个数组，所以要用T[]来接收比如Object[]。\n\n所以上面代码中，如果想获取attributeList，用List<Map<String, Object>>来接收就会报上面第三点的错误。正确的做法是用Map<String, Object>[]或者Object[]来接收：\nList<Map<String, Object>> list = getLabelAttributeList(labelIdList);\nfor (Map<String, Object> map : list) {\n    Map<String, Object>[] attributeList = (Map<String, Object>[]) map.get(\"attributeList\");\n}\n\n"
  },
  {
    "title": "mysql删除重复数据",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/11/mysql%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE.html",
    "date": "2024-01-11 09:00:00 +0000",
    "content": "我有一张 resource 表，现在要删除其中 user_id 和 book_id 同时重复的数据，只保留一条。\n\nDELETE FROM `resource`\nWHERE `id` NOT IN (\n    SELECT MIN(`id`)\n    FROM `resource`\n    GROUP BY `user_id`, `book_id`\n);\n\n"
  },
  {
    "title": "锚点跳转被fixed定位方式header遮挡问题.md",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/07/%E9%94%9A%E7%82%B9%E8%B7%B3%E8%BD%AC%E8%A2%ABfixed%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8Fheader%E9%81%AE%E6%8C%A1%E9%97%AE%E9%A2%98.html",
    "date": "2024-01-07 10:00:00 +0000",
    "content": "当页面的 header 使用 fixed 定位时，锚点跳转会被 header 遮挡。解决方法是修改页面的 scroll-padding-top 属性值为 header 的高度。\n\nhtml {\n  scroll-padding-top: 100px;\n}\n\n"
  },
  {
    "title": "input下划线被隐藏问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2024/01/07/input%E4%B8%8B%E5%88%92%E7%BA%BF%E8%A2%AB%E9%9A%90%E8%97%8F%E9%97%AE%E9%A2%98.html",
    "date": "2024-01-07 09:00:00 +0000",
    "content": "问题如下图所示，input 中输入下划线时，下划线被隐藏了。即使有时候能显出来，但在缩放时也会消失。\n\n\n\n解决方法是把这个 input 的 height 设置为 100%。\n"
  },
  {
    "title": "表单中的button点击后自动刷新页面问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/12/19/%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84button%E7%82%B9%E5%87%BB%E5%90%8E%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E9%97%AE%E9%A2%98.html",
    "date": "2023-12-19 07:00:00 +0000",
    "content": "本文参考: https://blog.csdn.net/weixin_42318705/article/details/120471154\n\n在表单中，如果 button 的 type 属性为 submit 或者不设置，点击 button 后会自动刷新页面。这是因为 button 的默认 type 属性为 submit，点击后会触发表单的提交事件，这个事件会刷新页面。\n\n有几种解决方式:\n\n  将 button 的 type 属性设置为 button，这样点击 button 后不会触发表单的提交事件，也就不会刷新页面。\n  将 button 移出 form 标签。\n  使用其他标签如 span, div 代替 button。\n\n\n"
  },
  {
    "title": "spring实现elasticsearch的search after",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023/12/04/spring%E5%AE%9E%E7%8E%B0elasticsearch%E7%9A%84search-after.html",
    "date": "2023-12-04 08:00:00 +0000",
    "content": "简单实现\n\nimport org.elasticsearch.action.search.SearchRequest;\nimport org.elasticsearch.action.search.SearchResponse;\nimport org.elasticsearch.client.RequestOptions;\nimport org.elasticsearch.client.RestHighLevelClient;\nimport org.elasticsearch.search.SearchHit;\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Test {\n\n    /**\n     * search after分页检索\n     *\n     * @param client              client\n     * @param searchSourceBuilder searchSourceBuilder\n     * @param pageNum             页码\n     * @param pageSize            每页大小\n     */\n    public static List<SearchHit> searchAfter(RestHighLevelClient client, SearchSourceBuilder searchSourceBuilder, int pageNum, int pageSize) {\n        searchSourceBuilder.size(pageSize);\n        searchSourceBuilder.trackTotalHits(false);\n        SearchRequest searchRequest = new SearchRequest(\"book\");\n        searchRequest.source(searchSourceBuilder);\n        SearchHit[] searchHits = null;\n        // 跳过前面的数据\n        int totalCountOfSkip = (pageNum - 1) * pageSize;\n        // 根据内存和性能的需求调整batchSize, 最大不超过10000\n        int batchSize = 10000;\n        while (totalCountOfSkip > 0) {\n            searchSourceBuilder.size(Math.min(totalCountOfSkip, batchSize));\n            totalCountOfSkip -= batchSize;\n            try {\n                SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);\n                searchHits = searchResponse.getHits().getHits();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n            if (searchHits.length == 0) {\n                break;\n            }\n            SearchHit lastHit = searchHits[searchHits.length - 1];\n            searchSourceBuilder.searchAfter(lastHit.getSortValues());\n        }\n        searchSourceBuilder.size(pageSize);\n        try {\n            SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);\n            searchHits = searchResponse.getHits().getHits();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return searchHits == null ? null : Arrays.asList(searchHits);\n    }\n\n}\n\n\n\n在项目中的实际使用\n\n我有一个需求是要查找某个 nested 字段的总匹配条目数，数据量较大会超过 10000 条，所以用 search after 来分页查询（这里用 scroll 可能更好一些）。数据的格式是这样的：\n\n{\n  \"text\": [\n    {\n      \"text\": \"测试文本\",\n      \"keyword\": [\"test1\", \"test2\"]\n    },\n    {\n      \"text\": \"测试文本2\",\n      \"keyword\": [\"test3\", \"test4\"]\n    }\n  ]\n}\n\n需要查找所有text.text包含搜索关键字的条数和text.keyword包含搜索关键字的条数，这里用到了 script 来分别统计，并使用 search after来统计总数。\n\n这里还有另外两个小的需求：\n\n  由于数据中的中文有简体和繁体，所以需要同时匹配简体和繁体，这里用到了com.github.houbb.opencc4j.util.ZhConverterUtil来转换简体和繁体。\n  允许使用空格、加号、减号来分隔关键字，来表示与或非的关系，需要对搜索关键字中的这几个符号的格式做检查，并动态拼接 painless script。\n\n\npackage com.mb.retrieval.utils;\n\nimport com.github.houbb.opencc4j.util.ZhConverterUtil;\nimport org.elasticsearch.action.search.SearchRequest;\nimport org.elasticsearch.action.search.SearchResponse;\nimport org.elasticsearch.client.RequestOptions;\nimport org.elasticsearch.client.RestHighLevelClient;\nimport org.elasticsearch.index.query.BoolQueryBuilder;\nimport org.elasticsearch.script.Script;\nimport org.elasticsearch.script.ScriptType;\nimport org.elasticsearch.search.SearchHit;\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\nimport org.elasticsearch.search.sort.SortOrder;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Test {\n\n    /**\n     * 获取匹配条数总数\n     * @param directorySearchContent 目录标引搜索内容\n     * @param textSearchContent 全文文本搜索内容\n     * @param boolQueryBuilder boolQueryBuilder\n     * @param client client\n     */\n    public static int getTotalCountOfMatchRecords(String directorySearchContent, String textSearchContent, BoolQueryBuilder boolQueryBuilder, RestHighLevelClient client) {\n        String directoryPainlessScript = getPainlessScriptOfMatchCountSearch(directorySearchContent);\n        String textPainlessScript = getPainlessScriptOfMatchCountSearch(textSearchContent);\n        if (directoryPainlessScript == null && textPainlessScript == null) {\n            return 0;\n        }\n        SearchRequest searchRequest = new SearchRequest(\"book\");\n        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n        searchSourceBuilder.query(boolQueryBuilder).fetchSource(false).sort(\"id\", SortOrder.ASC);\n        if (textPainlessScript != null) {\n            Script script1 = new Script(ScriptType.INLINE, \"painless\",\n                    \"params['_source']['text'].stream().filter(t -> {String w = t.get(\\\"text\\\");return \" + textPainlessScript + \";}).count()\",\n                    new HashMap<>());\n            searchSourceBuilder.scriptField(\"text_text\", script1);\n        }\n        if (directoryPainlessScript != null) {\n            Script script2 = new Script(ScriptType.INLINE, \"painless\",\n                    \"params['_source']['text'].stream().filter(t -> t.get(\\\"keyword\\\").stream().anyMatch(w -> \" + directoryPainlessScript + \")).count()\",\n                    new HashMap<>());\n            searchSourceBuilder.scriptField(\"text_keyword\", script2);\n        }\n        int batchSize = 10000;\n        searchSourceBuilder.size(batchSize);\n        searchRequest.source(searchSourceBuilder);\n        try {\n            int total = 0;\n            while (true) {\n                SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);\n                SearchHit[] searchHits = searchResponse.getHits().getHits();\n                for (SearchHit hit : searchHits) {\n                    total += textPainlessScript != null ? (int) hit.getFields().get(\"text_text\").getValue() : 0;\n                    total += directoryPainlessScript != null ? (int) hit.getFields().get(\"text_keyword\").getValue() : 0;\n                }\n                if (searchHits.length < batchSize) {\n                    break;\n                }\n                searchRequest.source().searchAfter(searchHits[searchHits.length - 1].getSortValues());\n            }\n            return total;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n\n    private static String getPainlessScriptOfMatchCountSearch(String searchContent) {\n        searchContent = removeEmptyChar(searchContent);\n        if (searchContent.length() == 0) { return null; }\n        StringBuilder painlessScript = new StringBuilder();\n        StringBuilder word = new StringBuilder();\n        Map<Character, String> delimiterMap = new HashMap<Character, String>() {{\n            put(' ', \"||\"); put('+', \"&&\"); put('-', \"&& !\");\n        }};\n        for (char c : searchContent.toCharArray()) {\n            if (delimiterMap.containsKey(c)) {\n                if (word.length() > 0) {\n                    painlessScript.append(getSimpleAndTraditionalPainlessScriptOfWord(word.toString()));\n                }\n                painlessScript.append(delimiterMap.get(c));\n                word = new StringBuilder();\n            } else {\n                word.append(c);\n            }\n        }\n        if (word.length() > 0) {\n            painlessScript.append(getSimpleAndTraditionalPainlessScriptOfWord(word.toString()));\n        }\n        if (painlessScript.toString().startsWith(\"&& \")) {\n            painlessScript.delete(0, 3);\n        }\n        return painlessScript.toString();\n    }\n\n    private static String getSimpleAndTraditionalPainlessScriptOfWord(String word) {\n        if (word == null || word.length() == 0) {\n            return \"\";\n        }\n        String simplifiedWord = ZhConverterUtil.convertToSimple(word);\n        String traditionalWord = ZhConverterUtil.convertToTraditional(word);\n        if (simplifiedWord.equals(traditionalWord)) {\n            return \"w.contains(\\\"\" + simplifiedWord + \"\\\")\";\n        } else {\n            return \"(w.contains(\\\"\" + simplifiedWord + \"\\\") || w.contains(\\\"\" + traditionalWord + \"\\\"))\";\n        }\n    }\n\n    private static String removeEmptyChar(String str) {\n        if (str == null) {\n            return \"\";\n        }\n        // 多个空格、加号、减号只保留一个\n        str = str.trim().replaceAll(\"\\\\s+\", \" \")\n                .replaceAll(\"\\\\++\", \"+\").replaceAll(\"-+\", \"-\")\n                // 去除加号和减号前后的空格\n                .replaceAll(\"\\\\s*\\\\+\\\\s*\", \"+\").replaceAll(\"\\\\s*-\\\\s*\", \"-\")\n                // 加号和减号相邻时，如果末尾是减号则只保留一个减号，否则只保留一个加号\n                .replaceAll(\"([+-])+-\", \"-\").replaceAll(\"([+-])+\", \"+\")\n                // 去除开头的加号和空格，去除结尾的加号和减号和空格\n                .replaceAll(\"^\\\\s*\\\\+\\\\s*\", \"\").replaceAll(\"\\\\s*[+-]*\\\\s*$\", \"\");\n        return str;\n    }\n\n}\n\n\n"
  },
  {
    "title": "elasticsearch使用script查询和排序",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023/12/04/elasticsearch%E4%BD%BF%E7%94%A8script%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%8E%92%E5%BA%8F.html",
    "date": "2023-12-04 04:00:00 +0000",
    "content": "使用script作为排序条件\n\n比如某个用户查询书籍，然后想把这个用户购买的书籍排在前面，那么就没法直接对某个字段进行排序。我想到的方案是先查询出用户购买的所有书籍id，然后使用脚本排序，把用户购买的书籍id放在前面。\n\nGET /book/_search\n{\n  \"track_total_hits\": true,\n  \"query\": {\n    \"match\": {\n      \"bookName\": \"本草\"\n    }\n  },\n\n  \"sort\": {\n    \"_script\": {\n      \"type\": \"number\",\n      \"script\": {\n        \"lang\": \"painless\",\n        // \"source\": \"if (params['id_set'].contains(params['_source']['id'])) { return 0 } else { return 1 }\",\n        // \"source\": \"if (['12345'].contains(doc['id'].value)) { return 0 } else { return 1 }\",\n        \"source\": \"if (doc['id'].size() > 0 && params.id_set.contains(doc['id'].value)) return 0; else return 1;\",\n        \"params\": {\n          \"id_set\": [\"12345\", \"12346\"]\n        }\n      },\n      \"order\": \"asc\"\n    }\n  },\n  \"size\": 100\n}\n\n\n\nspringboot中的代码如下：\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\nimport org.elasticsearch.script.Script;\nimport org.elasticsearch.script.ScriptType;\nimport java.util.*;\n\nSearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n\nString scriptContent = \"if (doc['id'].size() > 0 && params.bookIdList.contains(doc['id'].value)) return 0; else return 1;\";\n\nScript script = new Script(ScriptType.INLINE, \"painless\", scriptContent, Collections.singletonMap(\"bookIdList\", bookIdList));\n\nsearchSourceBuilder.sort(SortBuilders.scriptSort(script, ScriptSortBuilder.ScriptSortType.NUMBER).order(SortOrder.ASC));\n\n\n使用script作为查询条件\n\n如果要用 script 来作为查询条件，可以按照上面类似的方法，只是把 script 放在 query 下面。\n\nGET /book/_search\n{\n  \"track_total_hits\": true,\n  \"query\": {\n    \"script\": {\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"params['id_set'].contains(doc['id'].value)\",\n        \"params\": {\n          \"id_set\": [\"12345\", \"12346\"]\n        }\n      }\n    }\n  },\n  \"size\": 100\n}\n\n\n对应的springboot代码如下：\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\nimport org.elasticsearch.script.Script;\nimport org.elasticsearch.script.ScriptType;\nimport java.util.*;\n\nSearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n\nString scriptContent = \"params['id_set'].contains(doc['id'].value)\";\n\nScript script = new Script(ScriptType.INLINE, \"painless\", scriptContent, Collections.singletonMap(\"id_set\", bookIdList));\n\nsearchSourceBuilder.query(QueryBuilders.scriptQuery(script));\n\n\n使用script作为查询返回的字段\n\n有时候需要返回的字段并不是索引中的字段，而是根据索引中的字段计算出来的，这时候可以使用 script_fields 来实现。\n\nGET /book/_search\n{\n  \"track_total_hits\": true,\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"nested\": {\n            \"path\": \"text\",\n            \"query\": {\n              \"match\": {\n                \"text.text\": \"测试\"\n              }\n            }\n          }\n        }\n      ]\n    }\n  },\n  \"_source\": false,\n  \"script_fields\": {\n    \"text_text\": {\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"params['_source']['text'].stream().filter(t -> t.get(\\\"text\\\").contains(params.searchContent)).map(t->t.get(\\\"text\\\")).collect(Collectors.toList())\",\n        \"params\": {\n          \"searchContent\": \"测试\"\n        }\n      }\n    },\n    \"text_keyword\": {\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"params['_source']['text'].stream().filter(t -> t.get(\\\"keyword\\\").contains(params.searchContent)).map(t->t.get(\\\"keyword\\\")).collect(Collectors.toList())\",\n        \"params\": {\n          \"searchContent\": \"测试\"\n        }\n      }\n    },\n    \"directory\": {\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"params['_source']['directory'].stream().filter(t -> t.get(\\\"name\\\").contains(params.searchContent)).map(t->t.get(\\\"name\\\")).collect(Collectors.toList())\",\n        \"params\": {\n          \"searchContent\": \"\"\n        }\n      }\n    }\n  }\n}\n\n\nspringboot代码如下：\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\nimport org.elasticsearch.script.Script;\nimport org.elasticsearch.script.ScriptType;\nimport java.util.*;\n\nSearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\nScript script1 = new Script(ScriptType.INLINE, \"painless\",\n                   \"params['_source']['text'].stream().filter(t -> {String w = t.get(\\\"text\\\");return w != null && w.contains(params.searchContent);}).map(t->t.get(\\\"text\\\")).collect(Collectors.toList())\",\n                    Collections.singletonMap(\"searchContent\", \"测试\"));\nsearchSourceBuilder.scriptField(\"text_text\", script1);\n\n"
  },
  {
    "title": "elasticsearch创建索引以及几个插件的使用",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/12/03/elasticsearch%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E4%BB%A5%E5%8F%8A%E5%87%A0%E4%B8%AA%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8.html",
    "date": "2023-12-03 01:30:00 +0000",
    "content": "记录一下在使用elasticsearch时创建索引的配置，以及几个插件的使用。\n\n1. 简繁体转换插件\n用于简体和繁体之间的转换\nhttps://github.com/medcl/elasticsearch-analysis-stconvert/releases\n\n2. 拼音分词插件\n用于使用拼音进行搜索\nhttps://github.com/infinilabs/analysis-pinyin/releases\n\n3. ik分词插件\n用于中文分词\nhttps://github.com/infinilabs/analysis-ik/releases\n\n4. analysis-hao分词插件\n用于中文分词\nhttps://github.com/tenlee2012/elasticsearch-analysis-hao\n\n5. icu_collation_keyword\n用于中文排序\nhttps://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-icu.html\n\n6. 创建索引\n\n{\n  \"settings\": {\n    \"index\": {\n      \"analysis\": {\n        \"analyzer\": {\n          \"search_analyzer\": {\n            \"filter\": [\"lowercase\"],\n            \"char_filter\": [\"tsconvert\"],\n            \"type\": \"custom\",\n            \"tokenizer\": \"my_search_token\"\n          },\n          \"index_analyzer\": {\n            \"filter\": [\"lowercase\"],\n            \"char_filter\": [\"tsconvert\"],\n            \"type\": \"custom\",\n            \"tokenizer\": \"my_index_token\"\n          },\n          \"ik_analyzer\": {\n            \"char_filter\": [\"tsconvert\"],\n            \"type\": \"custom\",\n            \"tokenizer\": \"ik_max_word\"\n          }\n        },\n        \"char_filter\": {\n          \"tsconvert\": {\n            \"type\": \"stconvert\",\n            \"convert_type\": \"t2s\",\n            \"keep_both\": true\n          }\n        },\n        \"tokenizer\": {\n          \"my_index_token\": {\n            \"enableFailDingMsg\": \"true\",\n            \"type\": \"hao_index_mode\",\n            \"enableSingleWord\": \"true\",\n            \"enableFallBack\": \"true\",\n            \"autoWordLength\": 3\n          },\n          \"my_search_token\": {\n            \"enableFailDingMsg\": \"true\",\n            \"type\": \"hao_search_mode\",\n            \"enableSingleWord\": \"true\",\n            \"enableFallBack\": \"true\",\n            \"autoWordLength\": 3\n          }\n        }\n      },\n      \"number_of_replicas\": \"0\"\n    }\n  },\n  \"mappings\": {\n    \"dynamic\": \"strict\",\n    \"properties\": {\n      \"id\": {\n        \"type\": \"keyword\"\n      },\n      \"bookName\": {\n        \"type\": \"text\",\n        \"analyzer\": \"index_analyzer\",\n        \"search_analyzer\": \"search_analyzer\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          },\n          \"sort\": {\n            \"type\": \"icu_collation_keyword\",\n            \"index\": false,\n            \"language\": \"zh\",\n            \"country\": \"CN\"\n          }\n        }\n      },\n      \"isFree\": {\n        \"type\": \"long\"\n      },\n      \"createTime\": {\n        \"type\": \"keyword\"\n      },\n      \"subLibraryId\": {\n        \"type\": \"long\"\n      },\n      \"classification\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_analyzer\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          },\n          \"sort\": {\n            \"type\": \"icu_collation_keyword\",\n            \"index\": false,\n            \"language\": \"zh\",\n            \"country\": \"CN\"\n          }\n        }\n      },\n      \"author\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_analyzer\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          },\n          \"sort\": {\n            \"type\": \"icu_collation_keyword\",\n            \"index\": false,\n            \"language\": \"zh\",\n            \"country\": \"CN\"\n          }\n        }\n      },\n      \"description\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_analyzer\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          }\n        }\n      },\n      \"completionTime\": {\n        \"type\": \"integer\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          }\n        }\n      },\n      \"subLibrary\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_analyzer\",\n        \"fields\": {\n          \"keyword\": {\n            \"type\": \"keyword\",\n            \"ignore_above\": 256\n          }\n        }\n      },\n      \"directory\": {\n        \"type\": \"nested\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"integer\"\n          },\n          \"name\": {\n            \"type\": \"text\",\n            \"analyzer\": \"ik_analyzer\"\n          },\n          \"parentId\": {\n            \"type\": \"integer\"\n          },\n          \"pageId\": {\n            \"type\": \"integer\"\n          }\n        }\n      },\n      \"text\": {\n        \"type\": \"nested\",\n        \"properties\": {\n          \"page\": {\n            \"type\": \"integer\"\n          },\n          \"keyword\": {\n            \"type\": \"text\",\n            \"analyzer\": \"ik_analyzer\",\n            \"fields\": {\n              \"keyword\": {\n                \"type\": \"keyword\",\n                \"ignore_above\": 256\n              }\n            }\n          },\n          \"text\": {\n            \"analyzer\": \"ik_analyzer\",\n            \"type\": \"text\",\n            \"fields\": {\n              \"keyword\": {\n                \"type\": \"keyword\",\n                \"ignore_above\": 256\n              }\n            }\n          },\n          \"directoryId\": {\n            \"type\": \"integer\"\n          },\n          \"originPath\": {\n            \"type\": \"keyword\"\n          },\n          \"pdfPath\": {\n            \"type\": \"keyword\"\n          }\n        }\n      }\n    }\n  }\n}\n\n\n"
  },
  {
    "title": "elasticsearch设置密码",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/11/29/elasticsearch%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81.html",
    "date": "2023-11-29 06:30:00 +0000",
    "content": "1. 设置密码\n进入elasticsearch的安装目录，打开config目录下的elasticsearch.yml文件，添加如下配置：\nxpack.security.enabled: true\n\n\n进入bin目录，启动elasticsearch:\n./elasticsearch\n\n设置密码：\n./elasticsearch-setup-passwords interactive\n\n\n2. 修改密码\n修改密码：\ncurl -X POST -u elastic:old_password -H \"Content-Type: application/json\" http://localhost:9200/_security/user/elastic/_password -d \"{\\\"password\\\":\\\"new_password\\\"}\"\n\n如果忘记密码，可以通过以下方式重置密码：\n# 重置密码，系统会生成一个密码\n./elasticsearch-reset-password -u elastic\n# 交互式重置密码，自己输入新密码\n./elasticsearch-reset-password -u elastic -i\n\n\n3. 在spring boot中使用\n在application.yml中添加任意配置：\nelasticsearch:\n  host: localhost\n  port: 9200\n  username: elastic\n  password: elastic-password\n\n使用CredentialsProvider设置用户名和密码：\npackage com.mb.retrieval.utils;\n\nimport org.apache.http.HttpHost;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.client.CredentialsProvider;\nimport org.apache.http.impl.client.BasicCredentialsProvider;\nimport org.elasticsearch.client.RestClient;\nimport org.elasticsearch.client.RestHighLevelClient;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\n\n@Component\npublic class EsClientUtils {\n\n    @Value(\"${elasticsearch.host}\")\n    private String esHost;\n\n    @Value(\"${elasticsearch.port}\")\n    private int esPort;\n\n    @Value(\"${elasticsearch.username}\")\n    private String esUsername;\n\n    @Value(\"${elasticsearch.password}\")\n    private String esPassword;\n\n    private static EsClientUtils esClientUtils;\n\n    @PostConstruct\n    public void init() {\n        esClientUtils = this;\n    }\n\n    public static RestHighLevelClient getEsClient() {\n        RestHighLevelClient client = null;\n        try {\n            CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n            credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(esClientUtils.esUsername, esClientUtils.esPassword));\n            client = new RestHighLevelClient(RestClient.builder(\n                    new HttpHost(esClientUtils.esHost, esClientUtils.esPort, \"http\")\n            ).setHttpClientConfigCallback(\n                    httpClientBuilder -> httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider))\n            );\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return client;\n    }\n\n}\n\n\n"
  },
  {
    "title": "vue使用esri-loader切换底图并添加自定义图片",
    "url": "/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/2023/11/25/vue%E4%BD%BF%E7%94%A8esri-loader%E5%88%87%E6%8D%A2%E5%BA%95%E5%9B%BE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87.html",
    "date": "2023-11-25 14:00:00 +0000",
    "content": "1. 问题描述\n我想实现一个能够切换各种地图（如百度、谷歌地图）并在此基础上给上面叠一张某个朝代的地图，且这张朝代地图的经纬度与地图的经纬度相契合。项目是 vue 项目，使用 arcgis api 来实现上述功能。\n\n2. 地图切换\n2.1. 安装 esri-loader\n首先需要引入 arcgis api，然后使用esri-loader来加载地图。\n\nnpm install esri-loader\n\n\n2.2. 加载地图\n通过网上搜索各个地图的api，目前先找了天地图、谷歌、高德地图的api，封装了一个加载地图的方法。\n\nload-map.js\n// load-map.js\n\nfunction getMapOfTianditu (Basemap, WebTileLayer, TileInfo, SpatialReference) {\n  const spatialReference = SpatialReference.WGS84\n  const tileInfo = new TileInfo({\n    dpi: 90.71428571427429,\n    lods: [\n      { level: 0, levelValue: '1', scale: 295828763.79585470937713011037, resolution: 0.703125 },\n      { level: 1, levelValue: '2', scale: 147914381.89792735468856505518, resolution: 0.3515625 },\n      { level: 2, levelValue: '3', scale: 73957190.948963677344282527592, resolution: 0.17578125 },\n      { level: 3, levelValue: '4', scale: 36978595.474481838672141263796, resolution: 0.087890625 },\n      { level: 4, levelValue: '5', scale: 18489297.737240919336070631898, resolution: 0.0439453125 },\n      { level: 5, levelValue: '6', scale: 9244648.868620459668035315949, resolution: 0.02197265625 },\n      { level: 6, levelValue: '7', scale: 4622324.4343102298340176579745, resolution: 0.010986328125 },\n      { level: 7, levelValue: '8', scale: 2311162.2171551149170088289872, resolution: 0.0054931640625 },\n      { level: 8, levelValue: '9', scale: 1155581.1085775574585044144937, resolution: 0.00274658203125 },\n      { level: 9, levelValue: '10', scale: 577790.55428877872925220724681, resolution: 0.001373291015625 },\n      { level: 10, levelValue: '11', scale: 288895.2771443893646261036234, resolution: 0.0006866455078125 },\n      { level: 11, levelValue: '12', scale: 144447.63857219468231305181171, resolution: 0.00034332275390625 },\n      { level: 12, levelValue: '13', scale: 72223.819286097341156525905853, resolution: 0.000171661376953125 },\n      { level: 13, levelValue: '14', scale: 36111.909643048670578262952926, resolution: 0.0000858306884765625 },\n      { level: 14, levelValue: '15', scale: 18055.954821524335289131476463, resolution: 0.00004291534423828125 },\n      { level: 15, levelValue: '16', scale: 9027.977410762167644565738231, resolution: 0.000021457672119140625 },\n      { level: 16, levelValue: '17', scale: 4513.9887053810838222828691158, resolution: 0.0000107288360595703125 },\n      { level: 17, levelValue: '18', scale: 2256.9943526905419111414345579, resolution: 0.00000536441802978515625 },\n      { level: 18, levelValue: '19', scale: 1128.4971763452709555707172788, resolution: 0.000002682209014892578125 }\n    ],\n    size: [256, 256],\n    origin: {\n      x: -180,\n      y: 90\n    },\n    spatialReference\n  })\n\n  const webTileLayer = new WebTileLayer({\n    urlTemplate: 'http://{subDomain}.tianditu.gov.cn/vec_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=b854fdb3a3b2625bd6c8353e83f7cca3',\n    subDomains: ['t0', 't1', 't2', 't3', 't4', 't5', 't6', 't7'],\n    tileInfo,\n    spatialReference,\n    opacity: 1\n  })\n  const basemap = new Basemap({\n    baseLayers: [webTileLayer]\n  })\n  return basemap\n}\n\nfunction getMapByUrlTemplate (Basemap, WebTileLayer, urlTemplate, subDomains) {\n  const layerData = {\n    urlTemplate\n  }\n  if (subDomains) {\n    layerData.subDomains = subDomains\n  }\n  const webTileLayer = new WebTileLayer(layerData)\n  const basemap = new Basemap({\n    baseLayers: [webTileLayer]\n  })\n  return basemap\n}\n\nconst mapUrlSet = {\n  'google': { url: 'https://mt1.google.com/vt/lyrs=m&x={col}&y={row}&z={level}' },\n  // 'google': 'https://mt1.google.com/vt/lyrs=m&x={col}&y={row}&z={level}&s=Galil',\n  'amap1': { url: 'https://webst01.is.autonavi.com/appmaptile?style=6&x={col}&y={row}&z={level}' },\n  'amap2': { url: 'https://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={col}&y={row}&z={level}' }\n  // 'tencent': { url: 'https://rt2.map.gtimg.com/tile?z={level}&x={col}&y={row}&type=vector&styleid=3&version=110' }\n}\n\nexport function loadMap (mapName, Basemap, WebTileLayer, TileInfo, SpatialReference) {\n  if (mapUrlSet[mapName]) {\n    const temp = mapUrlSet[mapName]\n    return getMapByUrlTemplate(Basemap, WebTileLayer, temp.url, temp.subDomains)\n  } else {\n    return getMapOfTianditu(Basemap, WebTileLayer, TileInfo, SpatialReference)\n  }\n}\n\n\n然后在vue里调用这个方法，加载地图。\n\nMapTest.vue\n<template>\n  <div class=\"main-container\">\n    <!-- 地图选择 -->\n    <el-select class=\"my-select\" v-model=\"currentMapChoice\" value-key=\"key\" placeholder=\"请选择地图\" @change=\"handleMapChange\">\n      <el-option\n        v-for=\"item in mapChoices\"\n        :key=\"item.key\"\n        :label=\"item.name\"\n        :value=\"item\">\n      </el-option>\n    </el-select>\n    <div id=\"map-container\"></div>\n  </div>\n</template>\n\n<script>\nimport { loadModules } from 'esri-loader'\nimport { loadMap } from './load-map'\n\nexport default {\n  data () {\n    return {\n      mapView: null,\n      mapChoices: [\n        { name: '天地图', key: 'tianditu' },\n        { name: '谷歌地图', key: 'google' },\n        { name: '高德地图-卫星', key: 'amap1' },\n        { name: '高德地图-街道', key: 'amap2' }\n      ],\n      currentMapChoice: null\n    }\n  },\n  methods: {\n    \n    loadMap (mapName) {\n      loadModules(\n        [\n          'esri/views/MapView',\n          'esri/Basemap',\n          'esri/Map',\n          'esri/layers/WebTileLayer',\n          'esri/layers/support/TileInfo',\n          'esri/geometry/SpatialReference'\n        ],\n        { css: true }\n      ).then(\n        ([MapView,\n          Basemap,\n          Map,\n          WebTileLayer,\n          TileInfo,\n          SpatialReference]) => {\n          const basemap = loadMap(mapName, Basemap, WebTileLayer, TileInfo, SpatialReference)\n          const map = new Map({ basemap })\n          const view = new MapView({\n            map,\n            container: 'map-container',\n            center: [113, 36],\n            zoom: 3\n          })\n          this.mapView = view\n        }\n      )\n    },\n    handleMapChange (value) {\n      document.getElementById('map-container').innerHTML = ''\n      this.loadMap(value.key)\n    }\n  }\n}\n\n效果如下：\n\n\n3. 添加各朝代地图\n3.1. 获取各朝代地图\n从网上搜索谭其骧主编的《中国历史地图集》中找到了各朝代的地图。每张地图上基本都有一部分经纬度信息，可以通过这些信息来定位它在地图上的位置。将每个朝代的地图比对好经纬度后，得到下面的数据:\n\nmapData: [\n  { 'dynasty': '春秋', 'mapName': '01-20春秋时期全图.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '战国', 'mapName': '01-31战国时期全图.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '秦', 'mapName': '02-3秦时期全图.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '汉', 'mapName': '02-13西汉时期全图.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '三国', 'mapName': '03-3三国时期全图.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '东晋', 'mapName': '东晋十六国时期.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '南北朝', 'mapName': '04-17宋、魏时期全图.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '隋', 'mapName': '05-3隋时期全图.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '唐', 'mapName': '05-32唐时期全图（一）.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '五代', 'mapName': '05-82五代十国时期全图.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '北宋', 'mapName': '辽.北宋时期.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '南宋', 'mapName': '金.南宋时期.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '元', 'mapName': '元初期.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '明', 'mapName': '07-40明时期全图（一）.jpg', left: 60, top: 58, right: 140, bottom: 17 },\n  { 'dynasty': '清', 'mapName': '08-3清时期全图（一）.jpg', left: 60, top: 58, right: 140, bottom: 17 }\n]\n\nleft、top、right、bottom分别表示图片的左上角和右下角的经纬度。\n\n然后将地图部署到nginx上，通过nginx的http://localhost:8084/maps/访问。\n\nserver {\n    listen       8084;\n    server_name  localhost;\n\n    location /maps {\n      add_header 'Access-Control-Allow-Origin' '*';\n\t\t\troot\tfiles;\n\t\t\tautoindex\ton;\n\t\t}\n}\n\n\n当然也可以直接用require来引入图片，我测试时使用的是nginx。\n\n3.2. 添加朝代地图\n目前尝试了以下几种方法：\n\n3.2.1. 使用esri/Graphic来添加图片\n在比较早的版本可以用esri/layers/MapImageLayer, esri/layers/MapImage来添加图片，具体操作就是创建一个MapImageLayer图层并添加到地图中，然后调用它的addImage方法添加一个MapImage。我试过这种方式，发现一个很大的问题就是图片的分辨率很糟糕，放大图片后原本图片中的信息基本看不清楚。\n\n我现在使用的是esri-loader v3.7.0，这个版本的MapImage移到了esri/layers/support/MapImage，且它的MapImageLayer已经没有addImage方法了，所以我采用了另一种方式，就是使用esri/Graphic来添加图片。\n\ngetPictureSize (mapData) {\n  const scale = this.calculateScale(this.mapView)\n  const width = (mapData.right - mapData.left) * scale.x\n  const height = (mapData.top - mapData.bottom) * scale.y\n  return {\n    width: `${width}px`,\n    height: `${height}px`\n  }\n},\ngeneratePictureSymbol (mapData) {\n  const size = this.getPictureSize(mapData)\n  const pictureSymbol = {\n    type: \"picture-marker\",\n    url: `${this.mapRootUrl}${mapData.mapName}`,\n    ...size\n  }\n  const point = {\n    type: \"point\",\n    longitude: mapData.left + (mapData.right - mapData.left) / 2,\n    latitude: mapData.top + (mapData.bottom - mapData.top) / 2,\n  }\n  return new this.Graphic({\n    geometry: point,\n    symbol: pictureSymbol,\n  })\n},    \nhandleDynastyChange () {\n  this.mapView.graphics.removeAll()\n  if (this.currentMapData.dynasty === '无') {\n    return\n  }\n  this.mapView.graphics.add(this.generatePictureSymbol(this.currentMapData))\n},\nloadMap (mapName) {\n  loadModules(\n    [ ..., 'esri/Graphic' ],\n    { css: true }\n  ).then(\n    ([..., Graphic]) => {\n      this.Graphic = Graphic\n      this.mapView = view\n      view.watch('scale', () => {\n        this.handleDynastyChange()\n      })\n    }\n  )\n}\n\n清除图片用this.mapView.graphics.removeAll()，添加图片用this.mapView.graphics.add()，这样就可以在地图上添加图片了。记得监听地图的scale事件，因为地图缩放时，图片的大小也需要相应的改变。\n\n效果如下：\n\n\n这种方式的缺陷也很明显，一是缩放时动画不流畅，二是图片的分辨率不高，放大后看不清楚。\n\n3.2.2. 在地图上添加一个div来放置图片\n在map-container外面添加一个relative定位的div，然后在这个div里面添加一个absolute定位的div用于放置图片，图片设置一定的透明度。图片的大小和位置通过计算经纬度来确定。这里我采用的方式是随便在地图上取两个点，然后计算这两个点的经纬度与屏幕坐标的比例，然后根据这个比例来计算图片的位置。\ncalculateScale (mapView) {\n  const mapPoint1 = {\n    x: 103,\n    y: 33,\n    spatialReference: {\n      wkid: 4326\n    }\n  }\n  const mapPoint2 = {\n    x: 113,\n    y: 43,\n    spatialReference: {\n      wkid: 4326\n    }\n  }\n  const screenPoint1 = mapView.toScreen(mapPoint1)\n  const screenPoint2 = mapView.toScreen(mapPoint2)\n  const scaleX = Math.abs(screenPoint1.x - screenPoint2.x) / Math.abs(mapPoint1x - mapPoint2.x)\n  const scaleY = Math.abs(screenPoint1.y - screenPoint2.y) / Math.abs(mapPoint1y - mapPoint2.y)\n  return { x: scaleX, y: scaleY }\n}\n\n\n然后分别计算图片的左上角和右下角的经纬度，然后通过这两个经纬度来计算图片的位置。\n\nupdateImagePosition (mapView, leftTop, rightBottom) {\n  if (!mapView) { return }\n  let scale\n  try {\n    scale = this.calculateScale(mapView)\n  } catch (e) {\n    return\n  }\n  const imgWidth = Math.abs(leftTop.x - rightBottom.x) * scale.x\n  const imgHeight = Math.abs(leftTop.y - rightBottom.y) * scale.y\n  const newLeftTop = mapView.toScreen({x: leftTop.x, y: leftTop.y, spatialReference: { wkid: 4326 }}) // 左上角\n  const img = document.querySelector('.image-layer')\n  if (!img) { return }\n  img.style.width = imgWidth + 'px'\n  img.style.height = imgHeight + 'px'\n  img.style.left = newLeftTop.x + 'px'\n  img.style.top = newLeftTop.y + 'px'\n},\nupdateImage () {\n  const mapView = this.mapView\n  const leftTop = { x: this.currentMapData.left, y: this.currentMapData.top }\n  const rightBottom = { x: this.currentMapData.right, y: this.currentMapData.bottom }\n  this.updateImagePosition(mapView, leftTop, rightBottom)\n}\n\n\n还有一个需要处理的问题就是图片如果覆盖在地图之上，那么像移动地图和缩放地图这些操作就会被图片给遮挡住，而给图片添加pointer-events: none的样式似乎无法让鼠标事件穿透图片。所以打算采用事件传递的方式，当鼠标在图片上时，将事件传递给地图。\n\n<template>\n  <div class=\"outer-container\">\n    <div id=\"map-container\"></div>\n    <div class=\"image-layer\"\n      @wheel.stop=\"dispatchEventToMap($event, 'wheel')\"\n      @mousedown.stop=\"handleImageLayerMouseDown\"\n      @mouseup.stop=\"handleImageLayerMouseUp\"\n      @mousemove.stop=\"handleImageLayerMouseMove\"\n      @mouseleave.stop=\"handleImageLayerMouseUp\">\n    </div>\n  </div>\n</template>\n\n<script>\nimport { loadModules } from 'esri-loader'\n  \nexport default {\n  data() {\n    return {\n      mapView: null,\n      mouseDown: false,\n      mouseDownPoint: { x: 0, y: 0 },\n      mouseDownMapCenter: { x: 0, y: 0 },\n      // other data\n    }\n  },\n  methods: {\n    dispatchEventToMap (event, type) {\n      this.mouseDown = false\n      document.body.style.cursor = 'default'\n      const tempCanvas = document.querySelector('#map-container .esri-view-root .esri-view-surface canvas')\n      let tempEvent = new WheelEvent(type, event)\n      tempCanvas.dispatchEvent(tempEvent)\n    },\n    handleImageLayerMouseDown (event) {\n      this.mouseDown = true\n      this.mouseDownPoint = { x: event.clientX, y: event.clientY }\n      this.mouseDownMapCenter = this.mapView.center\n    },\n    handleImageLayerMouseUp (event) {\n      this.mouseDown = false\n      document.body.style.cursor = 'default'\n    },\n    handleImageLayerMouseMove (event) {\n      if (this.mouseDown) {\n        const deltaX = event.clientX - this.mouseDownPoint.x\n        const deltaY = event.clientY - this.mouseDownPoint.y\n        // 将鼠标形状设置为move\n        document.body.style.cursor = 'grab'\n        const originCenter = this.mapView.toScreen({\n          x: this.mouseDownMapCenter.longitude,\n          y: this.mouseDownMapCenter.latitude,\n          spatialReference: {\n            wkid: 4326\n          }\n        })\n        const newCenter = {\n          x: originCenter.x - deltaX,\n          y: originCenter.y - deltaY\n        }\n        const newCenterMapPoint = this.mapView.toMap(newCenter)\n        this.mapView.center = [newCenterMapPoint.longitude, newCenterMapPoint.latitude]\n      }\n    }\n    // other methods\n  },\n  loadMap (mapName) {\n    loadModules(\n      ...\n    ).then(\n      (...) => {\n        view.watch('scale', () => {\n          this.updateImage()\n        })\n\n        // 移动地图\n        view.watch('center', () => {\n          this.updateImage()\n        })\n\n        this.updateImage()\n      }\n    )\n  },\n}\n\n\n鼠标滚轮缩放事件可以直接传递给地图，但是鼠标移动事件需要计算移动的距离，然后通过计算得到新的地图中心点。所以我在mousemove事件中计算了鼠标移动的距离，然后通过这个距离来计算新的地图中心点，然后将地图的中心点设置为这个新的中心点，同时将鼠标形状设置为grab。相应的在触发地图的scale和center事件时，也需要更新图片的位置。\n\nesri-loader地图上自带了缩放的加号和减号图标，上述方式图片会覆盖在这两个图标之上，所以需要将这两个图标隐藏掉。\n\n#map-container >>> .esri-ui-top-left {\n  display: none;\n}\n\n\n效果如下：\n\n\n相比上面的方法，图片分辨率没有太大问题，移动和缩放也相当流畅。但在后续的一些操作中，比如我想给地图加一些点或者线，这些点或线会被图片遮挡住，处理起来也比较麻烦。\n\n3.2.3. 使用esri/BaseDynamicLayer\nBaseDynamicLayer是一个抽象类，可以通过继承这个类来实现自定义图层。官方文档：https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-BaseDynamicLayer.html。\n\nhandleDynastyChange () {\n  // 清除之前的图片\n  if (this.currentPictureLayer) {\n    this.mapView.map.remove(this.currentPictureLayer)\n  }\n  if (this.currentMapData.dynasty === '无') {\n    return\n  }\n  const pictureUrl = this.mapRootUrl + this.currentMapData.mapName\n  this.currentPictureLayer = new this.MyCustomDynamicLayer({\n    pictureUrl, mapData: this.currentMapData\n  })\n  this.mapView.map.add(this.currentPictureLayer)\n},\nloadMap (mapName) {\n  loadModules(\n    [\n      ...,\n      'esri/layers/BaseDynamicLayer',\n      'esri/request'\n    ],\n    { css: true }\n  ).then(\n    ([...,\n      BaseDynamicLayer,\n      esriRequest]) => {\n      const basemap = loadMap(mapName, Basemap, WebTileLayer, TileInfo, SpatialReference)\n      const map = new Map({ basemap })\n      const view = new MapView({\n        map, container: 'map-container', center: [113, 36], zoom: 3\n      })\n      this.mapView = view\n      \n      this.MyCustomDynamicLayer = BaseDynamicLayer.createSubclass({\n        // properties of the custom dynamic layer\n        properties: {\n          pictureUrl: null,\n          mapData: null\n        },\n        // override getImageUrl() to generate URL to the image\n        getImageUrl: function (extent, width, height) {\n          return this.pictureUrl\n        },\n        // Fetches images for given extent and size\n        fetchImage: function (extent, width, height){\n          let url = this.getImageUrl(extent, width, height);\n          // request for the image based on the generated url\n          return esriRequest(url, {\n            responseType: \"image\"\n          })\n          .then(function(response) {\n            let image = response.data;\n            // create a canvas with teal fill\n            let canvas = document.createElement(\"canvas\");\n            let context = canvas.getContext(\"2d\");\n            canvas.width = width;\n            canvas.height = height;\n            if (extent.xmin === -180) {\n              // 地图移动到了左边界，直接隐藏\n              return canvas\n            }\n            const tempMapData = this.mapData\n            const leftTop = view.toScreen({ x: tempMapData.left, y: tempMapData.top })\n            const rightBottom = view.toScreen({ x: tempMapData.right, y: tempMapData.bottom })\n            // Apply destination-atop operation to the image returned from the server\n            context.fillStyle = \"rgb(0,200,200)\";\n            context.globalCompositeOperation = \"destination-atop\";\n            context.drawImage(image, leftTop.x, leftTop.y, rightBottom.x - leftTop.x, rightBottom.y - leftTop.y);\n            return canvas;\n          }.bind(this));\n        }\n      })\n      view.when(() => {\n        this.handleDynastyChange()\n      })\n      const resetButton = document.getElementById('reset-button')\n      // 添加按钮点击事件\n      resetButton.addEventListener('click', function () {\n      // 重新设置地图中心位置\n        view.center = [112, 29]\n        view.zoom = 3\n      })\n    }\n  )\n}\n\n\n使用BaseDynamicLayer.createSubclass方法，添加了pictureUrl和mapData两个属性，然后重写了getImageUrl和fetchImage方法。getImageUrl方法返回图片的 url，fetchImage方法用来获取图片，然后将图片绘制到canvas上。在绘制图片时，需要将图片的经纬度转换为屏幕坐标，然后绘制图片。\n\n每次切换朝代地图时，需要先移除之前的图片，然后添加新的图片: this.mapView.map.add(...)和this.mapView.map.remove(...)。\n\n效果如下：\n\n\n这种方式图片的分辨率没有问题，但有两个明显的缺陷：\n\n  移动和缩放地图时，会有明显的延迟。因为fetchImage仅会在移动和缩放的动画结束后才会调用，而且该方法中的esriRequest方法也会有一定的延迟。\n  一旦地图移动到了右侧的边界，fetchImage所生成的canvas的横坐标就会变到地图右侧的边界，但是通过view.toScreen方法转换的坐标还是在地图内部，这样的话图片的位置就会出现严重偏差。而且没法通过canvas的css样式将canvas的坐标移回去。所以不得不在到达边界时(extent.xmin === -180)直接隐藏图片。\n\n\n\n\n4. 总结\n本次添加地图图片的工作最主要的问题在于将图片正确的显示在地图上。上面的三种方法各有优缺点。分辨率除了第一种方法，其他两种方法都没有问题。操作的流畅度上，第三种方法最差，第一种方法次之，第二种方法最好。只有第二种方法会影响后续的标记位置等操作。所以整体上来说，根据实际需求选择第二种或者第三种方法比较好，某些极端情况对分辨率无要求的话，第一种方法也可以。\n\n5. 源代码\n代码地址：https://github.com/lxmghct/my-vue-components\n\n在src/views/map-test目录下。其中Test1.vue, Test2.vue, Test3.vue分别对应上述的三种方法。\n"
  },
  {
    "title": "python写入neo4j时间格式问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/11/24/python%E5%86%99%E5%85%A5neo4j%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98.html",
    "date": "2023-11-24 08:00:00 +0000",
    "content": "在使用py2neo写入neo4j时，如果属性值是时间类型，需要将时间转换为ISO-8601格式，否则会报错。\n\nimport datetime\n\n# 转化为ISO-8601格式\ncurrent_time = datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%fZ')\n\n# 将%f只保留3位小数\ncurrent_time = current_time[:-4] + current_time[-1]\n\n"
  },
  {
    "title": "el-select绑定value-key问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/11/24/el-select%E7%BB%91%E5%AE%9Avalue-key%E9%97%AE%E9%A2%98.html",
    "date": "2023-11-24 07:00:00 +0000",
    "content": "参考https://blog.csdn.net/Jie_Li_Wen/article/details/122881529\n\n在使用el-select组件时，如果绑定的值是对象，需要使用value-key属性来指定对象的某个属性作为v-model的值。\n\n<template>\n  <div>\n    <el-select class=\"my-select\" v-model=\"currentMapData\" value-key=\"dynasty\" placeholder=\"请选择朝代\" @change=\"handleDynastyChange\">\n      <el-option\n        v-for=\"item in mapData\"\n        :key=\"item.dynasty\"\n        :label=\"item.dynasty\"\n        :value=\"item\">\n      </el-option>\n    </el-select>\n  </div>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      mapData: [\n        { dynasty: '唐朝', name: '唐朝' },\n        { dynasty: '宋朝', name: '宋朝' },\n        { dynasty: '元朝', name: '元朝' },\n        { dynasty: '明朝', name: '明朝' }\n      ],\n      currentMapData: null\n    }\n  },\n  methods: {\n    handleDynastyChange () {\n      console.log(this.currentMapData)\n    }\n  }\n}\n\n\n如果不指定value-key属性，el-select显示就会出现问题，无论选择哪个选项，都会显示最后一个选项的值。\n\n"
  },
  {
    "title": "neo4j导入含嵌套json字符串的csv失败问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/11/09/neo4j%E5%AF%BC%E5%85%A5%E5%90%AB%E5%B5%8C%E5%A5%97json%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84csv%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98.html",
    "date": "2023-11-09 03:00:00 +0000",
    "content": "1. 问题描述\n我在 neo4j 使用LOAD CSV导入数据时，报了下面的一个错:\nAt C:\\Users\\Administrator\\Desktop\\HonestCulture\\neo4j-community-3.5.35\\import\\article_node.csv @ position 279 -  there's a field starting with a quote and whereas it ends that quote there seems to be characters in that field after that ending quote. That isn't supported. This is what I read: '{\"note\": \"\", \"sentenseTranslation\": \"[{\"\"原\"\"[{\\\"\"原'\n\n可以从官网上找到这个报错的原因 https://neo4j.com/developer/kb/parsing-of-quotes-for-load-csv-and-or-import/，大概就是说 csv 文件中的字符串如果包含引号，需要用两个引号来转义。\n\ncsv 文件内容如下:\nnodeId,title,annotation\n1,标题1,\"{\"\"note\"\": \"\"\"\", \"\"sentenseTranslation\"\": [{\\\"\"原文\"\": \\\"\"测试数据\\\"\", \\\"\"译文\\\"\": \\\"\"测试数据\\\"\"}], \"\"knowledgePoint\"\": []}\"\n\n可以看到上面的annotation字段中包含了 json 字符串，而该 json 字符串中又因为嵌套了一个 json 字符串，内层 json 字符串中的引号被转义了两次，先转义成\\\"，再转义成\\\"\\\"，所以导致了这个问题。\n\n2. 解决方案\n该 csv 文件是通过 python 生成的，而在读取数据时，其中的 sentenceTranslation 字段使用了 json.dumps 方法，然后在生成 annotation 字段时，又再次使用了 json.dumps 方法，所以导致了这个问题。\n\n解决方法有两个，最简单的方式就是内层的 json 字符串不要使用 json.dumps 方法，保留原始的字典格式，仅在最外层使用 json.dumps 方法即可。\n\nsentenceTranslation = [{\"原文\": \"测试数据\", \"译文\": \"测试数据\"}]\nannotation = {\n    \"note\": \"\",\n    \"sentenseTranslation\": sentenceTranslation,\n    \"knowledgePoint\": []\n}\nprint(json.dumps(annotation))\n\n此时得到的 csv 文件内容如下:\nnodeId,title,annotation\n1,标题1,\"{\"\"note\"\": \"\"\"\", \"\"sentenseTranslation\"\": [{\"\"原文\"\": \"\"测试数据\"\", \"\"译文\"\": \"\"测试数据\"\"}], \"\"knowledgePoint\"\": []}\"\n\n\n如果数据过于复杂，不便于对内层的 json 字符串进行处理，可以在两次转义之后处理一下转义字符。\n\nsentenceTranslation = json.dumps([{\"原文\": \"测试数据\", \"译文\": \"测试数据\"}], ensure_ascii=False)\nannotation = json.dumps({\n    \"note\": \"\",\n    \"sentenseTranslation\": sentenceTranslation,\n    \"knowledgePoint\": []\n})\nannotation = annotation.replace('\\\\\"', '\"')\nprint(annotation)\n\n"
  },
  {
    "title": "修改input自动填充样式",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/11/05/%E4%BF%AE%E6%94%B9input%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E6%A0%B7%E5%BC%8F.html",
    "date": "2023-11-05 11:30:00 +0000",
    "content": "浏览器自动填充表单中的输入框时，会自动添加一些样式，比如背景色、边框等。如果想要修改这些样式，可以使用:-webkit-autofill伪类选择器。\n\ninput:-webkit-autofill {\n    -webkit-box-shadow: 0 0 0px 1000px white inset; /* 1000px是为了覆盖默认样式 */\n    -webkit-text-fill-color: #333; \n}\n\n"
  },
  {
    "title": "java忽略强制转换泛型类型的警告",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/11/05/java%E5%BF%BD%E7%95%A5%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2List%E7%AD%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AD%A6%E5%91%8A.html",
    "date": "2023-11-05 07:30:00 +0000",
    "content": "java 强制转换 List 等泛型类型时会有警告，可以通过@SuppressWarnings注解来忽略这个警告。\n\nimport java.util.List;\n// SuppressWarnings在java.lang包下\n\n@SuppressWarnings(\"unchecked\")\nList<String> list = (List<String>) obj;\n\n@SuppressWarnings(\"unchecked\")\npublic void test(Map<String, Object> map) {\n    List<String> list = (List<String>) map.get(\"list\");\n    System.out.println(list);\n}\n\n"
  },
  {
    "title": "jekyll使用highlight.js对代码块进行高亮",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/10/15/jekyll%E4%BD%BF%E7%94%A8highlight.js%E5%AF%B9%E4%BB%A3%E7%A0%81%E5%9D%97%E8%BF%9B%E8%A1%8C%E9%AB%98%E4%BA%AE.html",
    "date": "2023-10-15 13:20:00 +0000",
    "content": "我想给自己的博客添加代码块自动高亮的功能，使用功能强大的highlight.js是一个不错的选择。整体来说，我想完成以下几个功能：\n\n  代码块自动高亮，能够根据代码块中的语言类别进行高亮。\n  代码块中的行号显示。\n  添加一些额外功能，如复制代码、切换自动换行等。\n\n\nhighlight.js官网: https://highlightjs.org/\nhighlight.js中文文档: http://highlight.cndoc.wiki/doc/\n\n1. highlight.js简介\nhighlight.js 是一个用 JavaScript 编写的语法高亮库。它可以用来美化网页中的代码块，使其在浏览器中呈现出更具可读性的样式。highlight.js 支持超过 180 种编程语言和格式，包括常见的语言如 JavaScript、Python、Java，以及各种配置文件、标记语言等。\n\nhighlight.js 的主要特点包括：\n\n  轻量级：highlight.js 是一个轻量级的库，易于集成到网页中，并且不依赖于其他库或框架。\n  易用性：只需简单的几行代码，就可以在网页中集成代码高亮功能。\n  多语言支持：支持超过 180 种编程语言和格式的语法高亮。\n  自动检测：highlight.js 可以自动检测代码块中的语言类型，无需手动指定。\n  可定制性：用户可以根据需要自定义代码块的样式和主题。\n\n\n1.1 使用highlight.js\n去官网https://highlightjs.org/download下载 highlight.js，可以选择自己需要的语言，也可以直接使用默认的 highlight.js。下载后得到压缩包 highlight.zip，如果只使用默认样式，则只需要将highlight.min.js和default.min.css放到项目中即可。\n<link rel=\"stylesheet\" href=\"/path/to/styles/default.min.css\">\n<script src=\"/path/to/highlight.min.js\"></script>\n<script>hljs.highlightAll();</script>\n\n上面代码是最简单的使用方式，调用hljs.highlightAll()会自动对页面中所有<pre><code>标签自动识别语言并进行高亮。如果需要指定语言，可以在<code>标签中添加class属性，如<code class=\"language-javascript\">。\n\n2. 在jekyll中使用highlight.js的过程以及遇到的问题\n2.1 jekyll中的代码块\n首先要弄清楚 jekyll 是如何渲染代码块的。我使用了两段代码来做测试：\n首先用了一段 python 代码作为例子：\nprint(\"hello world\")\n\n检查渲染后的 html 代码，可以看到如下图所示的结构：\n\n然后用了同样的代码，但是随便改了个语言类别为 test1：\nprint(\"hello world\")\n\n检查渲染后的 html 代码，可以看到如下图所示的结构：\n\n\n\n\n可以看到，jekyll 渲染代码块的时候，对于可以识别的代码类型，会将代码块包裹在<div class=\"highlighter-rouge\">中，其中包含了language-python类名，然后在其中依次添加类名为highlight的<div>和<pre>标签，然后添加一个没有任何类的<code>标签。对于无法识别的代码类型，则直接生成一个<pre>标签，然后在其中添加一个类名为language-xxx的<code>标签。如果未指定语言，则视为第一种情况，语言类型为plaintext。\n\n为了方便后续统一处理，主要是后续添加行号以及方便后面样式上的统一修改，我采用的方法是把情况二转化成情况一的结构，也就是从<code>标签中提取语言类别，然后外层添加<div class=\"highlighter-rouge\">。\n// 找到没有任何类的<pre>元素\nlet preWithoutLanguages = [];\nlet allPres = document.querySelectorAll(\".post-content pre\");\nallPres.forEach((pre) => {\n  if (pre.classList.length === 0) {\n    preWithoutLanguages.push(pre);\n  }\n});\n// 为这些<pre>元素外层添加一个.highlighter-rouge的div\npreWithoutLanguages.forEach((pre) => {\n  // 先看看它的<code>元素是否有language-开头的class\n  let language = Array.from(\n    pre.getElementsByTagName(\"code\")[0].classList\n  ).find((c) => c.startsWith(\"language-\"));\n  if (!language) {\n    language = \"language-plaintext\";\n  }\n  let div = document.createElement(\"div\");\n  div.classList.add(\"highlighter-rouge\");\n  div.classList.add(language);\n  // 内层还有一层div\n  let innerDiv = document.createElement(\"div\");\n  innerDiv.classList.add(\"highlight\");\n  div.appendChild(innerDiv);\n  pre.parentNode.insertBefore(div, pre);\n  innerDiv.appendChild(pre);\n});\n\n\n2.2 使用highlight.js\n直接使用hljs.highlightAll()会对所有的<pre><code>标签进行高亮，使用如下 python 代码进行测试：\ndef test():\n    print(\"hello world\")\n\n高亮后的 html 结构如下图所示：\n\n可以看到，其中的code标签中添加了类名hljs和language-scss，并添加了 data-highlighted=\"yes\"属性。但是python被识别成了scss，这是由于一开始 jekyll 渲染代码块的时候没有将language-xxx类添加到<code>标签中，导致 highlight.js 无法识别指定的语言，所以进行了自动识别。因此在做这一步之前，需要先将<code>标签中的类名改为language-xxx，而这个语言类型就从highlighter-rouge元素中的language-xxx类名中获取。\nlet preContainers = document.querySelectorAll(\n  \".post-content div.highlighter-rouge\"\n);\nlet codeDataList = [];\nlet codeList = [];\npreContainers.forEach((preContainer) => {\n  // 从自身的class列表中提取语言类别, language-开头的class\n  let language = Array.from(preContainer.classList).find((c) =>\n    c.startsWith(\"language-\")\n  );\n  if (!language) {\n    language = \"plaintext\";\n  }\n  let code = preContainer.getElementsByTagName(\"code\")[0];\n  code.classList.add(`language-${language.replace(\"language-\", \"\")}`);\n});\n// 代码高亮\nhljs.highlightAll();\n\n这样做之后，highlight.js 就能够正确识别代码块中的语言类型了。\n\n2.3 使用 Web Worker 加载 highlight.js\n根据官方文档所说，当代码块很大时，为了避免页面卡顿，可以使用 Web Worker 加载 highlight.js。创建一个 worker.js 文件，然后将高亮的代码放在其中，注意这里需要我们将要高亮的代码文本传给 worker，然后 worker 返回高亮后的代码文本。不能直接使用 hljs.highlightAll()，否则会报错Uncaught ReferenceError: document is not defined。因为在 worker 中不能直接操作 DOM。\n\n我这里是把所有的代码块放在一个数组中，然后传给 worker，worker 返回高亮后的代码数组，然后在主线程中将高亮后的代码替换原来的代码块。\n// worker.js\nonmessage = (event) => {\n  importScripts(\"/assets/js/highlight/highlight.min.js\");\n  const result = [];\n  event.data.forEach((codeData) => {\n    let language = codeData.language;\n    // 如果语言类型不在 highlight.js 支持的语言列表中，则使用 plaintext\n    if (self.hljs.getLanguage(language) === undefined) {\n      language = \"plaintext\";\n    }\n    result.push(\n      self.hljs.highlight(codeData.code, { language: language }).value\n    );\n  });\n  postMessage(result);\n};\n\n然后在主线程中使用 worker：\n// 用上一步中的代码获取到的 preContainers\npreContainers.forEach((preContainer) => {\n  // ...\n  let code = preContainer.getElementsByTagName(\"code\")[0];\n  codeDataList.push({\n    language: language.replace(\"language-\", \"\"),\n    code: code.textContent,\n  });\n  codeList.push(code);\n});\nworker.onmessage = (event) => {\ncodeList.forEach((code, i) => {\n  code.innerHTML = event.data[i];\n});\n};\nworker.postMessage(codeDataList);\n\n这样做之后，页面加载的时候就不会因为代码块太多而卡顿了。\n\n3. 添加行号\nhighlight.js 高亮后的代码是没有行号的，为了添加行号，我使用了一个叫highlightjs-line-numbers.js的插件。github 地址：https://github.com/wcoder/highlightjs-line-numbers.js。\n3.1 使用 highlightjs-line-numbers.js\n下载或使用 CDN 引入highlightjs-line-numbers.js，然后在hljs.highlightAll()或其他高亮代码之后调用hljs.initLineNumbersOnLoad()即可。\n<script src=\"/path/to/highlightjs-line-numbers.js\"></script>\n<script>hljs.initLineNumbersOnLoad();</script>\n\n也可以使用参数配置，比如单行默认是不显示行号的，可以使用hljs.initLineNumbersOnLoad({ singleLine: true })来显示单行的行号。\n\n添加了行号的 html 结构如下图所示：\n\n可以看到，它实现添加行号的方式是使用table来给代码最前面加上一列来显示行号。\n\n注意，hljs.initLineNumbersOnLoad()并不是马上执行的，是一个异步操作，所以不能直接在它后面立刻执行其他依赖于行号的操作。\n\n3.2 样式优化\n直接使用 highlightjs-line-numbers.js 生成的行号样式不太好看，我主要想修改的有以下几点：\n\n  调整基本样式，比如把左对齐改为右对齐，给行号右边加一道竖线等。\n  支持后面的自动换行功能，多行文本的行号改为显示在这些文本的第一行而非中间。\n  固定在左侧，不随着代码块的滚动而滚动。(sticky 定位)\n    .hljs {\n background-color: transparent;\n}\n.hljs-ln {\n padding-bottom: 10px;\n}\n.hljs-ln-numbers {\n position: sticky;\n position: -webkit-sticky; /* 兼容 Safari */\n left: 0;\n background-color: #F7F4F3;\n vertical-align: top;\n}\n.hljs-ln-code {\n padding: 0 5px !important;\n}\n.hljs-ln-n {\n padding: 0 3px;\n margin-right: 3px;\n text-align: right;\n min-width: 2em;\n border-right: 1px solid #e3e0dc;\n}\n    \n    注意调整一下背景色，避免 stikcy 定位滚动时显得不自然。\n  \n\n\n4. 其他功能\n4.1 代码块头部添加快捷操作\n我想在代码块的头部添加一些方便的操作，比如显示语言类型、复制代码、切换自动换行等。为了避免影响美观，只有鼠标悬停在代码块上时才显示这些操作。\n// 放在之前 web worker 的 onmessage 事件中\ncodeList.forEach((code, i) => {\n  code.innerHTML = event.data[i];\n  // ... other code\n  // 显示语言类别\n  let codeHeader =\n    `<div class=\"code-header\">` +\n    `<span class=\"language\">${codeDataList[i].language}</span> | ` +\n    `<span class=\"change-wrap-btn\"><i class=\"fa fa-rotate-right\"></i>自动换行</span> | ` +\n    `<span class=\"copy-btn\"><i class=\"fa fa-copy\"></i>复制</span>` +\n    `</div>`;\n  // 通过 insertAdjacentHTML 在代码块前面插入代码块头部\n  code.parentNode.insertAdjacentHTML(\"afterbegin\", codeHeader);\n});\n// 默认隐藏顶部按钮，鼠标放在代码块上时显示\npreContainers.forEach((preContainer) => {\n  const codeHeader = preContainer.querySelector(\".code-header\");\n  codeHeader.classList.add(\"hidden\");\n  preContainer.onmouseover = () => {\n    codeHeader.classList.remove(\"hidden\");\n  }\n  preContainer.onmouseleave = () => {\n    codeHeader.classList.add(\"hidden\");\n  }\n});\n\n.hidden {\n  display: none;\n}\n\n.code-header {\n  position: absolute;\n  top: 0;\n  right: 20px;\n  z-index: 1;\n}\n\n4.2 复制代码功能\n首先获取需要复制的代码文本，由于添加了行号，不能直接使用innerText或textContent，一开始想的是在高亮之前获取过一次代码文本，可以直接用这个文本传入到复制函数中。但问题也很明显，临时存储文本的变量因为在复制函数中用到了，所以并不能及时释放，会占用一定的内存。所以还是直接获取高亮后的代码文本比较好。需要遍历每一行，把行号去掉，然后拼接成一个字符串。每一行的行号放在类名为hljs-ln-numbers的<td>标签中，每一行的代码放在类名为hljs-ln-code的<td>标签中。\ndocument.querySelectorAll(\".copy-btn\").forEach(copyBtn => {\n  copyBtn.onclick = () => {\n    let parent = copyBtn.parentNode.parentNode;\n    let codeTable = parent.querySelector(\".hljs-ln tbody\");\n    let codeRows = codeTable.querySelectorAll(\"tr\");\n    let text = \"\";\n    codeRows.forEach((row) => {\n      // 忽略行号, 直接找.hljs-ln-code元素\n      let code = row.querySelector(\".hljs-ln-code\");\n      text += code.textContent + \"\\n\";\n    });\n    copyText(text);\n  }\n});\n\n复制代码是通过创建一个textarea元素，然后把代码文本放进去，然后选中这个textarea元素，然后执行document.execCommand(\"copy\")来实现的。当然如果浏览器支持navigator.clipboard，则使用navigator.clipboard.writeText(text)来实现。\nfunction copyText(text) {\n  if (navigator.clipboard) {\n    // clipboard api 复制\n    navigator.clipboard.writeText(text);\n  } else {\n    var textarea = document.createElement(\"textarea\");\n    document.body.appendChild(textarea);\n    // 隐藏此输入框\n    textarea.style.position = \"fixed\";\n    textarea.style.clip = \"rect(0 0 0 0)\";\n    textarea.style.top = \"10px\";\n    // 赋值\n    textarea.value = text;\n    // 选中\n    textarea.select();\n    // 复制\n    document.execCommand(\"copy\", true);\n    // 移除输入框\n    document.body.removeChild(textarea);\n  }\n}\n\n4.3 切换自动换行\n由于代码块的宽度是固定的，所以当代码块中的代码过长时，会出现横向滚动条。虽然对于代码而言，大部分时候不自动换行显得更清晰，但有时候可能会有换行更方便的情况。因此我想添加一个切换自动换行的功能。\ndocument.querySelectorAll(\".change-wrap-btn\").forEach((changeWrapBtn, i) => {\n  changeWrapBtn.onclick = () => {\n    const pre = changeWrapBtn.parentNode.parentNode;\n    const code = pre.getElementsByTagName(\"code\")[0];\n    code.classList.toggle(\"wrap\");\n  }\n});\n\n.post-content pre code.wrap {\n    white-space: pre-wrap !important;\n}\n\n5. 效果展示\n最终的效果如下图所示：\n\n\n完整代码可以在我的 github 仓库中找到：https://github.com/lxmghct/lxmghct.github.io。核心代码在assets/js/highlight和assets/css/highlight目录下。\n\n"
  },
  {
    "title": "jekyll添加beaudar评论系统",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/10/15/jekyll%E6%B7%BB%E5%8A%A0beaudar%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html",
    "date": "2023-10-15 01:10:00 +0000",
    "content": "beaudar是一个基于github issue的评论系统，所有评论都保存在某个仓库的issue评论中，是utterances的中文版本。官网为https://beaudar.lipk.org/，其中有详细的使用说明。\n\n先建一个公开的仓库用于保存评论，然后去https://github.com/apps/beaudar给仓库安装beaudar应用。\n\n按照官网的说明，一步一步设置，最后官网会给出对应的代码，然后将代码添加到页面中即可。\n\nbeaudar会根据页面的url或者title等信息自动创建issue，也可以使用自定义的issue-term来指定issue的标题。如果只使用文章的标题有可能会出现重复的问题，使用url又显得太长格式上不美观，所以我使用了日期加标题的方式来作为issue的标题。\n\n<script src=\"https://beaudar.lipk.org/client.js\"\n  repo=\"lxmghct/blog-comments\"\n  branch=\"master\"\n  issue-term=\"【2023-10-15】 jekyll添加beaudar评论系统\"\n  theme=\"github-light\"\n  loading=\"false\"\n  crossorigin=\"anonymous\" async>\n</script>\n\n"
  },
  {
    "title": "个人主页响应式布局调整",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/10/14/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E8%B0%83%E6%95%B4.html",
    "date": "2023-10-14 03:00:00 +0000",
    "content": "响应式布局是一种网页设计方法，旨在使网页能够在不同的设备和屏幕尺寸下提供最佳的用户体验。这意味着网页的布局和元素会根据用户所使用的设备的屏幕尺寸和分辨率进行调整和重新排列，以确保内容在各种设备上都能够清晰可见、易于浏览和交互。\n\n我的github个人主页主要用了几个响应式布局的方式，一个是通过Bootstrap框架实现的，通过Bootstrap的栅格系统，可以很方便的实现响应式布局。比如用class=\"col-md-2 col-lg-2 hidden-xs hidden-sm\"来实现某一栏在不同屏幕尺寸下的显示宽度和隐藏等。\n\n另一个是通过媒体查询实现的，通过CSS3的媒体查询，可以根据不同的设备和屏幕尺寸设置不同的样式。比如通过@media screen and (max-width: 768px)来设置在屏幕宽度小于768px时的样式。如果是想要电脑端优先，就设置max-width，如果是移动端优先，就设置min-width。screen表示媒体类型是屏幕，如果不加这个，那么在其他媒体比如打印机上也会生效。\n\n还有就是通过一些css布局来实现，比如flex布局，grid布局等。视口单位vw和vh也是很好的实现响应式布局的方式，比如设置width: 90vw，表示元素的宽度为视口宽度的90%。\n\nrem和em也是很好的实现响应式布局的方式，rem是相对于根元素的字体大小，也就是html元素的字体大小，而em是相对于父元素的字体大小。其设计思想则是不直接给元素设置具体的尺寸，而是根据字体大小来设置元素的尺寸，好处是可以方便的控制整体上各元素的尺寸，可以结合媒体查询或者js来动态的改变根元素的字体大小，从而实现响应式布局。\n\n除了在技术层面上的实现，响应式布局还需要考虑到用户体验和设计的角度。比如在移动设备上，由于屏幕尺寸较小，需要考虑到内容的可读性和可操作性，以及导航和交互的方式等。所以我在做自己个人博客的时候，也会考虑到这些因素，比如header的导航菜单在电脑上是横向排列，在移动设备上则是点击菜单按钮后弹出的垂直菜单；比如文章页面在宽屏上是三栏布局，方便显示目录等信息，而在移动端则只显示一栏，方便阅读。\n"
  },
  {
    "title": "导航栏手机端自适应",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/10/14/%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94.html",
    "date": "2023-10-14 00:10:00 +0000",
    "content": "我的博客导航栏中包含的内容比较多，包含首页、分类、归档等，还有一个搜索框。在手机端显示时，如果直接把导航栏的内容全部显示出来，必然会换行，影响美观。所以需要对导航栏进行自适应，当屏幕宽度小于一定值时，导航栏的内容自动隐藏，通过点击菜单按钮显示。\n完整代码在https://github.com/lxmghct/lxmghct.github.io的_includes/header.html等文件中。\n\n1. 实现思路\n首先需要判断当前页面是否是手机端，这可以通过判断屏幕宽度来实现。然后通过点击菜单按钮显示导航栏的内容。这个可以通过现有的一些ui库来实现，也可以自己通过js来实现。\n\n2. 实现过程\n2.1 根据屏幕宽度选择性显示导航栏\n可以使用bootstrap的col-{size}-{number}类来实现。其中size表示屏幕大小，有xs、sm、md、lg、xl五种，对应的像素值如下：\n\n  xs：小于576px\n  sm：大于等于576px\n  md：大于等于768px\n  lg：大于等于992px\n  xl：大于等于1200px\ncol表示列，number表示占据的列数。例如col-md-6表示在中等屏幕上占据6列。隐藏可以用hidden-{size}类来实现。例如hidden-xs表示在小屏幕上隐藏。\n\n\n宽度够时显示导航栏：\n<div class=\"col-md-6 col-lg-6 hidden-sm hidden-xs center\">\n  <div class=\"site-nav\">\n    <ul class=\"nav nav-pills\">\n      <li class=\"select\"><a href=\"/pages/classify.html\">分类</a></li>\n      <li class=\"select\"><a href=\"/pages/archive.html\">归档</a></li>\n      <li class=\"select\"><a href=\"/pages/tags.html\">标签</a></li>\n      <li class=\"select\"><a href=\"/pages/about.html\">关于</a></li>\n    </ul>\n  </div>\n</div>\n\n宽度不够时显示菜单按钮：\n<!-- 宽度不够时显示 -->\n<div class=\"hidden-lg hidden-md col-sm-4 col-xs-4\">\n  <div class=\"header-hidden-buttons\">\n    <i class=\"fa fa-search fa-lg search-icon\"></i>\n    <i class=\"fa fa-bars fa-2x menu-icon\"></i>\n    <!-- 用于控制菜单的显示和隐藏 -->\n    <input type=\"checkbox\" id=\"nav-trigger\" class=\"nav-trigger\">\n  </div>\n</div>\n\n\n2.2 点击菜单按钮显示导航栏\n这里我打算自己写一个下拉菜单。点击时显示导航栏内容，再次点击按钮或者其他任意空白处隐藏导航栏内容。实现思路是创建一个透明的勾选框，显示菜单时用js使其聚焦，然后通过勾选框的失去焦点事件来隐藏导航栏内容。\n\n<input type=\"checkbox\" id=\"nav-trigger\" class=\"nav-trigger\">\n\n#nav-trigger {\n    position: absolute;\n    right: 0;\n    opacity: 0; /* 隐藏，但是要能够触发失焦和聚焦事件，所以不能用display:none */\n}\n.phone-nav-show {\n    display: block;\n}\n\n$(\"#nav-trigger\").blur(() => {\n  // 延时隐藏, 因为blur比click先触发\n  setTimeout(() => {\n    $(\".phone-nav\").removeClass(\"phone-nav-show\");\n  }, 100);\n});\n$(\".header-hidden-buttons .menu-icon\").click(() => {\n  if (!$(\".phone-nav\").hasClass(\"phone-nav-show\")) {\n    $(\"#nav-trigger\").focus();\n    $(\".phone-nav\").addClass(\"phone-nav-show\");\n  }\n});\n\n\n3. 效果\n宽屏时显示：\n\n\n窄屏时显示：\n\n"
  },
  {
    "title": "jekyll实现显示文章目录",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/10/13/jekyll%E5%AE%9E%E7%8E%B0%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95.html",
    "date": "2023-10-13 00:30:00 +0000",
    "content": "1. 实现思路\n首先先要判断当前页面是否是文章，然后获取文章的各级标题并生成目录，并添加点击跳转到相应标题的功能。完整代码在https://github.com/lxmghct/lxmghct.github.io/blob/master/_includes/table_of_contents.html\n\n2. 实现过程\n2.1 获取标题并生成目录\n先获取所有的标题h1-h6，然后遍历生成目录。生成目录时考虑到有些文章并不是从h1开始的，有可能h2或者h3才是第一级小标题，所以要先获取所有的标题，然后才能判断目录的层级。\n\n为了方便后面的点击跳转，需要给每个标题添加一个id，如果标题没有id，则根据标题内容生成一个id。这样直接把#id添加到链接的href属性上就可以实现点击跳转。\n\n// 获取文章内容的标题\nconst headings = document.querySelectorAll(\".post-content h1, post-content h2, .post-content h3, .post-content h4, .post-contenth5, .post-content h6\");\nif (headings.length === 0) {\n    document.querySelector(\".toc-container\").classList.add(\"hidden\");\n} else {\n    document.querySelector(\".toc-container\").classList.remove(\"hidden\");\n}\n// 目录容器\nconst tocList = document.getElementById(\"toc-list\");\nconst tempTocData = []\n// 遍历标题，生成目录\nheadings.forEach((heading) => {\n    const level = parseInt(heading.tagName.charAt(1), 10); // 获取标题级别\n    const listItem = document.createElement(\"li\");\n    const link = document.createElement(\"a\");\n    link.textContent = heading.textContent;\n    if (!heading.id) {\n        heading.id = heading.textContent.replace(/\\s+/g, \"-\").toLowerCase();\n    }\n    link.href = `#${heading.id}`;\n    listItem.appendChild(link);\n    tocList.appendChild(listItem);\n    tempTocData.push({\n        level: level,\n        dom: listItem\n    })\n});\n\n\n2.2 调整目录格式\n根据上一步获取的目录层级，设置左边距，使目录结构看起来更加清晰。\nconst minLevel = Math.min(...tempTocData.map(item => item.level))\ntempTocData.forEach(item => {\n    let diff = item.level - minLevel\n    item.dom.style.marginLeft = diff * 20 + \"px\"\n    if (diff === 0) {\n        item.dom.classList.add(\"root-toc\")\n    }\n})\n\n\n2.3 判断文章页并使用目录\n将该目录组件封装成了table_of_content.html组件，然后在文章页引入该组件。判断当前页面是否是文章的方式是判断page.id或page.date是否存在。\n\n{% if page.id or page.date %}\n    {% include table_of_content.html %}\n{% endif %}\n\n\n3. 样式调整\n3.1 平滑滚动\n点击目录跳转到相应标题时，添加平滑滚动效果。\nhtml, body {\n    scroll-behavior: smooth;\n}\n\n3.2 目录定位方式\n我想把目录固定放在页面最左侧，不随滚动条滚动，本来想设置position: fixed，但是由于我页面的整体布局是有一个header导航栏，而且导航栏已经设置成了会随滚动条滚动，并非一直固定在页面顶部。所以如果此时目录是fixed定位，会出现目录和导航栏重叠的情况，而且整体观感也不好。所以我选择了sticky定位，目的是当导航栏滚动出屏幕前，目录也会随着滚动，当导航栏滚动到屏幕外时，目录会固定在页面最上方。这样既不会和导航栏重叠，浏览起来也比较舒服。\n<div class=\"toc-container\">\n  <div class=\"toc-header\">\n    <h3>目录导航</h3>\n  </div>\n  <ul id=\"toc-list\"></ul>\n</div>\n\n.toc-container {\n    position: sticky;\n    position: -webkit-sticky; /* 兼容 Safari */\n    top: 30px;\n    padding-top: 10px;\n}\n\n#toc-list {\n    height: 70vh;\n    overflow-y: auto;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n}\n\n\n4. 效果展示\n\n"
  },
  {
    "title": "jekyll实现文章搜索功能",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/10/12/jekyll%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD.html",
    "date": "2023-10-12 17:30:00 +0000",
    "content": "在jekyll中可以使用simple-jeckyll-search插件实现文章搜索功能，可以实现大部分需求。我在使用simple-jeckyll-search过程中遇到了一些问题：\n\n  一个是想要将匹配的所有条目都显示出来，包括一篇文章中的多处匹配，并显示匹配位置的上下文；\n  另一个是simple-jeckyll-search似乎并没有过滤掉文章中的某些html标签，导致能够搜索到一些html标签，这并不是我想要的。\n上述两个问题能够解决，但是需要另外写的代码比较多，特别是第一个问题如果需要显示匹配位置的上下文基本需要再写一遍搜索。所以最后我打算自己写一个搜索组件。\n\n\n\n1. 整体思路\n搜索时从rss文件中获取所有文章的标题、内容等信息，然后根据搜索关键词匹配文章标题和内容，将匹配的文章显示出来。参考了https://knightyun.github.io/2019/03/04/articles-search这篇文章。\n\n2. 设计目标\n能够实现搜索文章标题和内容，显示匹配的条目，不仅是文章的标题，还要把每一条匹配的内容前后的一些内容显示出来，以便用户更好的了解匹配的内容，并能点击跳转到对应的文章（跳转到文章中匹配的位置这个功能暂时先不做）。做成类似于vscode的全局搜索功能。\n\n3. 实现过程\n3.1 获取rss文件\nrss文件是jekyll生成的一个xml文件，里面包含了所有文章的标题、内容等信息，可以通过http请求获取rss文件，然后解析rss文件。这里使用XMLHttpRequest来获取rss文件。\n\nfunction makeHttpRequest(method, url, data) {\n  return new Promise(function (resolve, reject) {\n    var xhr = new XMLHttpRequest() || new ActiveXObject(\"Microsoft.XMLHTTP\");\n    xhr.open(method, url, true);\n    xhr.onload = function () {\n      if (xhr.readyState == 4 && xhr.status == 200) {\n        resolve(xhr);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = function () {\n      reject(\"网络错误\");\n    };\n    if (data) {\n      xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n      xhr.send(JSON.stringify(data));\n    } else {\n      xhr.send();\n    }\n  });\n}\nmakeHttpRequest(\"GET\", \"/feed.xml\").then(function (xhr) {\n  console.log(xhr.responseText);\n}).catch(function (err) {\n  console.error(err);\n});\n\n\n3.2 解析rss文件\nrss的文件结构如下图所示：\n\n解析rss代码如下：\nfunction getXmlData() {\n  articleData = [];\n  return new Promise(function (resolve, reject) {\n    makeHttpRequest(\"get\", \"/feed.xml\")\n      .then(function (res) {\n        const xml = res.responseXML;\n        const items = xml.getElementsByTagName(\"entry\");\n        for (const item of items) {\n          const title = item.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue;\n          const link = item.getElementsByTagName(\"link\")[0].getAttribute(\"href\");\n          let content = item.getElementsByTagName(\"content\")[0].childNodes[0].nodeValue.replace(/<.*?>/g, \"\");\n          articleData.push({ title, link, content });\n        }\n        resolve(articleData);\n      }).catch(function (err) {\n        reject(err);\n      });\n  });\n}\n\n\n3.3 搜索匹配并显示\n搜索时每篇文章用正则匹配查找：\n    const regExp = new RegExp(searchContent, \"gi\");\n    for (const item of articleData) {\n      if (item.title.match(regExp) || (!onlySearchTitle && item.content.match(regExp))) {\n        searchResults.push(item);\n      }\n    }\n\n显示时，匹配的内容前后的一些内容也显示出来，给匹配文本添加上span标签用于高亮，最后将搜索到的这些匹配条目渲染到页面上。\nfunction getMatchedPositions(keyword, content) {\n  const previewList = [];\n  let regex = new RegExp(keyword, \"gi\");\n  let match;\n  while ((match = regex.exec(content)) !== null) {\n    let startIndex = Math.max(0, match.index - 30);\n    let endIndex = Math.min(content.length, match.index + keyword.length + 40);\n    let preStr = content.substring(startIndex, match.index);\n    let suffixStr = content.substring(match.index + keyword.length, endIndex);\n    let matchStr = content.substring(match.index, match.index + keyword.length);\n    let preview = preStr + \"<span class='highlight'>\" + matchStr + \"</span>\" + suffixStr;\n    previewList.push(preview);\n  }\n  return previewList;\n}\n\n渲染时只需把上面得到的previewList添加到搜索结果容器的innerHTML中即可。\n\n4. 效果展示\n\n\n以上就是自己写的搜索组件的核心逻辑，完整代码请前往https://github.com/lxmghct/lxmghct.github.io/blob/master/assets/js/search.js\n\n5. 实现优化\n5.1 搜索数据来源优化\n上面的搜索组件是从rss文件中获取数据，当前项目使用的是jekyll-feed插件生成rss文件，在config.yml中配置如下：\nplugins:\n  - jekyll-feed\n\nfeed:\n  posts_limit: 20\n\n\nposts_limit默认不设置会生成10篇文章，使用默认设置只能搜索前10篇文章，可以设置成一个较大的值，但是这样会导致rss文件较大，加载时间较长。简单测试了一下80篇长度中等的文章差不多是在1MB左右，这个大小对于一个rss文件来说还是可以接受的。即使再大一点，也不会太大，所以可以适当增大posts_limit的值。\n\n由于rss中含有较多html标签，实际在搜索时并不需要这些标签，所以可以进一步优化rss文件。这里我打算自己生成一个json文件，只包含文章的标题、内容、日期和链接，这样可以减小文件大小，提高搜索效率。生成json文件的代码如下：\n\nrequire 'json'\nrequire 'cgi'  # 用于处理 HTML 实体的转义和恢复\n\nJekyll::Hooks.register :site, :post_write do |site|\n\n  def strip_html(content)\n      content.gsub(/<\\/?[^>]*>/, \"\")\n  end\n\n  def restore_html_entities(content)\n    CGI.unescapeHTML(content)\n  end\n\n  start_time = Time.now\n\n  all_posts = site.posts.docs.sort_by { |post| -post.date.to_i }.map do |post|\n    {\n      title: post.data['title'],\n      url: post.url,\n      date: post.date,\n      content: restore_html_entities(strip_html(post.content))\n    }\n  end\n  \n  File.open('_site/assets/posts.json', 'w') do |file|\n    file.write(JSON.pretty_generate(all_posts))\n  end\n\nend\n\n使用正则表达式去除文章的html标签，并恢复原文本中的html实体，最后生成json文件。这样生成的json文件大概是原来rss文件的1/3大小，搜索效率也有所提高。\n\n5.2 减少搜索频率\n目前每次input输入框中的内容变化时都会触发搜索，这样会导致搜索频率过高，可以使用延时搜索的方式，0.5秒内无输入才触发搜索。\nvar inputTimeout = null;\nfunction startSearch() {\n  inputTimeout && clearTimeout(inputTimeout);\n  if (articleData.length === 0) {\n    getJsonData().then(() => {\n      getSearchResult();\n      renderSearchResult();\n    })\n  } else {\n    getSearchResult();\n    renderSearchResult();\n  }\n}\nsearchInput.addEventListener(\"input\", function () {\n  inputTimeout && clearTimeout(inputTimeout);\n  inputTimeout = setTimeout(() => {\n    startSearch();\n  }, 500);\n});\n\n\n"
  },
  {
    "title": "jekyll自定义分页组件",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/10/12/jekyll%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E9%A1%B5%E7%BB%84%E4%BB%B6.html",
    "date": "2023-10-12 13:30:00 +0000",
    "content": "不采用其他现有的分页插件，自定义分页组件，实现纯前端分页功能。\n1. 整体思路\n假定所有待分页的元素都位于同一个父元素下，获取所有待分页的元素，根据每页数量pageSize和当前页currentPage，计算出当前需要显示的元素的起始索引start和结束索引end，然后根据start和end显示元素，将其他元素隐藏。\n\n2. 设计目标\n能够实现显示总页数、当前页、显示当前页前后页码、跳转到指定页、修改每页显示数量等功能，如下图所示：\n\n\n3. 实现过程\n这里只展示核心逻辑，一些较为简单的逻辑这里就不多赘述。完整代码请参考https://github.com/lxmghct/lxmghct.github.io/blob/master/_includes/pagination.html\n3.1 分页核心逻辑\n开始索引为pageSize * (currentPage - 1)，结束索引为pageSize * currentPage，遍历所有待分页元素，根据索引通过添加或移除hide类来显示或隐藏元素。\n    function changeContentShow() {\n      const showPageStart = paginationData.pageSize * (paginationData.currentPage - 1);\n      const showPageEnd = paginationData.pageSize * paginationData.currentPage;\n      for (let i = 0; i < paginationData.total; i++) {\n        if (i >= showPageStart && i < showPageEnd) {\n          pageItems[i].classList.remove(\"hide\");\n        } else {\n          pageItems[i].classList.add(\"hide\");\n        }\n      }\n    }\n\n\n3.2 显示当前页前后页码\n这里采用的方式是：每次页码更新时，重新生成页码列表，根据当前页码和总页数，生成当前页码前后大约3个页码的页码列表，如果当前页码距离第一页或最后一页小于3，则显示当前页码前后的页码直到第一页或最后一页；否则就显示为省略号...。\n    function showPagerList() {\n      const totalPage = Math.ceil(paginationData.total / paginationData.pageSize);\n      pagerContainer.innerHTML = \"\";\n      const createLi = (i) => {\n        const li = document.createElement(\"li\");\n        li.innerText = i;\n        pagerContainer.appendChild(li);\n        // add click event\n        if (i !== \"...\") {\n          li.addEventListener(\"click\", () => {\n            paginationData.currentPage = i;\n            changePage();\n          });\n        }\n        // set active\n        if (i === paginationData.currentPage) {\n          li.classList.add(\"active\");\n        }\n      }\n      const start = 1, end = totalPage;\n      const pagerNumberList = [];\n      if (paginationData.currentPage - start > 3) {\n        pagerNumberList.push(...[start, start + 1, \"...\", paginationData.currentPage - 1, paginationData.currentPage]);\n      } else {\n        for (let i = start; i <= paginationData.currentPage; i++) {\n          pagerNumberList.push(i);\n        }\n      }\n      if (end - paginationData.currentPage > 3) {\n        pagerNumberList.push(...[paginationData.currentPage + 1, \"...\", end - 1, end]);\n      } else {\n        for (let i = paginationData.currentPage + 1; i <= end; i++) {\n          pagerNumberList.push(i);\n        }\n      }\n      pagerNumberList.forEach((item) => {\n        createLi(item);\n      });\n    }\n\n\n3.3 优化组件的使用\n将该分页组件封装为_include目录下的一个组件，通过组件调用时传参来配置一些参数，尽量能够直接使用。\n\n这里我打算父组件只向分页组件传递待分页元素父组件的选择器，分页组件自动获取该父组件下的所有待分页元素，然后进行分页操作。这样做的好处是：父组件不需要关心待分页元素的数量，也不需要任何其他操作就可以使用分页组件。\n\n考虑到分页组件有时候需要放在分页元素的父组件外，所以还需要传递一个参数parent，用来指定分页元素的父组件的选择器。这两个选择器可以相同，也可以不同。\n\n组件之间传参的方式为：\n父组件使用如下方式调用子组件并传参：\n<!-- pagination.html -->\n\n<div class=\"my-pagination\">\n  <ul class=\"my-pager\">\n    <li class=\"active\">1</li>\n    <li>2</li>\n  </ul>\n  <span class=\"my-pagination__sizes\">\n    <span class=\"my-pagination__sizes__label\">每页</span>\n    <select class=\"my-pagination__sizes__select\" autocomplete=\"off\">\n      <option>5</option>\n      <option>10</option>\n      <option>20</option>\n    </select>\n    <span class=\"my-pagination__sizes__label\">条</span>\n  </span>\n  <span class=\"my-pagination__total\">共 0 条</span>\n  <span class=\"my-pagination__goto\">\n    <span class=\"my-pagination__goto__label\">前往</span>\n    <input class=\"my-pagination__goto__input\" type=\"text\" />\n    <span class=\"my-pagination__goto__label\">页</span>\n  </span>\n</div>\n\n<script>\n  (function () {\n    const contentSelector = '.home';\n    const parentSelector = '.home';\n    const contentContainer = document.querySelector(`${contentSelector}`);\n    if (!contentContainer || !contentSelector || !parentSelector) {\n      console.error(\"pagination.html: content or parent is not defined\");\n      return;\n    }\n    const pageItems = []\n    const pagerContainer = document.querySelector(`${parentSelector} .my-pager`);\n    const totalContainer = document.querySelector(`${parentSelector} .my-pagination__total`);\n    const sizesSelect = document.querySelector(`${parentSelector} .my-pagination__sizes__select`);\n    const gotoInput = document.querySelector(`${parentSelector} .my-pagination__goto__input`);\n\n    const paginationData = {\n      total: 0,\n      pageSize: 10,\n      currentPage: 1\n    }\n    sizesSelect.value = paginationData.pageSize;\n\n    function showPagerList() {\n      const totalPage = Math.ceil(paginationData.total / paginationData.pageSize);\n      pagerContainer.innerHTML = \"\";\n      const createLi = (i) => {\n        const li = document.createElement(\"li\");\n        li.innerText = i;\n        pagerContainer.appendChild(li);\n        // add click event\n        if (i !== \"...\") {\n          li.addEventListener(\"click\", () => {\n            paginationData.currentPage = i;\n            changePage();\n          });\n        }\n        // set active\n        if (i === paginationData.currentPage) {\n          li.classList.add(\"active\");\n        }\n      }\n      const start = 1, end = totalPage;\n      const pagerNumberList = [];\n      if (paginationData.currentPage - start > 3) {\n        pagerNumberList.push(...[start, start + 1, \"...\", paginationData.currentPage - 1, paginationData.currentPage]);\n      } else {\n        for (let i = start; i <= paginationData.currentPage; i++) {\n          pagerNumberList.push(i);\n        }\n      }\n      if (end - paginationData.currentPage > 3) {\n        pagerNumberList.push(...[paginationData.currentPage + 1, \"...\", end - 1, end]);\n      } else {\n        for (let i = paginationData.currentPage + 1; i <= end; i++) {\n          pagerNumberList.push(i);\n        }\n      }\n      pagerNumberList.forEach((item) => {\n        createLi(item);\n      });\n    }\n\n    function changeTotal() {\n      pageItems.length = 0;\n      for (let i = 0; i < contentContainer.children.length; i++) {\n        if (contentContainer.children[i].classList.contains(\"my-pagination\") || contentContainer.children[i].tagName === \"SCRIPT\") {\n          continue;\n        }\n        pageItems.push(contentContainer.children[i]);\n      }\n      paginationData.total = pageItems.length;\n      totalContainer.innerText = `共 ${paginationData.total} 条`;\n    }\n\n    function changeContentShow() {\n      const showPageStart = paginationData.pageSize * (paginationData.currentPage - 1);\n      const showPageEnd = paginationData.pageSize * paginationData.currentPage;\n      for (let i = 0; i < paginationData.total; i++) {\n        if (i >= showPageStart && i < showPageEnd) {\n          pageItems[i].classList.remove(\"hide\");\n        } else {\n          pageItems[i].classList.add(\"hide\");\n        }\n      }\n    }\n\n    function changePage() {\n      showPagerList();\n      changeContentShow();\n      gotoInput.value = paginationData.currentPage;\n    }\n\n    function startPagination() {\n      changeTotal();\n      changePage();\n    }\n\n    sizesSelect.addEventListener(\"change\", (e) => {\n      paginationData.pageSize = e.target.value;\n      paginationData.currentPage = 1;\n      changePage();\n    });\n\n    gotoInput.addEventListener(\"keyup\", (e) => {\n      if (e.keyCode === 13) {\n        const gotoPage = parseInt(e.target.value);\n        if (gotoPage > 0 && gotoPage <= Math.ceil(paginationData.total / paginationData.pageSize)) {\n          paginationData.currentPage = gotoPage;\n          changePage();\n        }\n      }\n    });\n\n    // 监听内容变化\n    const observer = new MutationObserver((mutationsList) => {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n          changeTotal();\n          paginationData.currentPage = 1;\n          changePage();\n        }\n      }\n    });\n    observer.observe(contentContainer, { childList: true });\n\n    startPagination();\n  })();\n</script>\n\n子组件接收参数的方式为：\n    const contentSelector = '';\n    const parentSelector = '';\n    const contentContainer = document.querySelector(`${contentSelector}`);\n    const pagerContainer = document.querySelector(`${parentSelector} .my-pager`);\n\n\n3.4 实时更新分页组件\n待分页容器内的元素有时会在其他地方被改变，所以最好能够实时更新分页组件的各个分页参数，避免不必要的额外操作，方便分页组件的使用。可以采用MutationObserver来监听待分页容器内元素的变化，然后实时更新分页组件。\n\n    const observer = new MutationObserver((mutationsList) => {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n          changeTotal(); // update total\n          paginationData.currentPage = 1;\n          changePage(); // update page\n        }\n      }\n    });\n    observer.observe(contentContainer, { childList: true });\n\n"
  },
  {
    "title": "jekyll构建博客过程中遇到的一些问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/10/12/jekyll%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html",
    "date": "2023-10-12 13:00:00 +0000",
    "content": "1. 构建时sass警告\nremote: DEPRECATION WARNING: Using / for division outside of calc() is deprecated and will be removed in Dart Sass 2.0.0.\n\n参考: https://github.com/jekyll/minima/issues/709\n这些警告的根本原因来自 jekyll-sass-converter-3.0.0，它使用了 Sass 的新实现。可以编辑的 Gemfile，仅使用 jekyll-sass-converter-2.x。或者继续使用 sass-converter 的 v3 版本，但通过你的配置文件禁用这些警告：\nsass:\n  quiet_deps: true\n\n"
  },
  {
    "title": "使用jekyll和github pages搭建个人博客",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/10/12/%E4%BD%BF%E7%94%A8jekyll%E5%92%8Cgithub-pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html",
    "date": "2023-10-12 06:00:00 +0000",
    "content": "Jekyll 是一个静态网站生成器，它可以将文本文档（如 Markdown 或 Textile）和 HTML 文件通过一些处理生成一个有机整体的 HTML 语言的网站。Jekyll 的核心是一个文本转换引擎，它支持多种文本标记语言，例如 Markdown 和 HTML，并通过 Liquid 渲染器转化成一个完整的可发布的静态网站。\n\nGitHub Pages 是一个由 GitHub 提供的静态网站托管服务，它允许用户在 GitHub 上托管自己的静态网站，并提供了一些域名配置和自定义选项。用户可以通过 GitHub Pages 托管个人博客、项目文档等静态网站内容。\n\n下面我将介绍一下自己搭建博客的过程。\n\n1. 创建GitHub Pages仓库\n首先，在GitHub上创建一个仓库，用于存放博客内容。在仓库名为username.github.io，其中username是GitHub用户名。比如我的是lxmghct.github.io。注意仓库的访问权限要设置为Public。在该仓库的settings中，可以修改github pages的一些配置，如主题、分支、域名等。\n\n\n\n2. 安装环境\n本地搭建Jekyll环境，可以在本地预览博客效果，也可以在本地编辑博客内容。\n2.1 安装Ruby\nRuby官网下载地址：https://rubyinstaller.org/downloads/\n\n\n\n安装完成后，可以在命令行中输入ruby -v查看版本。\n\n2.2 安装rubygems\nRubyGems 是 Ruby 的一个包管理器，它提供了一个标准的格式来打包 Ruby 程序和库，还提供了一个管理这些包的工具。RubyGems 是一个用于分发 Ruby 程序和库的标准格式，它可以自动下载、安装、管理 Ruby 程序和库。\nRubyGems 官网下载地址：https://rubygems.org/pages/download\n\n下载后解压后，进入解压目录，执行命令：\ncd D:\\rubygems-3.4.19\\\nruby setup.rb\ngem -v # 查看版本\n\n\n2.3 安装Jekyll\ngem install jekyll\njekyll -v # 查看版本\n\n\n3. 创建并运行博客\n\n3.1 创建博客\n可以使用Jekyll提供的命令创建博客：\njekyll new myblog\n\n\n也可以fork一个现成的博客模板，然后clone到本地。\n\njekyll的目录结构如下：\n\n_config.yml: 存储配置数据，例如网站主题，名称，介绍，域名，Github用户名等。\n_drafts: 存放未发布的文章，这些文件的格式中都没有日期，例如 title.MARKUP。\n_includes: 可以加载这些包含部分到你的布局或者文章中以方便重用。例如，可以用这个标签 {% include file.ext %} 来把文件 _includes/file.ext 包含进来。\n_layouts: 这是包裹在文章外部的模板。布局可以在 YAML 头信息中根据不同文章进行选择。例如，标签 {{ content }} 可以将 content 插入页面中。\n_posts: 这里放的就是你的文章了。文件格式很重要，必须要符合: YEAR-MONTH-DAY-title.MARKUP。\n_site: 一旦 Jekyll 完成转换，就会将生成的页面放在这里（默认）。\n\n\n3.2 运行博客\ncd myblog\njekyll server\n\n然后在浏览器中输入http://localhost:4000，就可以看到博客的效果了。如果需要修改端口可以在_config.yml中修改port字段。\n\n\n  每次修改代码后，无需重启服务，刷新浏览器即可看到效果。如果修改了_config.yml文件，需要重启服务。\n  如果在博客代码块中出现liquid语法，可以在前后加上{% raw %}和{% endraw %}，使其不被解析。如果想要显示{% raw %}，可以使用如下代码:\n\n\n{% assign openTag = '{%' %}\n{{ openTag }} raw %}\n...\n{{ openTag }} endraw %}\n\n\n4. 发布博客\n将博客内容提交到GitHub仓库中，每次提交代码都会触发GitHub Pages的构建，大约1-2分钟后，就可以在https://username.github.io上看到博客的效果了。\n\n5. 其他说明\n\n  Github Pages 并不是无限存储和无限流量的静态站点服务，一些限制如下：\n    \n      仓库大小限制为1GB\n      每月流量限制为100GB\n      每小时构建限制为10次\n更多信息可以参考github官网说明usage-limits。\n    \n  \n  如果需要使用自定义域名，可以在仓库的settings中进行配置。或者在根目录下创建一个名为CNAME的文件，文件内容为自定义域名。\n\n"
  },
  {
    "title": "linux非root用户安装python3.8",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/09/17/linux%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85python3.8.html",
    "date": "2023-09-17 09:40:00 +0000",
    "content": "1. 下载Python\nwget https://www.python.org/ftp/python/3.8.10/Python-3.8.10.tgz\ntar -zxvf Python-3.8.10.tgz\n\n此时尝试编译安装，一般会缺少某些依赖编译失败。\n./configure --prefix=$HOME/python3\nmake && make install\n\nmake步骤一般会报下面的错:\nFailed to build these modules:\n_hashlib              _ssl                                     \n\nCould not build the ssl module!\nPython requires an OpenSSL 1.0.2 or 1.1 compatible libssl with X509_VERIFY_PARAM_set1_host().\nLibreSSL 2.6.4 and earlier do not provide the necessary APIs, https://github.com/libressl-portable/portable/issues/381\n\n有时还会缺少zlib, libffi, sqlite3等。\nPython build finished successfully!\nThe necessary bits to build these optional modules were not found:\n_bz2                  _curses               _curses_panel      \n_dbm                  _gdbm                 _lzma              \n_sqlite3              _tkinter              _uuid              \nreadline              zlib   \n\n缺少libffi导致_ctypes模块编译失败:\nfatal error: ffi.h: No such file or directory\n  107 | #include <ffi.h>\n      |          ^~~~~~~\ncompilation terminated.\n\nFailed to build these modules:\n_ctypes \n\n\n2. 安装openssl, libffi, zlib, sqlite3等依赖库\n\n2.1. 直接下载已经编译好的库\n有root权限可以直接使用包管理器安装，如yum, apt-get, brew等。但是在没有root权限的情况下，可以自己编译安装。也可以下载已经编译好的库，然后指定路径。\n\napt-get download libbz2-dev lib-lzma-dev\ndpkg -x libbz2-dev_1.0.8-4_amd64.deb $HOME/libs/libbz2\ndpkg -x liblzma-dev_5.2.2-1.3_amd64.deb $HOME/libs/liblzma\n\n\n2.2. 下载源码编译安装\n\n这里以openssl, libffi, zlib, sqlite3为例。\n\nopenssl:\n\nwget https://www.openssl.org/source/openssl-1.1.1d.tar.gz\ntar -zxvf openssl-1.1.1d.tar.gz\ncd openssl-1.1.1d\n./config --prefix=$HOME/libs/openssl\nmake && make install\n\n\nlibffi和zlib也都类似的步骤。\n\nlibffi前往https://github.com/libffi/libffi/releases下载\n\nzlib前往https://zlib.net/下载。或者其他站点下载:\nwget https://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.11/zlib-1.2.11.tar.gz\n\n\nsqlite3: 参考https://blog.csdn.net/qq_37144341/article/details/115214323\n\nwget https://www.sqlite.org/2017/sqlite-autoconf-3170000.tar.gz\ntar -zxvf sqlite-autoconf-3170000.tar.gz\ncd sqlite-autoconf-3170000\n./configure --prefix=$HOME/libs/sqlite3 --disable-static --enable-fts5 --enable-json1 CFLAGS=\"-g -O2 -DSQLITE_ENABLE_FTS3=1 \n\n\n2.3. 配置环境变量\n\n写入环境变量, 打开~/.bashrc添加如下内容:\n\nexport LD_LIBRARY_PATH=$HOME/libs/libbz2/usr/lib/x86_64-linux-gnu:$HOME/libs/liblzma/usr/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH\n\n\n其他依赖库类似。\n\n这里需要写进~/.bashrc，如果仅仅只在当前shell生效，那么尽管python可以编译安装成功，并且可以正常执行。但是在下次重新进入系统或者打开新的shell时，就会在执行python代码时，比如python xxx.py时，会报错找不到依赖库，报错类似于:\n\nModuleNotFoundError: No module named '_lzma'\n\n\n一开始我遇到时确实有点困惑，以为是有别人也在服务器上动过相关的环境。后面才意识到忘记把依赖库的路径写入环境变量。\n\n3. 编译安装Python\n先指定编译时的依赖库的路径，尽管上面配了LD_LIBRARY_PATH，但是编译时还是需要指定依赖库的头文件和库文件的路径。\n\nexport LDFLAGS=\"-L$HOME/libs/openssl/lib -L$HOME/libs/libffi/lib -L$HOME/libs/zlib/lib\"\nexport CPPFLAGS=\"-I$HOME/libs/openssl/include -I$HOME/libs/libffi/include -I$HOME/libs/zlib/include\"\n\n\n然后重新编译安装Python:\n\n# 可以输入./configure --help查看更多选项, 这里openssl可以用--with-openssl指定\n./configure --prefix=$HOME/python3 --with-openssl=$HOME/libs/openssl\n\n# 也可以直接把上一步LDFLAGS和CPPFLAGS的设置放到configure的前面\n# LDFLAGS=... CPPFLAGS=... ./configure --prefix=$HOME/python3 --with-openssl=$HOME/libs/openssl\n\n# 也可以用pkg-config来查找依赖库的路径\n# export PKG_CONFIG_PATH=$HOME/libs/openssl/lib/pkgconfig:$HOME/libs/libffi/lib/pkgconfig:$HOME/libs/zlib/lib/pkgconfig\n# LDFLAGS=$(pkg-config --libs-only-L openssl) ...其他部分同上\n\n\nmake\n# 如果比较慢可以加上-j参数 make -j8\n# 如果没有出现\"Failed to build these modules: ...\"之类的错误，就可以继续安装\nmake install\n\n\n4. 配置环境变量\necho 'export PATH=$HOME/python3/bin:$PATH' >> ~/.bashrc\nsource ~/.bashrc\n\n\n5. 测试\npython3 --version\npip3 --version\n\n\n"
  },
  {
    "title": "Welcome to Jekyll!",
    "url": "/%E6%B5%8B%E8%AF%95/2023/09/11/welcome-to-jekyll.html",
    "date": "2023-09-11 07:05:05 +0000",
    "content": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.\n\nJekyll requires blog post files to be named according to the following format:\n\nYEAR-MONTH-DAY-title.MARKUP\n\nWhere YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.\n\nJekyll also offers powerful support for code snippets:\n\ndef print_hi(name)\n  puts \"Hi, #{name}\"\nend\nprint_hi('Tom')\n#=> prints 'Hi, Tom' to STDOUT.\n\nCheck out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.\n\nTest mathjax:\n\n\\[R_{\\mu \\nu} - {1 \\over 2}g_{\\mu \\nu}\\,R + g_{\\mu \\nu} \\Lambda\n= {8 \\pi G \\over c^4} T_{\\mu \\nu}\\]\n"
  },
  {
    "title": "unity将安卓streamingAssetsPath文件复制到persistentDataPath",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/06/18/unity%E5%B0%86%E5%AE%89%E5%8D%93streamingAssetsPath%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%88%B0persistentDataPath.html",
    "date": "2023-06-18 05:40:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17489056.html\n现在转移到 github pages 上。\n\nprivate void TestCopy()\n{\n  string from = Application.streamingAssetsPath + \"/Test/test.txt\";\n  string to = Application.persistentDataPath + \"/Test/\";\n  CopyFile(from, to);\n}\n\npublic static void CopyFile(string sourcePath, string destinationPath)\n{\n    byte[] fileData = null;\n    // 从 StreamingAssets 文件夹读取文件数据\n    if (Application.platform == RuntimePlatform.Android)\n    {\n        using (UnityWebRequest www = UnityWebRequest.Get(sourcePath))\n        {\n            www.SendWebRequest();\n            while (!www.isDone) { }\n            fileData = www.downloadHandler.data;\n        }\n    }\n    else\n    {\n        fileData = File.ReadAllBytes(sourcePath);\n    }\n    // 创建目标文件夹（如果不存在）\n    string destinationFolder = Path.GetDirectoryName(destinationPath);\n    if (!Directory.Exists(destinationFolder))\n    {\n        Directory.CreateDirectory(destinationFolder);\n    }\n    // 将文件数据写入目标文件\n    File.WriteAllBytes(destinationPath, fileData);\n}\n\n\n"
  },
  {
    "title": "windows下将Pikafish编译为安卓可执行文件",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/05/25/windows%E4%B8%8B%E5%B0%86Pikafish%E7%BC%96%E8%AF%91%E4%B8%BA%E5%AE%89%E5%8D%93%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.html",
    "date": "2023-05-25 01:38:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17430256.html\n现在转移到 github pages 上。\n\n1. 下载Android NDK\n\nhttps://developer.android.com/ndk/downloads?hl=zh-cn\n\n2. 下载Pikafish源码\n\nhttps://github.com/official-pikafish/Pikafish\n\n3. 编译\n\n在Pikafish的src目录下创建如下bat文件\n\nset clang=D:\\android-ndk-r25c\\toolchains\\llvm\\prebuilt\\windows-x86_64\\bin\\aarch64-linux-android31-clang++\n\n%clang%  ^\n    -static-libstdc++ ^\n    -Wall ^\n    -Wcast-qual ^\n    -Wextra ^\n    -Wshadow ^\n    -std=c++17 ^\n    -DNDEBUG -O3 ^\n    -DUSE_NEON=8 ^\n    -DIS_64BIT ^\n    -DUSE_PTHREADS ^\n    -DUSE_POPCNT ^\n    -pedantic ^\n    -fno-exceptions ^\n    -flto=full ^\n    -DANDROID_STL=c++_shared ^\n    benchmark.cpp ^\n    bitboard.cpp ^\n    evaluate.cpp ^\n    main.cpp ^\n    misc.cpp ^\n    movegen.cpp ^\n    movepick.cpp ^\n    position.cpp ^\n    search.cpp ^\n    thread.cpp ^\n    timeman.cpp ^\n    tt.cpp ^\n    tune.cpp ^\n    uci.cpp ^\n    ucioption.cpp ^\n    nnue\\evaluate_nnue.cpp ^\n    nnue\\features\\half_ka_v2_hm.cpp ^\n    external\\zip.cpp ^\n    -o pikafish\n\n具体的clang路径需要根据自己的ndk版本进行修改, -static-libstdc++不加也能编译成功，但在安卓上运行时会报找不到libc++_shared.so的错误，所以采用静态链接的方式。\n\n4. 运行\n将编译好的pikafish文件和pikafish.nnue文件放到同一个目录下，然后用adb运行即可。\n\n"
  },
  {
    "title": "vue自定义组件 search-box",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/05/17/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6-search-box.html",
    "date": "2023-05-17 05:15:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17408456.html\n现在转移到 github pages 上。\n\ngithub地址: https://github.com/lxmghct/my-vue-components\n\n组件介绍\n\n  props:\n    \n      value/v-model: 检索框的值, default: ‘’\n      boxStyle: 检索框的样式, default: ‘position: fixed; top: 0px; right: 100px;’\n      highlightColor: 高亮颜色, default: ‘rgb(246, 186, 130)’\n      currentColor: 当前高亮颜色, default: ‘rgb(246, 137, 31)’\n      selectorList: 检索的选择器列表, default: []\n      iFrameId: 检索的iframe的id, default: null, 若需要搜索iframe标签中的内容, 则将该参数设为目标iframe的id\n      beforeJump: 跳转前的回调函数, default: () => {}\n      afterJump: 跳转后的回调函数, default: () => {}\n      (注: 上述两个回调函数参数为currentIndex, currentSelector, lastIndex, lastSelector)\n    \n  \n  events:\n    \n      @search: 检索时触发, 参数为input和total\n      @goto: 跳转时触发, 参数为index\n      @close: 关闭时触发\n    \n  \n  methods:\n    \n      clear() 清空检索框\n      search() 检索\n    \n  \n\n\n效果展示\n\n\n设计思路\n完整代码见github: https://github.com/lxmghct/my-vue-components\n在其中的src/components/SearchBox下。\n1. 界面\n界面上比较简单, 输入框、当前/总数、上一个、下一个、关闭按钮。\n<div class=\"search-box\" :style=\"boxStyle\">\n  <input\n    v-model=\"input\"\n    placeholder=\"请输入检索内容\"\n    class=\"search-input\"\n    type=\"text\"\n    @input=\"search\"\n  >\n  <!--当前/总数、上一个、下一个、关闭-->\n  <span class=\"input-append\">\n    &nbsp;&nbsp;/&nbsp;&nbsp;\n  </span>\n  <span class=\"input-append\" @click=\"searchPrevious\">\n    <div class=\"svg-container\">\n      <svg width=\"100px\" height=\"100px\">\n        <path d=\"M 100 0 L 0 50 L 100 100\" stroke=\"black\" fill=\"transparent\" stroke-linecap=\"round\"/>\n      </svg>\n    </div>\n  </span>\n  <span class=\"input-append\" @click=\"searchNext\">\n    <div class=\"svg-container\">\n      <svg width=\"100px\" height=\"100px\" transform=\"rotate(180)\">\n        <path d=\"M 100 0 L 0 50 L 100 100\" stroke=\"black\" fill=\"transparent\" stroke-linecap=\"round\"/>\n      </svg>\n    </div>\n  </span>\n  <span class=\"input-append\" @click=\"searchClose\">\n    <div class=\"svg-container\">\n      <svg width=\"100%\" height=\"100%\">\n        <line x1=\"0\" y1=\"0\" x2=\"100%\" y2=\"100%\" stroke=\"black\" stroke-width=\"1\" />\n        <line x1=\"100%\" y1=\"0\" x2=\"0\" y2=\"100%\" stroke=\"black\" stroke-width=\"1\" />\n      </svg>\n    </div>\n  </span>\n</div>\n\n\n2. 检索与跳转\n这部分是search-box的核心功能，一共有以下几个需要解决的问题:\n\n  获取待搜索的容器\n    \n      为提高组件的通用性，可以通过传入选择器列表来获取容器，如['.container', '#containerId']，使用document.querySelector()获取容器。\n    \n  \n  获取所有文本\n    \n      不能单独对某个dom节点获取文本, 因为某个待搜索词可能被分割在多个节点中, 例如<span>hello</span><span>world</span>，所以需要获取整个容器内的所有文本拼接起来, 然后再进行检索。\n      使用innetText获取文本会受到样式影响, 具体见文章最后的其它问题。所以需要遍历所有节点将文本拼接起来。\n      遍历文本节点时, 可以用node.nodeType === Node.TEXT_NODE判断是否为文本节点。\n         if (node.nodeType === Node.TEXT_NODE) { // text node\n  callback(node)\n } else if (node.nodeType === Node.ELEMENT_NODE) { // element node\n  for (let i = 0; i < node.childNodes.length; i++) {\n      traverseTextDom(node.childNodes[i], callback)\n  }\n }\n        \n      \n    \n  \n  检索结果的保存\n    \n      由于查找完之后需要实现跳转, 所以为方便处理, 将检索到的结果所在的dom节点保存起来, 以便后续跳转时使用。每个结果对应一个domList。\n    \n  \n  高亮检索词\n    \n      使用span标签包裹检索词, 并设置样式, 实现高亮。\n      为了避免检索词被html标签分割, 可以对检索词的每个字符都用span标签包裹, 例如检索词为hello，则可以将其替换为<span>h</span><span>e</span><span>l</span><span>l</span><span>o</span>。\n      样式设置可以给span设置background-color, 为了方便修改并减小整体html长度, 可以改为给span设置class, 注意这种情况下在style标签设置的样式未必有效, 可以采用动态添加样式的方式。\n         function createCssStyle (css) {\n  const style = myDocument.createElement('style')\n  style.type = 'text/css'\n  try {\n      style.appendChild(myDocument.createTextNode(css))\n  } catch (ex) {\n      style.styleSheet.cssText = css\n  }\n  myDocument.getElementsByTagName('head')[0].appendChild(style)\n }\n        \n      \n      将span标签插入到原先文本节点的位置, 若使用innerHtml直接进行替换, 处理起来略有些麻烦。可以考虑使用insertBefore和removeChild方法。\n         const tempNode = myDocument.createElement('span')\n tempNode.innerHTML = textHtml\n const children = tempNode.children\n if (children) {\nfor (let i = 0; i < children.length; i++) {\n  domList.push(children[i])\n}\n }\n // 将节点插入到parent的指定位置\n // insertBofore会将节点从原来的位置移除，导致引错误，所以不能用forEach\n while (tempNode.firstChild) {\nparent.insertBefore(tempNode.firstChild, textNode)\n }\n parent.removeChild(textNode)\n        \n      \n    \n  \n  跳转\n 由于结果对应的dom节点已保存，所以跳转起来比较容易。跳转时修改当前高亮的dom节点的类名, 然后将其滚动到可视区域。\n     setCurrent (index) {\n     const lastSelector = this.searchResult[this.currentIndex] ? this.searchResult[this.currentIndex].selector : null\n     const currentSelector = this.searchResult[index] ? this.searchResult[index].selector : null\n     if (this.currentIndex >= 0 && this.currentIndex < this.searchResult.length) {\n         this.searchResult[this.currentIndex].domList.forEach((dom) => {\n             dom.classList.remove(this.currentClass)\n         })\n         this.searchResult[this.currentIndex].domList[0].scrollIntoView({ behavior: 'smooth', block: 'center' })\n     }\n     this.currentIndex = index\n     if (this.currentIndex >= 0 && this.currentIndex < this.searchResult.length) {\n         this.searchResult[this.currentIndex].domList.forEach((dom) => {\n             dom.classList.add(this.currentClass)\n         })\n     }\n }\n    \n  \n  移除高亮效果\n    \n      由于高亮效果是通过给text节点添加span标签实现, 所以需要将span标签移除, 并替换为原先的文本节点。\n      使用insertBefore和removeChild方法。\n      替换完节点后需要调用normalize()方法, 将相邻的文本节点合并为一个文本节点。\n         function convertHighlightDomToTextNode (domList) {\n  if (!domList || !domList.length) { return }\n  domList.forEach(dom => {\n      if (dom && dom.parentNode) {\n          const parent = dom.parentNode\n          const textNode = myDocument.createTextNode(dom.textContent)\n          parent.insertBefore(textNode, dom)\n          parent.removeChild(dom)\n          parent.normalize() // 合并相邻的文本节点\n      }\n  })\n }\n        \n      \n    \n  \n\n\n3. 添加对iframe的支持\n有时候页面中可能会包含iframe标签, 如果需要检索iframe中的内容, 直接使用当前的document是无法获取到iframe中的内容的, 需要拿到iframe的document对象。\nconst myIframe = document.getElementById(this.iframeId)\nif (myIframe) {\n  myDocument = myIframe.contentDocument || myIframe.contentWindow.document\n} else {\n  myDocument = document\n}\nif (myIframe && this.lastIframeSrc !== myIframesrc) {\n  const css = `.${this.highlightClass} { background-color: ${this.highlightColor}; } .${this.currentClass} { background-color: ${this.currentColor}; }`\n  createCssStyle(css)\n  this.lastIframeSrc = myIframe.src\n}\n\n同一个iframe, 如果src发生变化, 则需要重新给其生成样式, 否则样式会失效。\n其他问题\n\n  使用svg画按钮图标时，双击svg按钮会自动触发全选\n    \n      解决方法: 在svg标签所在容器上添加user-select: none;样式\n    \n  \n  使用node.nodeType === Node.TEXT_NODE判断文本节点时，会遇到一些空节点，导致检索错误\n    \n      解决方法: 在判断文本节点时，加上node.textContent.trim() !== ''的判断, 获取所有元素的文本时。\n      后续修改: 可以不单独处理这些空的文本节点, 只要保证所有使用到获取文本的地方都统一使用或不使用trim()即可。尽量都不使用trim(), 如果随意使用trim()，可能会导致部分空白字符被误删。\n    \n  \n\n"
  },
  {
    "title": "Mybatis plus拦截器解决 foreach 列表为空报错问题",
    "url": "/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/2023/05/09/Mybatis-plus%E6%8B%A6%E6%88%AA%E5%99%A8%E8%A7%A3%E5%86%B3foreach%E5%88%97%E8%A1%A8%E4%B8%BA%E7%A9%BA%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98.html",
    "date": "2023-05-09 08:45:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17385580.html\n现在转移到 github pages 上。\n\n在mybatis中使用<foreach>标签时, 如果传入的列表为空, 则解析为sql语句时<foreach>标签所在位置会被解析为空, 最终的sql呈现为in ()或者in后面的内容为空, 从而导致sql语法错误。\n网上找了很多种方法，如果foreach用的地方比较少，在执行sql之前判空即可。如果用到foreach的地方比较多，用拦截器来处理可能会更好。\n\n参考: https://blog.csdn.net/qq_26222859/article/details/55101903\n部分代码做了一些修改。\n\n拦截器：\nimport org.apache.ibatis.cache.CacheKey;\nimport org.apache.ibatis.executor.Executor;\nimport org.apache.ibatis.mapping.BoundSql;\nimport org.apache.ibatis.mapping.MappedStatement;\nimport org.apache.ibatis.plugin.*;\nimport org.apache.ibatis.session.ResultHandler;\nimport org.apache.ibatis.session.RowBounds;\n\nimport java.util.*;\n\n@Intercepts({\n        @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}),\n        @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class}),\n        @Signature(type = Executor.class, method = \"update\", args = {MappedStatement.class,Object.class})\n})\npublic class EmptyCollectionInterceptor implements Interceptor {\n\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        Object[] args = invocation.getArgs();\n        MappedStatement mappedStatement = (MappedStatement) args[0];\n        Object parameter = args[1];\n        if (parameter == null) {\n            Class<?> parameterType = mappedStatement.getParameterMap().getType();\n            // 实际执行时的参数值为空，但mapper语句上存在输入参数的异常状况，返回默认值\n            if (parameterType != null) {\n                return getDefaultReturnValue(invocation);\n            }\n            return invocation.proceed();\n        }\n        BoundSql boundSql = mappedStatement.getBoundSql(parameter);\n        if (hasEmptyList(boundSql.getSql())) {\n            return getDefaultReturnValue(invocation);\n        }\n        return invocation.proceed();\n    }\n\n    @Override\n    public Object plugin(Object target) {\n        //只拦截Executor对象，减少目标被代理的次数\n        if (target instanceof Executor) {\n            return Plugin.wrap(target, this);\n        } else {\n            return target;\n        }\n    }\n\n    @Override\n    public void setProperties(Properties properties) {\n    }\n\n    /**\n     * 返回默认的值，list类型的返回空list,数值类型的返回0\n     *\n     * @param invocation Invocation\n     * @return Object\n     */\n    private Object getDefaultReturnValue(Invocation invocation) {\n        Class<?> returnType = invocation.getMethod().getReturnType();\n        if (returnType.equals(List.class)) {\n            return new ArrayList<>();\n        } else if (returnType.equals(Integer.class) || returnType.equals(int.class)\n                || returnType.equals(Long.class) || returnType.equals(long.class)\n                || returnType.equals(Short.class) || returnType.equals(short.class)\n                || returnType.equals(Byte.class) || returnType.equals(byte.class)) {\n            return 0;\n        }\n        return null;\n    }\n\n    /**\n     * 判断是否存在空list\n     *\n     * @param sql sql\n     * @return boolean\n     */\n    private static boolean hasEmptyList(String sql) {\n        char quote = '\\0';\n        int index = 0;\n        int len = sql.length();\n        boolean hasBackSlash = false;\n        // 找到不在引号内的in关键字\n        while (index < len) {\n            char c = sql.charAt(index++);\n            if (hasBackSlash) { // 忽略转义字符\n                hasBackSlash = false;\n                continue;\n            }\n            switch (c) {\n                case '\\\\':\n                    hasBackSlash = true;\n                    break;\n                case '\\'':\n                case '\"':\n                case '`':\n                    if (quote == c) {\n                        quote = '\\0';\n                    } else if (quote == '\\0') {\n                        quote = c;\n                    }\n                    break;\n                case 'i':\n                case 'I':\n                    if (quote == '\\0' && index + 1 < len && (sql.charAt(index) == 'n' || sql.charAt(index) == 'N') && index > 1) {\n                        // in前必须是空白字符或三种引号或右括号，in后必须是空白字符或左括号\n                        if (sql.substring(index - 2, index + 2).matches(\"(?i)([\\\\s)\\\"'`]in[\\\\s(])\")) {\n                            int leftQuoteIndex = sql.indexOf('(', index + 1);\n                            int rightQuoteIndex = sql.indexOf(')', index + 1);\n                            if (leftQuoteIndex == -1 || rightQuoteIndex == -1 || leftQuoteIndex > rightQuoteIndex ||\n                                    !sql.substring(index + 1, leftQuoteIndex).trim().isEmpty() ||\n                                    sql.substring(leftQuoteIndex + 1, rightQuoteIndex).trim().isEmpty()) {\n                                return true;\n                            } else {\n                                index = rightQuoteIndex + 1;\n                            }\n                        }\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        return false;\n    }\n}\n\n\n配置类：\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport com.mb.process.interceptor.EmptyCollectionInterceptor;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n@Configuration\npublic class MybatisConfig {\n\n    @Autowired\n    private List<SqlSessionFactory> sqlSessionFactoryList;\n\n    @PostConstruct\n    public void addMySqlInterceptor() {\n        EmptyCollectionInterceptor interceptor = new EmptyCollectionInterceptor();\n        for (SqlSessionFactory sqlSessionFactory : sqlSessionFactoryList) {\n            sqlSessionFactory.getConfiguration().addInterceptor(interceptor);\n        }\n    }\n\n}\n\n"
  },
  {
    "title": "Feign添加拦截器",
    "url": "/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/2023/05/03/Feign%E6%B7%BB%E5%8A%A0%E6%8B%A6%E6%88%AA%E5%99%A8.html",
    "date": "2023-05-03 10:30:00 +0000",
    "content": "1. 问题\n在项目中以如下方式定义了一个 FeignClient:\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\nimport java.util.List;\n\n@Component\n@FeignClient(name = \"user\")\npublic interface UserInterfaces {\n    @PostMapping(\"/user/deleteUsers\")\n    void deleteUsers(@RequestParam List<Integer> userIds);\n}\n\n但是user模块接口设置了拦截器或者Spring Security，导致调用失败。\n\n2. 解决方案\n可以通过RequestInterceptor来添加拦截器，如下:\nimport feign.RequestInterceptor;\nimport feign.RequestTemplate;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport java.util.Enumeration;\n\n@Configuration\npublic class FeignInterceptorConfig implements RequestInterceptor {\n\n    @Override\n    public void apply(RequestTemplate requestTemplate) {\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        if (attributes != null) {\n            Enumeration<String> headerNames = attributes.getRequest().getHeaderNames();\n            if (headerNames != null) {\n                while (headerNames.hasMoreElements()) {\n                    String name = headerNames.nextElement();\n                    String values = attributes.getRequest().getHeader(name);\n                    requestTemplate.header(name, values);\n                }\n            }\n        }\n    }\n}\n\n这样就可以将FeignClient调用时的请求头信息传递给user模块。\n\n"
  },
  {
    "title": "解决http下navigator.clipboard为undefined的问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/04/21/%E8%A7%A3%E5%86%B3http%E4%B8%8Bnavigator.clipboard%E4%B8%BAundefined%E7%9A%84%E9%97%AE%E9%A2%98.html",
    "date": "2023-04-21 11:56:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17341614.html\n现在转移到 github pages 上。\n\nclipboard只有在安全域名下才可以访问(https、localhost), 而http域名下只能得到undefined。\n例如现在想要实现点击”分享”按钮，将当前页面的url复制到剪贴板：\n  const clipboard = navigator.clipboard\n  if (clipboard) {\n    clipboard.writeText(window.location.href)\n  }\n\n在本地localhost测试是可以的，但是部署到服务器上后，由于部署的服务器使用的是http协议，所以clipboard为undefined。\n解决方法：\n可以考虑使用document.execCommand('copy')来实现复制到剪贴板的功能。\n创建input写入待复制的文本，选定文本后执行document.execCommand('copy')进行复制：\n  const clipboard = navigator.clipboard || {\n    writeText: (text) => {\n      const input = document.createElement('input')\n      input.value = text\n      document.body.appendChild(input)\n      input.select()\n      document.execCommand('copy')\n      document.body.removeChild(input)\n    }\n  }\n  if (clipboard) {\n    clipboard.writeText(window.location.href)\n  }\n\n也可以使用document.execCommand('copy')触发复制事件后，再在复制事件中对剪贴板进行操作：\nexport default {\n  methods: {\n    share() {\n      this.isShare = true\n      document.execCommand('copy')\n      setTimeout(() => { this.isShare = false }, 100)\n    }\n  },\n  created () {\n    this.copyListener = (event) => {\n      if (!this.isShare) { return }\n      const clipboardData = event.clipboardData || window.clipboardData\n      clipboardData.setData('text', window.location.href)\n      event.preventDefault()\n    }\n    window.addEventListener('copy', this.copyListener)\n  },\n  beforeDestroy () {\n    window.removeEventListener('copy', this.copyListener)\n  }\n}\n\n\n"
  },
  {
    "title": "mybatis-plus对列表中数据进行查询的性能比较",
    "url": "/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/2023/04/21/mybatis-plus%E5%AF%B9%E5%88%97%E8%A1%A8%E4%B8%AD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.html",
    "date": "2023-04-21 11:56:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17354547.html\n现在转移到 github pages 上。\n\n使用循环的方式对列表中的数据进行数据库查询肯定要比一次性查询要慢。为了验证一下，所以测试一下二者的性能。\n\n测试代码\n共准备了以下几个测试代码：\n\n  空白对照\n    public List<User> test0() {\n return new ArrayList<>();\n}\n    \n  \n  for循环遍历\n    public List<User> test1(@RequestBody List<Integer> ids) {\n List<User> list = new ArrayList<>();\n for (Integer id : ids) {\n     list.add(userService.getById(id));\n }\n return list;\n}\n    \n  \n  listByIds\n    public List<User> test2(@RequestBody List<Integer> ids) {\n return userService.listByIds(ids);\n}\n    \n  \n  mapper中的foreach\n    // controller\npublic List<User> test3(@RequestBody List<Integer> ids) {\n return userService.selectByIds(ids);\n}\n// mapper\n@Select(\"<script>\" +\n         \"select * from user where id in \" +\n             \"<foreach collection='list' item='item' open='(' separator=',' close=')'>\" +\n                 \"#{item}\" +\n             \"</foreach>\" +\n     \"</script>\")\nList<User> selectByIds(@Param(\"list\") List<Integer> ids);\n    \n  \n\n\n测试结果\nn为ids的长度，使用postman发送请求，各接口响应时间如下：\n\n\n  \n    \n      n\n      test0\n      test1\n      test2\n      test3\n    \n  \n  \n    \n      1\n      214ms\n      260ms\n      260ms\n      260ms\n    \n    \n      2\n      214ms\n      302ms\n      260ms\n      260ms\n    \n    \n      10\n      214ms\n      655ms\n      260ms\n      260ms\n    \n    \n      40\n      214ms\n      2.08s\n      260ms\n      260ms\n    \n    \n      240\n      214ms\n      10.71s\n      261ms\n      261ms\n    \n    \n      1000\n      214ms\n      -\n      267ms\n      267ms\n    \n  \n\n\n测试结论\n空白对照基本可以看做除去数据库查询以外的其他时间，减去这段时间后，可以看出本次实验环境下一次数据库查询的时间大概为40ms左右。使用mybatis的listByIds和foreach的时间基本相同，因为无论n为多少，都只会执行一次数据库查询。而使用for循环反复创建数据库连接的开销太大。\n"
  },
  {
    "title": "js颜色的单词名称字符串转为rgb颜色值",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/04/17/js%E9%A2%9C%E8%89%B2%E7%9A%84%E5%8D%95%E8%AF%8D%E5%90%8D%E7%A7%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BArgb%E9%A2%9C%E8%89%B2%E5%80%BC.html",
    "date": "2023-04-17 15:50:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17328033.html\n现在转移到 github pages 上。\n\njs颜色的单词名称字符串转为rgb颜色值\n将js单词名称如red,green,blue转为rgb颜色值, 暂时没找到什么特别的方法。网上找到了颜色名称与rgb值的对应表，然后构造成map获取rgb值。\n代码放在: https://github.com/lxmghct/my-vue-components的 src/utils/color_convert.js 下。\n\n完整代码如下：\nconst name2rgbMap = {\n  'aliceblue': 'rgb(240,248,255)',\n  'antiquewhite': 'rgb(250,235,215)',\n  'aqua': 'rgb(0,255,255)',\n  'auqamarin': 'rgb(127,255,170)',\n  'azure': 'rgb(240,255,255)',\n  'beige': 'rgb(107,142,35)',\n  'bisque': 'rgb(255,228,196)',\n  'black': 'rgb(0,0,0)',\n  'blanchedalmond': 'rgb(255,235,205)',\n  'blue': 'rgb(0,0,255)',\n  'blueviolet': 'rgb(138,43,226)',\n  'brown': 'rgb(165,42,42)',\n  'brulywood': 'rgb(222,184,135)',\n  'cadetblue': 'rgb(95,158,160)',\n  'chartreuse': 'rgb(127,255,0)',\n  'chocolate': 'rgb(210,105,30)',\n  'coral': 'rgb(255,127,80)',\n  'cornflowerblue': 'rgb(100,149,237)',\n  'cornislk': 'rgb(255,248,220)',\n  'crimson': 'rgb(220,20,60)',\n  'cyan': 'rgb(0,255,255)',\n  'darkblue': 'rgb(0,0,139)',\n  'darkcyan': 'rgb(0,139,139)',\n  'darkgray': 'rgb(169,169,169)',\n  'darkgreen': 'rgb(0,100,0)',\n  'darkkhaki': 'rgb(189,183,107)',\n  'darkmagenta': 'rgb(139,0,139)',\n  'darkorange': 'rgb(255,140,0)',\n  'darkorchid': 'rgb(153,50,204)',\n  'darkred': 'rgb(139,0,0)',\n  'darksalmon': 'rgb(233,150,122)',\n  'darkseagreen': 'rgb(143,188,143)',\n  'darkslateblue': 'rgb(72,61,139)',\n  'darkslategray': 'rgb(47,79,79)',\n  'darkturquoise': 'rgb(0,206,209)',\n  'darkvoilet': 'rgb(148,0,211)',\n  'deeppink': 'rgb(255,20,147)',\n  'deepskyblue': 'rgb(0,191,255)',\n  'dimgray': 'rgb(105,105,105)',\n  'doderblue': 'rgb(30,144,255)',\n  'firebrick': 'rgb(178,34,34)',\n  'floralwhite': 'rgb(255,250,240)',\n  'forestgreen': 'rgb(34,139,34)',\n  'fuchsia': 'rgb(255,0,255)',\n  'gainsboro': 'rgb(220,220,220)',\n  'ghostwhite': 'rgb(248,248,255)',\n  'gold': 'rgb(255,215,0)',\n  'goldenrod': 'rgb(218,165,32)',\n  'gray': 'rgb(128,128,128)',\n  'green': 'rgb(0,128,0)',\n  'greenyellow': 'rgb(173,255,47)',\n  'honeydew': 'rgb(240,255,240)',\n  'hotpink': 'rgb(255,105,180)',\n  'indianred': 'rgb(205,92,92)',\n  'indigo': 'rgb(75,0,130)',\n  'ivory': 'rgb(255,255,240)',\n  'khaki': 'rgb(240,230,140)',\n  'lavender': 'rgb(230,230,250)',\n  'lavenderblush': 'rgb(255,240,245)',\n  'lawngreen': 'rgb(124,252,0)',\n  'lemonchiffon': 'rgb(255,250,205)',\n  'lightblue': 'rgb(173,216,230)',\n  'lightcoral': 'rgb(240,128,128)',\n  'lightcyan': 'rgb(225,255,255)',\n  'lightgoldenrodyellow': 'rgb(250,250,210)',\n  'lightgreen': 'rgb(144,238,144)',\n  'lightgrey': 'rgb(211,211,211)',\n  'lightpink': 'rgb(255,182,193)',\n  'lightsalmon': 'rgb(255,160,122)',\n  'lightseagreen': 'rgb(32,178,170)',\n  'lightskyblue': 'rgb(135,206,250)',\n  'lightslategray': 'rgb(119,136,153)',\n  'lightsteelblue': 'rgb(176,196,222)',\n  'lightyellow': 'rgb(255,255,224)',\n  'lime': 'rgb(0,255,0)',\n  'limegreen': 'rgb(50,205,50)',\n  'linen': 'rgb(250,240,230)',\n  'magenta': 'rgb(255,0,255)',\n  'maroon': 'rgb(128,0,0)',\n  'mediumaquamarine': 'rgb(0,250,154)',\n  'mediumblue': 'rgb(0,0,205)',\n  'mediumorchid': 'rgb(186,85,211)',\n  'mediumpurple': 'rgb(147,112,219)',\n  'mediumslateblue': 'rgb(123,104,238)',\n  'mediumspringgreen': 'rgb(245,255,250)',\n  'mediumturquoise': 'rgb(72,209,204)',\n  'mediumvioletred': 'rgb(199,21,133)',\n  'midnightblue': 'rgb(25,25,112)',\n  'mintcream': 'rgb(0,255,127)',\n  'mistyrose': 'rgb(255,228,225)',\n  'moccasin': 'rgb(255,228,181)',\n  'navajowhite': 'rgb(255,222,173)',\n  'navy': 'rgb(0,0,128)',\n  'oldlace': 'rgb(253,245,230)',\n  'olive': 'rgb(128,128,0)',\n  'olivedrab': 'rgb(85,107,47)',\n  'orange': 'rgb(255,165,0)',\n  'orangered': 'rgb(255,69,0)',\n  'orchid': 'rgb(218,112,214)',\n  'palegodenrod': 'rgb(238,232,170)',\n  'palegreen': 'rgb(152,251,152)',\n  'paleturquoise': 'rgb(175,238,238)',\n  'palevioletred': 'rgb(219,112,147)',\n  'papayawhip': 'rgb(255,239,213)',\n  'peachpuff': 'rgb(255,218,185)',\n  'peru': 'rgb(205,133,63)',\n  'pink': 'rgb(255,192,203)',\n  'plum': 'rgb(221,160,221)',\n  'powderblue': 'rgb(176,224,230)',\n  'purple': 'rgb(128,0,128)',\n  'red': 'rgb(255,0,0)',\n  'rosybrown': 'rgb(188,143,143)',\n  'royalblue': 'rgb(65,105,225)',\n  'saddlebrown': 'rgb(139,69,19)',\n  'salmon': 'rgb(250,128,114)',\n  'sandybrown': 'rgb(244,164,96)',\n  'seagreen': 'rgb(46,139,87)',\n  'seashell': 'rgb(255,245,238)',\n  'sienna': 'rgb(160,82,45)',\n  'silver': 'rgb(192,192,192)',\n  'skyblue': 'rgb(135,206,235)',\n  'slateblue': 'rgb(106,90,205)',\n  'slategray': 'rgb(112,128,144)',\n  'snow': 'rgb(255,250,250)',\n  'springgreen': 'rgb(60,179,113)',\n  'steelblue': 'rgb(70,130,180)',\n  'tan': 'rgb(210,180,140)',\n  'teal': 'rgb(0,128,128)',\n  'thistle': 'rgb(216,191,216)',\n  'tomato': 'rgb(255,99,71)',\n  'turquoise': 'rgb(64,224,208)',\n  'violet': 'rgb(238,130,238)',\n  'wheat': 'rgb(245,222,179)',\n  'white': 'rgb(255,255,255)',\n  'whitesmoke': 'rgb(245,245,245)',\n  'yellow': 'rgb(255,255,0)'\n}\nconst name2hexrgbMap = {\n  'aliceblue': '#f0f8ff',\n  'antiquewhite': '#faebd7',\n  'aqua': '#00ffff',\n  'auqamarin': '#7fffaa',\n  'azure': '#f0ffff',\n  'beige': '#6b8e23',\n  'bisque': '#ffe4c4',\n  'black': '#000000',\n  'blanchedalmond': '#ffebcd',\n  'blue': '#0000ff',\n  'blueviolet': '#8a2be2',\n  'brown': '#a52a2a',\n  'brulywood': '#deb887',\n  'cadetblue': '#5f9ea0',\n  'chartreuse': '#7fff00',\n  'chocolate': '#d2691e',\n  'coral': '#ff7f50',\n  'cornflowerblue': '#6495ed',\n  'cornislk': '#fff8dc',\n  'crimson': '#dc143c',\n  'cyan': '#00ffff',\n  'darkblue': '#00008b',\n  'darkcyan': '#008b8b',\n  'darkgray': '#a9a9a9',\n  'darkgreen': '#006400',\n  'darkkhaki': '#bdb76b',\n  'darkmagenta': '#8b008b',\n  'darkorange': '#ff8c00',\n  'darkorchid': '#9932cc',\n  'darkred': '#8b0000',\n  'darksalmon': '#e9967a',\n  'darkseagreen': '#8fbc8f',\n  'darkslateblue': '#483d8b',\n  'darkslategray': '#2f4f4f',\n  'darkturquoise': '#00ced1',\n  'darkvoilet': '#9400d3',\n  'deeppink': '#ff1493',\n  'deepskyblue': '#00bfff',\n  'dimgray': '#696969',\n  'doderblue': '#1e90ff',\n  'firebrick': '#b22222',\n  'floralwhite': '#fffaf0',\n  'forestgreen': '#228b22',\n  'fuchsia': '#ff00ff',\n  'gainsboro': '#dcdcdc',\n  'ghostwhite': '#f8f8ff',\n  'gold': '#ffd700',\n  'goldenrod': '#daa520',\n  'gray': '#808080',\n  'green': '#008000',\n  'greenyellow': '#adff2f',\n  'honeydew': '#f0fff0',\n  'hotpink': '#ff69b4',\n  'indianred': '#cd5c5c',\n  'indigo': '#4b0082',\n  'ivory': '#fffff0',\n  'khaki': '#f0e68c',\n  'lavender': '#e6e6fa',\n  'lavenderblush': '#fff0f5',\n  'lawngreen': '#7cfc00',\n  'lemonchiffon': '#fffacd',\n  'lightblue': '#add8e6',\n  'lightcoral': '#f08080',\n  'lightcyan': '#e1ffff',\n  'lightgoldenrodyellow': '#fafad2',\n  'lightgreen': '#90ee90',\n  'lightgrey': '#d3d3d3',\n  'lightpink': '#ffb6c1',\n  'lightsalmon': '#ffa07a',\n  'lightseagreen': '#20b2aa',\n  'lightskyblue': '#87cefa',\n  'lightslategray': '#778899',\n  'lightsteelblue': '#b0c4de',\n  'lightyellow': '#ffffe0',\n  'lime': '#00ff00',\n  'limegreen': '#32cd32',\n  'linen': '#faf0e6',\n  'magenta': '#ff00ff',\n  'maroon': '#800000',\n  'mediumaquamarine': '#00fa9a',\n  'mediumblue': '#0000cd',\n  'mediumorchid': '#ba55d3',\n  'mediumpurple': '#9370db',\n  'mediumslateblue': '#7b68ee',\n  'mediumspringgreen': '#f5fffa',\n  'mediumturquoise': '#48d1cc',\n  'mediumvioletred': '#c71585',\n  'midnightblue': '#191970',\n  'mintcream': '#00ff7f',\n  'mistyrose': '#ffe4e1',\n  'moccasin': '#ffe4b5',\n  'navajowhite': '#ffdead',\n  'navy': '#000080',\n  'oldlace': '#fdf5e6',\n  'olive': '#808000',\n  'olivedrab': '#556b2f',\n  'orange': '#ffa500',\n  'orangered': '#ff4500',\n  'orchid': '#da70d6',\n  'palegodenrod': '#eee8aa',\n  'palegreen': '#98fb98',\n  'paleturquoise': '#afeeee',\n  'palevioletred': '#db7093',\n  'papayawhip': '#ffefd5',\n  'peachpuff': '#ffdab9',\n  'peru': '#cd853f',\n  'pink': '#ffc0cb',\n  'plum': '#dda0dd',\n  'powderblue': '#b0e0e6',\n  'purple': '#800080',\n  'red': '#ff0000',\n  'rosybrown': '#bc8f8f',\n  'royalblue': '#4169e1',\n  'saddlebrown': '#8b4513',\n  'salmon': '#fa8072',\n  'sandybrown': '#f4a460',\n  'seagreen': '#2e8b57',\n  'seashell': '#fff5ee',\n  'sienna': '#a0522d',\n  'silver': '#c0c0c0',\n  'skyblue': '#87ceeb',\n  'slateblue': '#6a5acd',\n  'slategray': '#708090',\n  'snow': '#fffafa',\n  'springgreen': '#3cb371',\n  'steelblue': '#4682b4',\n  'tan': '#d2b48c',\n  'teal': '#008080',\n  'thistle': '#d8bfd8',\n  'tomato': '#ff6347',\n  'turquoise': '#40e0d0',\n  'violet': '#ee82ee',\n  'wheat': '#f5deb3',\n  'white': '#ffffff',\n  'whitesmoke': '#f5f5f5',\n  'yellow': '#ffff00'\n}\n\nconst rgbReg = /\\s*rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*/\nconst rgbaReg = /\\s*rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*/\nconst hexReg = /\\s*#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\\s*/\n\nexport function getRgbColor(colorString) {\n  if (rgbReg.test(colorString) || rgbaReg.test(colorString)) {\n    return colorString.replace(/\\s*/g, '')\n  }\n  if (hexReg.test(colorString)) {\n    let hex = colorString.replace(/\\s*/g, '')\n    if (hex.length === 4) {\n      hex = hex.replace(/#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])/g, '#$1$1$2$2$3$3')\n    }\n    hex = hex.replace('#', '0x')\n    return `rgb(${[(hex & 0xff0000) >> 16, (hex & 0xff00) >> 8, hex & 0xff].join(',')})`\n  }\n  const color = name2rgbMap[colorString.toLowerCase()]\n  if (color) {\n    return color\n  }\n  return null\n}\n\nexport function getHexColor(colorString) {\n  if (hexReg.test(colorString)) {\n    return colorString.replace(/\\s*/g, '')\n  }\n  if (rgbReg.test(colorString) || rgbaReg.test(colorString)) {\n    colorString = colorString.replace(/\\s*/g, '')\n    let color = colorString.match(rgbReg) || colorString.match(rgbaReg)\n    // color[0] is the whole string, [1, 2, 3] is the rgb\n    let r = parseInt(color[1]) & 0xff\n    let g = parseInt(color[2]) & 0xff\n    let b = parseInt(color[3]) & 0xff\n    const format = (num) => {\n      const str = num.toString(16)\n      return str.length === 1 ? `0${str}` : str\n    }\n    return `#${[r, g, b].map(format).join('')}`\n  }\n  const color = name2hexrgbMap[colorString.toLowerCase()]\n  if (color) {\n    return getHexColor(color)\n  }\n  return null\n}\n\nexport default {\n  getRgbColor,\n  getHexColor\n}\n\n\n"
  },
  {
    "title": "vue自定义密码输入框解决浏览器自动填充密码的问题",
    "url": "/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/2023/04/15/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E5%AF%86%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98.html",
    "date": "2023-04-15 08:51:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17320432.html\n现在转移到 github pages 上。\n\n问题描述\n浏览器对于type=\"password\"的输入框会自动填充密码，但有时出于安全或者其他原因，我们不希望浏览器记住并自动填充密码。通过网上查到的一些解决方案，可以总结出以下几种解决方案(主要用edge浏览器进行测试)：\n\n  通过autocomplete=\"off\"/autocomplete=\"new-password\"来关闭浏览器自动填充密码的功能, 但某些对于浏览器像edge,firfox等，这种方法并不起作用\n  通过type=\"text\"来解决，当focus时，通过js将type=\"text\"改为type=\"password\"。\n    <input type=\"text\" onfocus=\"this.type='password'\">\n    \n    但同样对某些浏览器不起作用，如edge，在点击输入框时，仍会自动弹出填充密码的提示框。\n  \n  某些浏览器可能只会识别第一个type=\"password\"的输入框，所以可以在前面添加一些隐藏的type=\"password\"的输入框，来解决这个问题。\n```html\n\n\n  \n\n\n\n但同样并不是总是有效，拿edge测试时即使前几个密码输入框没有隐藏，最后一个输入框也会自动填充密码,如图:\n![](/post_assets/images/2023/04/15-password-auto-complete.png)\n\n4. 通过`readonly`属性来解决，初始化时将`readonly`设置为`true`，通过`setTimeout`来延时设置`readonly`为`false`。\n```html\n<input id=\"passwordInput\" type=\"password\" readonly>\n\nsetTimeout(() => {\n    document.getElementById('passwordInput').removeAttribute('readonly')\n}, 100)\n\n但同样并非总是有效，拿edge测试时，虽然点击输入框时并没有弹出填充密码的提示框，但是在输入框中输入密码然后退格到输入框为空时，又会重新弹出填充密码的提示框。\n\n上述几种方法除了会弹出填充密码的提示框外，在页面跳转或刷新时(如edge浏览器)，都会弹出保存密码的提示框，如图:\n\n\n当然，应该还会有其他解决方案我暂时还没找到，如果有的话，欢迎留言。\n\n自定义密码输入框组件解决方案\n在尝试了上述几种解决方案后，发现效果都不是很好，所以我感觉只有让input的type属性始终为password，才能更有效的解决这个问题。可以考虑自定义一个密码输入框组件，通过某些方法去改变input的值的显示方式，来达到隐藏密码的效果。\n目前想出了两种方法：一个是不改变input的值，仅仅隐藏input的内容，用另一个容器去显示密码或者显示*；另一个是将实际密码存在另一个变量中，将input的value值改成*来显示。\n\n方案一\n可以用两个input来实现，父容器是relative定位，两个input都是absolute，一个实际的输入框位于上层，设置为透明，另一个用于显示星号的输入框位于下层。\n<div class=\"container\">\n  <input v-model=\"passwordDisplay\">\n  <input\n    v-model=\"password\"\n    class=\"password\"\n    @input=\"passwordDisplay = password.replace(/./g, '*')\">\n</div>\n\n<style scoped>\n.container {\n  position: relative;\n}\n.container input {\n  position: absolute;\n  left: 0;\n  top: 0;\n  font-size: 12px;\n}\n.password {\n  opacity: 0;\n}\n</style>\n\n效果如下图所示：\n\n\n\n确实没有弹出密码填充的对话框，但样式上并不是很满意。因为实际的输入框被设置成了透明，且在密码显示框之上，所以光标无法显示出来，且无法进行选中一部分内容。\n\n方案二\n跟方案一差不多的方式，用input来接收用户输入的密码，但仅改变输入内容的透明度, 由于在opacity为0的情况下设置光标颜色无效，所以要将方案一中的opacity: 0改为:\n.password {\n  color: transparent;\n  background-color: transparent;\n  caret-color: #000; /* 光标颜色 */\n}\n\n但是这会有个问题，选中一部分内容时，会导致透明的内容选中后显现出来，如图所示：\n\n\n这种情况下可以考虑监听选中事件，当选中一部分内容时，将后面的星号也选中，同时通过::selection伪类来设置选中的内容的背景色，让两个选中的内容颜色一致。要实现这种效果，input显然做不到修改部分内容的背景色，所以可以考虑用span代替input，向其innerHTML中插入带背景色的span：\n<div class=\"container\">\n  <span\n    ref=\"passwordInputDisplay\"\n    class=\"password password-input__behind\"\n  />\n  <input\n    v-model=\"password\"\n    class=\"password password-input__front\"\n    @focus=\"isActive = true\"\n    @blur=\"isActive = false\"\n    @input=\"passwordDisplay = password.replace(/./g, '*')\">\n</div>\n<style scoped>\n::selection {\n  background-color: #409eff;\n}\n.container {\n  position: relative;\n}\n.password {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  font-size: 12px;\n  font-family: monospace; /* 必须用等宽字体 */\n}\n.password-input__behind {\n  text-align: left;\n  z-index: 1;\n}\n.password-input__front {\n  color: transparent;\n  background-color: transparent;\n  caret-color: #000;\n  z-index: 2;\n}\n\nexport default {\n  props: {\n    value: {\n      type: String,\n      default: ''\n    }\n  },\n  methods: {\n    handleInput (e) {\n      // 删除非法字符(只保留code>=32且code<=126的字符)\n      const value = e.target.value\n      const newValue = value.replace(/[^\\x20-\\x7E]/g, '')\n      if (newValue !== value) {\n        this.password = newValue\n      }\n      // 发布input事件，从而修改props中的value值\n      this.$emit('input', this.password)\n    }\n\n  },\n  created() {\n    this.selectionEvent = () => {\n      const display = this.$refs.passwordInputDisplay\n      display.style.zIndex = 1\n      display.innerHTML = this.passwordDisplay\n      if (!this.isActive) { return }\n      const selection = window.getSelection()\n      // 如果选中的内容不为空, 则由passwordInputDisplay显示\n      if (!selection.toString()) { return }\n      const input = this.$refs.passwordInput\n      const start = input.selectionStart\n      const end = input.selectionEnd\n      const highlightString = '<span style=\"background-color: #409eff; color: #fff;\">' + this.passwordDisplay.slice(start, end) + '</span>'\n      display.innerHTML = this.passwordDisplay.slice(0, start) + highlightString + this.passwordDisplay.slice(end)\n      display.style.zIndex = 4\n    }\n    document.addEventListener('selectionchange', this.selectionEvent)\n  },\n  beforeDestory() {\n    document.removeEventListener('selectionchange', this.selectionEvent)\n  }\n}\n\n需要注意以下几点：\n\n  监听select事件不能用input自带的onselect或@select，因为这只会在鼠标松开时触发，并不能实时相应选取区域的变化。所以要监听selectionchange事件。注意selectionchange事件在没选中内容时也会触发。\n  由于相比方案一显示了光标，光标的位置会受到实际字符宽度的影响，所以要使星号与其他字符宽度相等，必须使用如monospace之类的等宽字体，且必须阻止中文字符的输入。\n  修改innerHtml后需要改变密码显示框的z-index，否则仍然会被input中选中的内容覆盖。\n\n\n效果如下图所示：\n\n\n\n这里还有个问题，当输入内容超过了input的长度，显示上就会出现错误，可以考虑根据字体宽度计算出最大容纳的字符个数，阻止过多字符的输入。也可以在光标移动时同时移动后面的span，不过逻辑太过复杂没必要。\nconst width = this.$refs.passwordInput.clientWidth - 20 // 20为padding\nconst canvas = document.createElement('canvas')\nconst ctx = canvas.getContext('2d')\nctx.font = '16px monospace'\nconst fontWidth = ctx.measureText('A').width\nthis.maxLength = Math.floor(width / fontWidth)\n\n这里用的是canvas进行计算字体宽度。\n\n虽然最终实现了目标效果，不过逻辑上还是稍微复杂了点。\n\n完整代码在: https://github.com/lxmghct/my-vue-components的 src/components/PasswordInput/PasswordInput1.vue\n\n方案三\n只使用一个input，另外设置一个变量去保存真实密码。这种方法比上述方法逻辑上要稍微简单一些，唯一需要注意的就是当输入框中显示为星号时，如何区分哪些是新输入的内容，因为会有鼠标选中一段内容再删除或输入、粘贴的操作，而新输入的内容中也可能包含星号，所以不能处理的过于简单。最后采用的是监听selectionchange事件来随时更新光标所在位置，从而区分新输入的内容。\n\n<input\n  ref=\"passwordInput\"\n  v-model=\"passwordDisplay\"\n  autocomplete=\"off\"\n  @focus=\"isActive = true\"\n  @blur=\"isActive = false\"\n  @input=\"handleInput\"\n>\n\nexport default {\n  methods: {\n    handleInput () {\n      // 获取新输入的字符\n      const tempEnd = this.passwordDisplaylength - (this.password.length - thisselection.end)\n      const newStr = this.passwordDisplay.slic(this.selection.start, tempEnd)\n      // 更新输入框的值\n      const currentPosition = this.$refspasswordInput.selectionStart\n      this.password = this.password.slice(0,Math.min(this.selection.start,currentPosition)) + newStr + this.passwordslice(this.selection.end)\n      this.selection.start = currentPosition\n      this.selection.end = currentPosition\n      this.$emit('input', this.password)\n    }\n  },\n  created () {\n    this.selectionEvent = () => {\n      if (!this.isActive) { return }\n      const input = this.$refs.passwordInput\n      this.selection = {\n        start: input.selectionStart,\n        end: input.selectionEnd\n      }\n    }\n    this.copyEvent = (e) => {\n      if (!this.isActive) { return }\n      const clipboardData = e.clipboardData || window.clipboardData\n      clipboardData.setData('text', this.password.slice(this.selection.start, this.selection.end))\n      e.preventDefault()\n    }\n    document.addEventListener('selectionchange', this.selectionEvent)\n    document.addEventListener('copy', this.copyEvent)\n  },\n  beforeDestroy () {\n    document.removeEventListener('selectionchange', this.selectionEvent)\n    document.removeEventListener('copy', this.copyEvent)\n  }\n}\n\n有几点需要注意：\n\n  输入框中选定的内容的起始和结束位置无法通过window.getSelection().anchorOffset等参数获取(window.getSelection()的几个offset都是0), 只能通过input的selectionStart和selectionEnd可以拿到当前选中区域的起始和结束位置。\n  由于输入框内实际显示的是星号，所以复制时若不处理则复制的也是星号，所以需要监听复制事件，将实际密码写入剪贴板。剪贴板通过e.clipboardData || window.clipboardData获取。\n\n\n相比于方案二，这种方法无需要求一定要等宽字体，也无需另外去处理选中内容的事件，唯一多出的地方就是对输入框实际值的处理，包括输入和复制，而这里的逻辑显然比方案二中修改样式容易的多。\n\n效果上跟方案二基本差不多，而且没有长度限制，这里用this.passwordDisplay = '\\u2022'.repeat(this.value.length)把星号改成了圆点，如下：\n\n\n完整代码在: https://github.com/lxmghct/my-vue-components的 src/components/PasswordInput/PasswordInput2.vue\n\n密码显示与隐藏\n点击眼睛图标，切换密码的显示与隐藏状态。\nexport default {\n  watch: {\n    value () {\n      this.updatePasswordDisplay()\n    },\n    showPassword () {\n      this.updatePasswordDisplay()\n    }\n  },\n  methods: {\n    updatePasswordDisplay () {\n      if (this.showPassword) {\n        this.passwordDisplay = this.value\n      } else {\n        // this.passwordDisplay = '*'.repeat(this.value.length)\n        this.passwordDisplay = '\\u2022'.repeat(this.value.length) // 圆点\n      }\n    }\n  }\n}\n\n眼睛图标可以用图标库或者导入图片，我这里用的是svg，眼睛图标的svg可以通过一些转换工具来实现，这里推荐一个网站: https://picsvg.com/\n<div class=\"password-input__eye-wrap\">\n  <div\n      class=\"password-input__eye\"\n      @click=\"showPassword = !showPassword\"\n  >\n      <svg version=\"1.0\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"58.000000pt\" height=\"50.000000pt\" viewBox=\"0 0 58.000000 50.000000\"\n      preserveAspectRatio=\"xMidYMid meet\">\n          <g transform=\"translate(0.000000,50.000000) scale(0.100000,-0.100000)\"\n          fill=\"#000000\" stroke=\"none\">\n              <path d=\"M228 390 c-61 -19 -148 -96 -148 -130 0 -21 61 -87 103 -110 50 -29\n              127 -32 173 -8 39 21 114 98 114 118 0 19 -74 97 -111 115 -36 19 -98 26 -131\n              15z m121 -40 c37 -18 91 -72 91 -90 0 -18 -54 -72 -91 -90 -70 -36 -138 -22\n              -206 43 -18 17 -33 38 -33 47 0 19 53 71 95 93 41 22 98 21 144 -3z\"/>\n              <path d=\"M235 338 c-31 -18 -44 -40 -45 -75 0 -45 9 -62 42 -79 84 -43 168 60\n              106 130 -27 30 -74 41 -103 24z m79 -34 c20 -20 20 -68 0 -88 -35 -35 -104 -6\n              -104 44 0 50 69 79 104 44z\"/>\n          </g>\n      </svg>\n  </div>\n</div>\n<style scoped>\n.password-input__eye-wrap {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n.password-input__eye {\n    width: 20px;\n    height: 20px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n}\n</style>\n\n效果如下：\n\n\n完整代码在: https://github.com/lxmghct/my-vue-components的 src/components/PasswordInput/PasswordInput2.vue\n\n总结\n通过将密码输入框的type设置为text，修改样式上的显示，来实现既可以让浏览器不自动填充密码，又可以隐藏密码的效果。\n\n"
  },
  {
    "title": "非el组件、自定义组件触发el-form的校验",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/04/14/%E9%9D%9Eel%E7%BB%84%E4%BB%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E8%A7%A6%E5%8F%91el-form%E7%9A%84%E6%A0%A1%E9%AA%8C.html",
    "date": "2023-04-14 21:10:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17320426.html\n现在转移到 github pages 上。\n\n参考文档：https://zhuanlan.zhihu.com/p/390466860\n\n问题描述\n非el组件像原生的input、自定义组件等，无法触发el-form的rules校验，如下面的代码：\n<el-form ref=\"passwordForm\"\n         :model=\"passwordForm\"\n         :rules=\"rules\">\n  <el-form-item label=\"密码\"\n                prop=\"oldPassword\">\n    <el-input type=\"password\" auto-complete=\"off\"\n              v-model=\"passwordForm.oldPassword\" />\n  </el-form-item>\n  <el-form-item label=\"新密码\"\n                prop=\"newPassword\">\n    <password-input v-model=\"passwordForm.newPassword\" />\n  </el-form-item>\n  <el-form-item label=\"确认新密码\"\n                prop=\"newPasswordCheck\">\n    <password-input v-model=\"passwordForm.passwordCheck\" />\n  </el-form-item>\n</el-form>\n\nexport default {\n  data() {\n    var validatePasswordCheck = (rule, value, callback) => {\n      if (value !== this.passwordForm.newPassword) {\n        callback(new Error('两次输入密码不一致!'))\n      } else {\n        callback()\n      }\n    }\n    return {\n      passwordForm: {\n        oldPassword: '',\n        newPassword: '',\n        newPasswordCheck: ''\n      },\n      rules: {\n        oldPassword: [\n          { required: true, message: '请输入密码', trigger: 'blur' }\n        ],\n        newPassword: [\n          { required: true, message: '请输入新密码', trigger: 'blur' }\n        ],\n        newPasswordCheck: [\n          { required: true, message: '请再次输入新密码', trigger: 'blur' },\n          { validator: this.validatePasswordCheck, trigger: 'blur' }\n        ]\n      }\n    }\n  }\n}\n\n第一个el-form-item的el-input组件可以触发校验，但是第二个和第三个el-form-item的password-input是自定义组件，无法触发校验。\n\n源码分析\n源码地址: https://github.com/ElemeFE/element\n在packages/form/src/form-item.vue中，可以找到addValidateEvents方法，该方法是用来给el-form-item的子组件绑定校验事件的，如下：\naddValidateEvents() {\n  const rules = this.getRules();\n  if (rules.length || this.required !== undefined) {\n    this.$on('el.form.blur', this.onFieldBlur);\n    this.$on('el.form.change', this.onFieldChange);\n  }\n}\n\n在packages/input/src/input.vue中，可以找到el-input发送el.form.blur和el.form.change事件的代码，这里只贴出el.form.change的代码：\nwatch: {\n  value(val) {\n    this.$nextTick(this.resizeTextarea);\n    if (this.validateEvent) {\n      this.dispatch('ElFormItem', 'el.form.change', [val]);\n    }\n  }\n}\n\n这里用了dispatch方法，该方法的代码在src/mixins/emitter.js中：\ndispatch(componentName, eventName, params) {\n  var parent = this.$parent || this.$root;\n  var name = parent.$options.componentName;\n  while (parent && (!name || name !== componentName)) {\n    parent = parent.$parent;\n    if (parent) {\n      name = parent.$options.componentName;\n    }\n  }\n  if (parent) {\n    parent.$emit.apply(parent, [eventName].concat(params));\n  }\n}\n\n由此可以看出，要触发el-form的校验，需要el-form-item中的子组件去发布el.form.change或el.form.blur等事件，由el-form-item监听该事件，触发表单校验。\n\n解决方案\n\n  方法一：在父页面中直接调用表单的校验方法validateField:\n    watch: {\n  'passwordForm.newPassword': function() {\n this.$refs.passwordForm.validateField('newPassword')\n  }\n}\n    \n  \n  方法二：在父页面中发布组件的el.form.change等事件：\n```html\n<input ref=”input” @blur=”handleBlur”>\n\nexport default {\n  methods: {\n handleBlur (val) {\n   this.$refs.input.$emit('el.form.blur', val)\n }\n  }\n\n\n}\n</script>\n3. 方法三：在子组件中发布`el.form.change`等事件，此时无需在父页面中做任何处理，其中`dispatch`方法直接将上面所说的`emitter.js`中的代码拷贝过来即可：\n```js\nexport default {\n  methods: {\n    dispatch(componentName, eventName, params) {\n      // ... 从emitter.js中拷贝过来的代码\n    },\n    handleInput (e) {\n      this.$emit('input', e.target.value)\n      this.dispatch('ElFormItem', 'el.form.change', [e.target.value])\n    }\n  }\n}\n\n得到的效果如下图所示：\n\n不过输入框的颜色没变成红色，查看el-input的样式可以看到其错误时的颜色是通过.el-form-item.is-error .el-input__inner选择器来控制的：\n.el-form-item.is-error .el-input__inner, .el-form-item.is-error .el-input__inner:focus, .el-form-item.is-error .el-textarea__inner, .el-form-item.is-error .el-textarea__inner:focus, .el-message-box__input input.invalid, .el-message-box__input input.invalid:focus {\n    border-color: #F56C6C;\n}\n\n类似的，可以给自定义组件也加上el-input__inner类名，便能实现错误时的样式了。\n效果如下图所示：\n\n"
  },
  {
    "title": "vue自定义组件 ip-input",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/04/13/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6ip-input.html",
    "date": "2023-04-13 18:50:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17317111.html\n现在转移到 github pages 上。\n\ngithub地址: https://github.com/lxmghct/my-vue-components\n\n组件介绍\n\n  props:\n    \n      value: 输入的ip地址, 类型为字符串, 格式为xx.xx.xx.xx, default: ‘’\n      disabled: 是否禁用, 类型为布尔值, default: false\n    \n  \n  events:\n    \n      @input: 输入时触发, 参数为输入的ip地址\n      @change: ip地址改变时触发, 参数1为newIp, 参数2为oldIp\n    \n  \n\n\n效果展示\n\n\n设计思路\n组件设计上比较简单，四个输入框，每个输入框只能输入0-255的数字，输入满3位后自动跳转到下一个输入框，退格Backspace则可以删除内容并跳转到上一个输入框，左右方向键也可以进行切换输入框，这些都只需调用目标输入框的focus()方法即可。\n<div class=\"ip-input\">\n  <!-- 每一段一个输入框 -->\n  <div v-for=\"(item, index) in ipArr\" :key=\"index\" class=\"ip-input__item-wrap\">\n    <input\n      ref=\"ipInput\"\n      v-model=\"ipArr[index]\"\n      type=\"text\"\n      class=\"ip-input__item\"\n      :class=\"{\n        'ip-input__item--active': index === activeIndex,\n      }\"\n      :disabled=\"disabled\"\n      @input=\"handleInput(index)\"\n      @focus=\"handleFocus(index)\"\n      @blur=\"handleBlur(index)\"\n      @keydown.left.exact=\"handleFocus(index - 1)\"\n      @keydown.right.exact=\"handleFocus(index + 1)\"\n      @keydown.backspace.exact=\"handleBackspace(index)\"\n    >\n    <span v-if=\"index !== ipArr.length - 1\" class=\"ip-input__dot\">.</span>\n  </div>\n</div>\n\nhandleInput(index) {\n  const newValue = this.ipArr[index]\n  // 如果输入的是非数字，或者输入不在0-255之间，则阻止输入\n  if (!this.isNumberValid(newValue)) {\n    this.ipArr[index] = this.oldIpInput[index]\n    return false\n  }\n  this.$emit('input', this.ipArr.join('.'))\n  this.oldIpInput[index] = newValue\n  if (newValue.length === 3 || (newValue.length === 2 && newValue > 25)) {\n    if (index === this.ipArr.length - 1) { return true }\n    // 将焦点移动到下一个输入框\n    this.handleFocus(index + 1)\n  }\n  return true\n},\nhandleFocus(index) {\n  if (index < 0 || index > this.ipArr.length - 1) { return }\n  if (this.activeIndex !== index) {\n    this.$refs.ipInput[index].focus()\n  }\n  this.activeIndex = index\n}\n\n此外，还加入了复制和粘贴ip的功能，粘贴时会自动将ip地址分割并填入到对应的输入框中，复制时会将完整的ip地址复制到剪贴板中。这可以通过监听copy和paste事件来实现，通过event.clipboardData来获取剪贴板中的数据。\nthis.pasteListener = (event)=> {\n  if (this.activeIndex === -1) { return }\n  const clipboardData = event.clipboardData || window.clipboardData\n  this.clipboardText = clipboardData.getData('text')\n  this.handlePaste(this.activeIndex)\n}\nthis.copyListener = (event) =>{\n  if (this.activeIndex === -1) { return }\n  const clipboardData = event.clipboardData || window.clipboardData\n  clipboardData.setData('text', this.ipArr.join('.'))\n  event.preventDefault()\n}\nwindow.addEventListene('paste', this.pasteListener)\nwindow.addEventListene('copy', this.copyListener)\n\n完整代码可以前往文章开头的github地址查看。\n"
  },
  {
    "title": "vue自定义组件 split-pane",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/04/13/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6split-pane.html",
    "date": "2023-04-13 17:50:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17317101.html\n现在转移到 github pages 上。\n\ngithub地址: https://github.com/lxmghct/my-vue-components\n\n组件介绍\n\n  props:\n    \n      splitCount: 分割数量, default: 2\n      direction: 分割方向, ‘vertical’ or ‘horizontal’, default: ‘horizontal’\n      defaultRatio: 默认比例, 类型为数组, default: [1/spiltCount, 1/spiltCount, …]\n    \n  \n  slots:\n    \n      \n        ...\n      \n      \n        ...\n      \n      …\n    \n  \n  events:\n    \n      @resize: 拖动分割条时触发, 参数为分割线两侧的div\n      @resize-stop: 拖动分割条结束时触发\n    \n  \n  methods:\n    \n      changeItemSize(index, itemSize, dire=’next’) 改变第item个pane的大小, dire为next或prev, 表示修改当前pane时连带修改前一个pane还是后一个\n    \n  \n\n\n效果展示\n\n\n设计思路\n整个组件采用flex布局，通过设置整体的flex-direction控制分割方向，通过修改每个pane的style.flex控制每个pane的大小。\n<div class=\"split-main\" ref=\"splitMain\"\n     :class=\"direction === 'vertical' ? 'split-vertical' : 'split-horizontal'\">\n  <template v-if=\"direction === 'vertical'\">\n    <div v-for=\"i in splitCount\" :key=\"i\" ref=\"splitItem\"\n         class=\"split-vertical-item\">\n      <div class=\"split-vertical-line\" v-if=\"i < splitCount\"\n           @mousedown=\"_startDrag(i)\"\n           @touchstart=\"_startDrag(i)\"></div>\n      <div class=\"split-vertical-content\">\n        <slot :name=\"`pane${i}`\"></slot>\n      </div>\n    </div>\n  </template>\n  <template v-else>\n    <div v-for=\"i in splitCount\" :key=\"i\" ref=\"splitItem\"\n         class=\"split-horizontal-item\">\n      <div class=\"split-horizontal-line\" v-if=\"i < splitCount\"\n           @mousedown=\"_startDrag(i)\"\n           @touchstart=\"_startDrag(i)\"></div>\n      <div class=\"split-horizontal-content\">\n        <slot :name=\"`pane${i}`\"></slot>\n      </div>\n    </div>\n  </template>\n</div>\n\n通过v-for循环生成分割数量的pane，每个pane中间插入分割线，分割线通过@mousedown和@touchstart事件绑定_startDrag方法，该方法用于监听鼠标或手指的移动事件，从而实现拖动分割线改变pane大小的功能。\n_startDrag (index) {\n  this.dragIndex = index - 1\n},\n_onMouseMove (e) {\n  if (this.dragIndex === -1) {\n    return\n  }\n  let items = this.$refs.splitItem\n  let item1 = items[this.dragIndex]\n  let item2 = items[this.dragIndex + 1]\n  let rect1 = item1.getBoundingClientRect()\n  let rect2 = item2.getBoundingClientRect()\n  let ratio1, ratio2\n  let minLen = this.minLen\n  if (this.direction === 'vertical') {\n    let height = this.$refs.splitMain.clientHeight\n    let tempY = e.clientY - rect1.top > minLen ? e.clientY : rect1.top + minLen\n    tempY = rect2.bottom - tempY > minLen ? tempY : rect2.bottom - minLen\n    ratio1 = (tempY - rect1.top) / height\n    ratio2 = (rect2.bottom - tempY) / height\n  } else {\n    let width = this.$refs.splitMain.clientWidth\n    let tempX = e.clientX - rect1.left > minLen ? e.clientX : rect1.left + minLen\n    tempX = rect2.right - tempX > minLen ? tempX : rect2.right - minLen\n    ratio1 = (tempX - rect1.left) / width\n    ratio2 = (rect2.right - tempX) / width\n  }\n  item1.style.flex = ratio1\n  item2.style.flex = ratio2\n  e.preventDefault()\n  this.$emit('resize', item1, item2)\n},\n_onMouseUp () {\n  if (this.dragIndex === -1) {\n    return\n  }\n  this.dragIndex = -1\n  this.$emit('resize-stop')\n}\n\n完整代码在github上。https://github.com/lxmghct/my-vue-components\n"
  },
  {
    "title": "v-if与v-show造成部分元素丢失的问题——v-if复用元素问题",
    "url": "/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/2023/04/12/v-if%E4%B8%8Ev-show%E9%80%A0%E6%88%90%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98-v-if%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98.html",
    "date": "2023-04-12 19:50:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17312047.html\n现在转移到 github pages 上。\n\n问题描述\n在写tab切换时遇到了一个问题，以下为简化后的问题所在的代码：\n<img v-if=\"tabIndex === 2\" id=\"t1\">\n<div v-if=\"tabIndex === 2\" id=\"t2\"></div>\n<div v-if=\"tabIndex === 2\" id=\"t3\"></div>\n<div v-show=\"tabIndex === 2\" id=\"t4\">\n    <div id=\"content\"></div>\n</div>\n\n当页面加载时，先向id为content的div中添加了一些元素：\nfunction addContent() {\n    const newDiv = document.createElement('div');\n    newDiv.innerHTML = '123456789';\n    document.getElementById('content').appendChild(newDiv);\n}\n\n\n  如果当tabIndex为2时执行addContent()，上述123456789能够正常显示；\n  但如果:\n    \n      在此时将tabIndex改为1，再将tabIndex改为2，\n      或者在tabIndex不为2时执行addContent()，再将tabIndex改为2，\n  这两种情况下，123456789都无法正常显示。\n    \n  \n\n\n问题探索\n首先尝试将目标元素输出到控制台。在切换tabIndex前，先获取原来的元素：\nvar oldT4 = document.getElementById('t4');\nvar oldContent = document.getElementById('content');\n\n此时输出显然能得到正确的结果。\n然后在切换tabIndex后，再获取新的元素：\nvar newT4 = document.getElementById('t4');\nvar newContent = document.getElementById('content');\nconsole.log(oldT4, newT4);\nconsole.log(oldContent, newContent);\n\n此时会发现：\n\n  oldContent元素虽然能正常输出，但在页面上已经不存在了，此时oldContent仅仅是引用了一个不存在的元素；\n  newContent元素就是当前页面上的content元素，但其中的内容已被清空。\n  newT4元素就是当前页面上的t4元素。\n  oldT4却离奇的变为了t2元素，console.log(oldT4 === document.getElementById('t2'))的结果为true。\n\n\n\n问题原因\n这是因为t4在tabIndex切换时，复用了被v-if隐藏的t2元素，复用时会重新渲染t4内的所有内容，这种情况下，动态添加到content元素中的内容就会被清空。\n这里复用的顺序则是从第一个同样为div的被v-if隐藏的元素开始复用，即t2元素。类似的，如果此时进一步将t2元素的v-if修改成v-show，则oldT4就会去复用t3元素。\n\n解决方案\n要保留content元素中的内容，可以考虑：\n\n  将t2、t3的v-if改成v-show。\n  如果确实不方便修改v-if，则可以给t2、t3添加key属性，使其不会被复用。\n\n"
  },
  {
    "title": "不引入外部包、使用原生js发送请求的几种方式",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/04/08/%E4%B8%8D%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E5%8C%85-%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html",
    "date": "2023-04-08 18:30:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17299746.html\n现在转移到 github pages 上。\n\n参考文档：https://www.freecodecamp.org/chinese/news/the-most-popular-ways-to-make-an-http-request-in-javascript/\n\n1.form表单提交\n<form action=\"http://www.baidu.com\" method=\"post\">\n    <input type=\"text\" name=\"name\" value=\"123\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n\n只能单向提交，不能接收返回值。\n2. XMLHttpRequest\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', url, true);\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // 设置请求头\nxhr.send(JSON.stringify({name: '123'})); // 发送请求,body。如果后端不接受body类型的请求，则直接将参数放在url中，这里只需写成xhr.send()即可\nxhr.onreadystatechange = function () {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n        console.log(xhr.responseText);\n    }\n}\n\n注意setRequestHeader必须在open之后，send之前设置，如果放在open之前则会报以下错：\nUncaught DOMException: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n\n\n3. fetch\nfetch需要es6的支持，nodejs需要v17.5.0以上版本\nfetch(url, {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    body: JSON.stringify({name: '123'})\n}).then(res => res.text()).then(res => console.log(res));\n\n\n"
  },
  {
    "title": "Mariadb中同时使用with和insert values",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/04/07/Mariadb%E4%B8%AD%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8with%E5%92%8Cinsert-values.html",
    "date": "2023-04-07 18:30:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17297828.html\n现在转移到 github pages 上。\n\n不能将with放在insert之前，否则会报以下错误：\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'insert into table_name (id, name, ...) values ...' at line xxx\n\n正确做法是将with放在values之前：\n  insert into test (name, type)\n  with temp as (select type from test1 where id = 1)\n  values\n     ('name1', (select type from temp)),\n     ('name2', (select type from temp))\n\n"
  },
  {
    "title": "泰拉瑞亚EasyBuildMod便捷建造模组开发",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/03/25/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9AEasyBuildMod%E4%BE%BF%E6%8D%B7%E5%BB%BA%E9%80%A0%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91.html",
    "date": "2023-03-25 08:10:00 +0000",
    "content": "\n    img {\n        margin: 3px auto;\n    }\n\n\ngithub地址：\nhttps://github.com/lxmghct/Terraria-EasyBuildMod\n如果觉得有帮助，记得在github上点个star哦~\n\n本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17255401.html\n现在转移到 github pages 上。\n\n创意工坊搜索EasyBuildMod即可找到模组\n目录\n\n  简介\n  模组物品制作\n    \n      物品拾取磁铁\n      物块放置与摧毁助手基类\n        \n          Item实现\n          菜单实现\n          物块选择框实现\n        \n      \n      物块放置助手\n      物块摧毁助手\n    \n  \n  多人模式下的相关修改\n  开发过程中的其他问题\n\n\n1.简介\nEasyBuildMod是一个便捷建造模组，它包含了三个物品：物块放置助手可以快速将物块或墙壁放置在一个矩形区域、物块摧毁助手可以快速摧毁矩形区域内的物块或墙壁、物品拾取磁铁则可用于快速拾取摧毁后掉落的物品。\n制作这个模组主要是因为自己在游戏中想挖空或建造地形进行建造战斗场地时，直接手动挖空或放置非常耗时，而自己尝试过某些模组但都不太能满足自己需要，比如Fargo的“城市克星”，摧毁范围大但是墙壁无法破坏，还有“更好的体验”模组，放置和摧毁物块的效率并不算太高。暂时也没找到其他模组（如果有欢迎提出）。所以就自己动手写了一个。\n\n2.模组物品制作\n本模组包含三个物品，物品拾取磁铁、物块放置助手和物块摧毁助手。定义了一个全局的EasyBuildModPlayer类继承自ModPlayer，来控制使用某些物品或拥有某些效果时玩家的行为改变。\n\n2.1物品拾取磁铁\nItemGrabMagnet，该物品借鉴了懒人模组中的战利品磁铁和ItemMagnetPlus模组。希望达到的效果是使用后玩家拥有“物品拾取”的Buff，可以扩大拾取范围，再次使用则可以关闭。\n首先是ItemGrabMagnet的代码。这部分的代码比较简单，就是在玩家使用物品时判断是否已经拥有Buff，如果没有则添加Buff，如果有则移除Buff。\n有几个细节的地方：由于想要的是使用磁铁后buff时间无限长，在Buff中设置剩余时间不可见，在给Buff时设置足够长的时间即可。\n还有一个要注意的地方就是CombatText.NewText会默认对所有玩家触发，也就是玩家A在使用时，玩家B也能看到CombatText.NewText的讯息，所以CombatText.NewText的第一个参数不能用Main.LocalPlayer，否则其他人使用时也会显示在自己这里。\n    public class ItemGrabBuff : ModBuff\n    {\n        public override void SetStaticDefaults()\n        {\n            Main.buffNoTimeDisplay[Type] = true;\n            Main.debuff[Type] = false;\n        }\n        public override void Update(Player player, ref int buffIndex)\n        {\n            player.GetModPlayer<EasyBuildModPlayer>().ItemGrabBuff = true;\n        }\n    }\n\n    public class ItemGrabMagnet : ModItem\n    {\n        internal static string GetText(string str, params object[] args)\n        {\n            return Language.GetTextValue($\"Mods.EasyBuildMod.Content.Items.ItemGrabMagnet.{str}\", args);\n        }\n\n        public override string Texture => \"EasyBuildMod/Content/Items/ItemGrabMagnet\";\n\n        public bool IsMagnetOn;\n\n        public override void SetStaticDefaults()\n        {\n            CreativeItemSacrificesCatalog.Instance.SacrificeCountNeededByItemId[Type] = 1;\n        }\n\n        public override void SetDefaults()\n        {\n            Item.width = 30;\n            Item.height = 30;\n            Item.maxStack = 1;\n            Item.value = Item.sellPrice(gold: 1);\n            Item.rare = ItemRarityID.Blue;\n            Item.useAnimation = 15;\n            Item.useTime = 20;\n            Item.useStyle = ItemUseStyleID.HoldUp;\n            Item.consumable = false;\n            IsMagnetOn = false;\n        }\n\n        public override void AddRecipes()\n        {\n            // 20个铁锭/铅锭\n            CreateRecipe()\n                .AddRecipeGroup(\"IronBar\", 20)\n                .AddTile(TileID.Anvils)\n                .Register();\n        }\n\n        public override bool? UseItem(Player player)\n        {\n            IsMagnetOn = !player.HasBuff(ModContent.BuffType<Buffs.ItemGrabBuff>());\n            if (IsMagnetOn)\n            {\n                CombatText.NewText(player.Hitbox, Color.Green, GetText(\"OnTooltip\"));\n                player.AddBuff(ModContent.BuffType<Buffs.ItemGrabBuff>(), 2592000);\n                SoundEngine.PlaySound(SoundID.MenuTick);\n            }\n            else\n            {\n                CombatText.NewText(player.Hitbox, Color.Red, GetText(\"OffTooltip\"));\n                player.ClearBuff(ModContent.BuffType<Buffs.ItemGrabBuff>());\n                SoundEngine.PlaySound(SoundID.MenuClose);\n            }\n            return true;\n        }\n\n        public override void ModifyTooltips(List<TooltipLine> tooltips)\n        {\n            string color = IsMagnetOn ? \"00FF00\" : \"FF0000\";\n            string tooltop = IsMagnetOn ? GetText(\"OnTooltip\") : GetText(\"OffTooltip\");\n            var line = new TooltipLine(Mod, GetText(\"StatusName\"), $\"[c/{color}:{tooltop}]\");\n            tooltips.Add(line);\n        }\n\n    }\n\n然后是物品拾取范围扩大的实现。新定义EasyBuildModGlobalItem继承自GlobalItem，重写其中的GrabRange方法。注意格子数与游戏实际距离的换算是乘除16。\n    public class EasyBuildModGlobalItem : GlobalItem\n    {\n        public override void GrabRange(Item item, Player player, ref int grabRange)\n        {\n            if (player.GetModPlayer<EasyBuildModPlayer>().ItemGrabBuff)\n            {\n                grabRange = ModContent.GetInstance<EasyBuildModConfig>().MagnetRange * 16;\n            }\n        }\n    }\n\n至此便基本实现了ItemGrabMagnet的功能。效果如下：\n\n\n\n2.2物块放置与摧毁助手基类\nItemPlaceHelper与ItemDestroyHelper二者都有共同的特点，一个是可以通过右键调出菜单进行选择，一个是左键可以框选区域进行放置或破坏。自己最开始是先写了ItemPlaceHelper，而后写另一个的时候才意识到有大量重复的逻辑。为了避免过多重复代码，这里就二者的共同特点提取出一个抽象基类。\n这里分成了三部分，物品自身、菜单和区域选择。\n2.2.1Item实现\n主要就是定义了物品的基本行为，如右键调出菜单，左键进行框选。调出菜单在重写CanUseItem中进行实现，选择区域则是在UseItem，这样处理更为方便。这种情况下，ItemPlaceHelper与ItemDestroyHelper只需重写StartAction方法即可。\n这部分核心代码如下:\n    public abstract class AreaSelectItem : ModItem\n    {\n        // 选择区域的起点和终点\n        protected Point _beginPoint;\n        protected Point _endPoint;\n\n        // 是否开始选择区域\n        protected bool _startSelecting;\n\n        // 菜单UI的静态实例\n        protected MenuUI _menuUI;\n\n        public override bool AltFunctionUse(Player player) => true;\n\n        protected virtual bool useItemCondition(Player player) => true;\n\n        public override bool CanUseItem(Player player)\n        {\n            UISystem.CurrentMenuUI = _menuUI;\n            if (player.noBuilding)\n            {\n                return false;\n            }\n            if (player.altFunctionUse == 2)\n            {\n                if (_menuUI.Visible)\n                {\n                    SoundEngine.PlaySound(SoundID.MenuClose);\n                    _menuUI.Close();\n                }\n                else\n                {\n                    SoundEngine.PlaySound(SoundID.MenuTick);\n                    _menuUI.Open(this);\n                }\n                return false;\n            }\n            if (!useItemCondition(player))\n            {\n                return false;\n            }\n            if (!_startSelecting)\n            {\n                _beginPoint = Main.MouseWorld.ToTileCoordinates();\n                _startSelecting = true;\n            }\n            return true;\n        }\n        \n        public override bool? UseItem(Player player)\n        {\n            _endPoint = Main.MouseWorld.ToTileCoordinates();\n            if (!Main.mouseLeft)\n            {\n                HandleMouseUp();\n                return true;\n            }\n            if (Main.mouseRight && _startSelecting)\n            {\n                StopUse();\n            }\n            else\n            {\n                DrawingSystem.StartDraw(GetRectangle(_beginPoint, _endPoint));\n            }\n            return base.UseItem(player);\n        }\n\n        public virtual void StopUse()\n        {\n            DrawingSystem.StopDraw();\n            _startSelecting = false;\n        }\n\n        public void HandleMouseUp()\n        {\n            if (_startSelecting)\n            {\n                StartAction(Main.LocalPlayer);\n                SoundEngine.PlaySound(SoundID.Dig);\n                StopUse();\n            }\n        }\n\n        protected virtual void StartAction(Player player)\n        {\n        }\n                \n    }\n\n\n2.2.2菜单实现\n由于任意一个ItemPlaceHelper所调出的菜单都相同，所以就没必要给每一个ItemPlaceHelper配一个菜单，所有ItemPlaceHelper共用一个菜单即可。菜单继承自Terraria.UI.UIState，菜单的正确显示也花了不少时间，经过查看源码以及参考了”更好的体验”模组最后终于将UI显示出来。\n显示菜单的基本层次结构是ModSystem -> UserInterface -> UIState -> UIElement。具体就是UI中由若干像按钮之类的UIElement构成，UI的显示需要通过用户接口去更新UI状态，UIState与UserInterface的静态变量都存储在一个ModSystem中，让其可以在模组加载时就被加载好，并通过重写ModSystem的UpdateUI和ModifyInterfaceLayers去实现UI的更新与绘制。\nUISystem的核心代码如下：\n    public class UISystem : ModSystem\n    {\n\n        public static ItemPlaceHelperUI ItemPlaceHelperUI { get; set; }\n        private static UserInterface _itemPlaceHelperInterface;\n\n        public static ItemDestroyHelperUI ItemDestroyHelperUI { get; set; }\n        private static UserInterface _itemDestroyHelperInterface;\n\n        public override void Load()\n        {\n            ItemPlaceHelperUI = new ItemPlaceHelperUI();\n            _itemPlaceHelperInterface = new UserInterface();\n            _itemPlaceHelperInterface.SetState(ItemPlaceHelperUI);\n            ItemDestroyHelperUI = new ItemDestroyHelperUI();\n            _itemDestroyHelperInterface = new UserInterface();\n            _itemDestroyHelperInterface.SetState(ItemDestroyHelperUI);\n        }\n\n        public override void Unload()\n        {\n            ItemPlaceHelperUI = null;\n            _itemPlaceHelperInterface = null;\n            ItemDestroyHelperUI = null;\n            _itemDestroyHelperInterface = null;\n        }\n\n        public override void UpdateUI(GameTime gameTime)\n        {\n            if (ItemPlaceHelperUI.Visible)\n            {\n                _itemPlaceHelperInterface.Update(gameTime);\n            }\n            if (ItemDestroyHelperUI.Visible)\n            {\n                _itemDestroyHelperInterface.Update(gameTime);\n            }\n        }\n\n        public override void ModifyInterfaceLayers(List<GameInterfaceLayer> layers)\n        {\n            int mouseTextIndex = layers.FindIndex(layer => layer.Name.Equals(\"Vanilla: Mouse Text\")); // 表示在鼠标文本之上\n            if (mouseTextIndex != -1)\n            {\n                layers.Insert(mouseTextIndex, new LegacyGameInterfaceLayer(\n                    \"EasyBuildMod: MyMenuUI\",\n                    delegate\n                    {\n                        if (ItemPlaceHelperUI.Visible)\n                        {\n                            _itemPlaceHelperInterface.Draw(Main.spriteBatch, new GameTime());\n                        }\n                        if (ItemDestroyHelperUI.Visible)\n                        {\n                            _itemDestroyHelperInterface.Draw(Main.spriteBatch, new GameTime());\n                        }\n                        return true;\n                    },\n                    InterfaceScaleType.UI)\n                );\n            }\n        }\n\n    }\n\n可以看到存在这样的调用顺序ModSystem.UpdateUI -> UseInterface.Update用于实时更新,  ModSystem.ModifyInterfaceLayers -> UseInterface.Draw用于绘制。而这里给UI添加了个变量Visible用于控制何时显示。只有当Visible为true时上述两个方法才对其进行更新。\n\n接下来是UI，UI中的代码比较简单，由于所有物品共用一个UI，所以这里需要存储调出UI的物品是哪一个(AreaSelectItem)。在其派生类中只需定义包含的元素以及相应的点击事件等即可。\n这里有一个需要注意的点就是UI的位置需要考虑用户的UI缩放。\n\n这部分核心代码如下：\n\n    public abstract class MenuUI : UIState\n    {\n        internal AreaSelectItem AreaSelectItem;\n\n        protected UIElement MainContainer;\n\n        public bool Visible;\n\n        public override void OnInitialize()\n        {\n            base.OnInitialize();\n            Append(MainContainer = new ());\n            MainContainer.Width.Set(200, 0);\n            MainContainer.Height.Set(200, 0);\n        }\n\n        public virtual void Open(AreaSelectItem item)\n        {\n            this.AreaSelectItem = item;\n            Visible = true;\n            // 注意要除以UIScale，否则如果缩放比例不是100%就会错位\n            MainContainer.Left.Set(Main.mouseX / Main.UIScale - MainContainer.Width.Pixels / 2, 0);\n            MainContainer.Top.Set(Main.mouseY / Main.UIScale - MainContainer.Height.Pixels / 2, 0);\n        }\n\n    }\n\n\n当玩家手中物品切换时，也需要关闭UI，这里需要在ModPlayer中重写PostUpdate方法，当玩家手中物品不是AreaSelectItem时关闭UI。\n    public override void PostUpdate()\n    {\n        if (UISystem.CurrentMenuUI is null || UISystem.CurrentMenuUI.AreaSelectItem is null)\n        {\n            return;\n        }\n        AreaSelectItem currentItem = UISystem.CurrentMenuUI.AreaSelectItem;\n        Player player = Main.player[Main.myPlayer];\n        Item item = player.inventory[player.selectedItem];\n        if (item.type != currentItem.Type)\n        {\n            if (!Main.playerInventory)\n            {\n                UISystem.Hide();\n            }\n        }\n        else\n        {\n            DrawingSystem.Init();\n            if (!Main.mouseLeft)\n            {\n                UISystem.CurrentMenuUI.AreaSelectItem.\n            }\n        }\n    }\n\n\n2.2.3物块选择框实现\n这里也一样需要通过在ModSystem的ModifyInterfaceLayers调用对应UserInterface的Draw进行绘制。新定义一个DrawingSystem继承自ModSystem，这部分代码就不多赘述了。\n物品框选时希望显示的有(1)在鼠标末尾画物块预览 (2)矩形区域预览 (3) 矩形大小显示，其中(2)和(3)只有在使用物品时才进行绘制。这部分核心代码如下：\n    public class SelectedAreaDrawing\n    {\n        public bool IsDrawing;\n\n        /// <summary>\n        /// 绘制物块预览\n        /// </summary>\n        private void drawItemPreview()\n        {\n            Vector2 position = Main.MouseScreen + new Vector2(32, 32);\n            Texture2D texture = TextureAssets.Item[itemId].Value;\n            Main.spriteBatch.Draw(texture, position, null, Color.White, 0f, texture.Size() / 2, 1f, SpriteEffects.None, 0f);\n        }\n\n        /// <summary>\n        /// 绘制矩形区域预览\n        /// </summary>\n        private void drawRectanglePreview()\n        {\n            Vector2 leftTop = _rectangle.TopLeft() * 16 - Main.screenPosition;\n            Vector2 size = _rectangle.Size() * 16;\n            Color color = Color.White * 0.7f;\n            _areaTexture.SetData(new Color[] { color });\n            Main.spriteBatch.Draw(_areaTexture, leftTop, null, color, 0f, Vector2.Zero, size, SpriteEffects.None, 0f);\n        }\n\n        /// <summary>\n        /// 标明矩形大小\n        /// </summary>\n        private void drawRectangleSize()\n        {\n            string sizeText = $\"{_rectangle.Width} x {_rectangle.Height}\";\n            Vector2 size = FontAssets.MouseText.Value.MeasureString(sizeText);\n            Vector2 position = Main.MouseScreen + new Vector2(16, -size.Y - 6);\n            ChatManager.DrawColorCodedStringWithShadow(Main.spriteBatch, FontAssets.MouseText.Value, sizeText, position, Color.White, 0f, Vector2.Zero, Vector2.One);\n        }\n\n        public void Draw()\n        {\n            drawItemPreview();\n            if (IsDrawing)\n            {\n                drawRectanglePreview();\n                drawRectangleSize();\n            }\n        }\n    }\n\n\n\n2.3物块放置助手\nItemPlaceHelper，想要实现的效果是右键打开物品选择菜单，选择物品后，左键可以选择矩形区域放置。\n选择菜单中只有一个用于放置选择物块的按钮，通过获取Main.mouseItem物品，根据其createTile和createWall判断是否为物块或墙壁，这部分代码如下：\n    itemSelectButton.OnClick += (evt, element) =>\n    {\n        if (Main.mouseItem.type != 0)\n        {\n            // 如果物块可以放置，则添加进来\n            if ((Main.mouseItem.createTile != -1 && Main.tileSolid[Main.mouseItem.createTile]) || Main.mouseItem.createWall != -1)\n            {\n                AreaSelectItem.ContentItemType = Main.mouseItem.type;\n                itemSelectButton.SetContent(TextureAssets.Item[Main.mouseItem.type]);\n            }\n        }\n        else\n        {\n            itemSelectButton.SetContent(null);\n            AreaSelectItem.ContentItemType = 0;\n        }\n    };\n\n其中itemSelectButton是自己定义的一个圆形按钮。\n\n该物品的关键在于放置物品，即重写基类AreaSelectItem的StartAction方法。\n    protected override void StartAction(Player player)\n    {\n        var rect = GetRectangle(_beginPoint, _endPoint);\n        int consumeCount = 0;\n        int total = GetItemCountOfInventory(player.inventory, ContentItemType);\n        Item item = new Item();\n        item.SetDefaults(ContentItemType);\n        bool isWall = item.createWall > 0;\n        bool hasHammer = getMaxHammerPower(player) > 0;\n        // 从下到上，从左到右\n        // 这种顺序可以保证某些具有自由落体性质的方块(如沙块)能够被正确的放置\n        // 不过也会导致替换方块时, 像沙块这样的方块无法被从下往上替换\n        for (int y = rect.Y + rect.Height - 1; y >= rect.Y; y--)\n        {\n            for (int x = rect.X; x < rect.X + rect.Width; x++)\n            {\n                if (consumeCount >= total)\n                {\n                    break;\n                }\n                Tile tile = Main.tile[x, y];\n                if (isWall)\n                {\n                    if (tile.WallType > 0)\n                    {\n                        if (!player.TileReplacementEnabled)\n                        {\n                            continue;\n                        }\n                        if (hasHammer)\n                        {\n                            WorldGen.KillWall(x, y, false);\n                            WorldGen.PlaceWall(x, y, (ushort)item.createWall, true);\n                            consumeCount++;\n                        }\n                    }\n                    else\n                    {\n                        WorldGen.PlaceWall(x, y, (ushort)item.createWall, true);\n                        consumeCount++;\n                    }\n                }\n                else\n                {\n                    if (tile.HasTile)\n                    {\n                        if (!player.TileReplacementEnabled || !player.HasEnoughPickPowerToHurtTile(x, y))\n                        {\n                            continue;\n                        }\n                        // 判断是否是同一种方块，是则跳过\n                        WorldGen.KillTile_GetItemDrops(x, y, tile, out int tileType, out _, out _, out _);\n                        if (tileType == item.type)\n                        {\n                            continue;\n                        }\n                        if (WorldGen.ReplaceTile(x, y, (ushort)item.createTile, item.placeStyle))\n                        {\n                            consumeCount++;\n                        }\n                    }\n                    else\n                    {\n                        if (WorldGen.PlaceTile(x, y, (ushort)item.createTile, true, true, player.whoAmI, item.placeStyle))\n                        {\n                            consumeCount++;\n                        }\n                    }\n                }\n            }\n        }\n        if (consumeCount > 0)\n        {\n            for (int i = 0; i < player.inventory.Length; i++)\n            {\n                if (player.inventory[i].type == ContentItemType)\n                {\n                    if (player.inventory[i].stack > consumeCount)\n                    {\n                        player.inventory[i].stack -= consumeCount;\n                        break;\n                    }\n                    else\n                    {\n                        consumeCount -= player.inventory[i].stack;\n                        player.inventory[i].SetDefaults();\n                    }\n                }\n            }\n        }\n    }\n\n以上有几个需要注意的问题，\n\n  如果使用player.PickTile进行破坏物块，则第三个参数镐力值需要尽可能的填大一些，如果镐力刚好大于物块所需的最大镐力，则完全有可能不能直接摧毁物块而仅仅是对其造成一定程度损坏\n  替换物块可以用WorldGen.ReplaceTile但替换墙壁则没找到对应的ReplaceWall，需要先使用KillWall再进行放置。\n  获取位于x,y处的物块或墙壁的类型的问题放在了文章末尾 点这里跳转\n\n\n2.4物块摧毁助手\nItemDestroyHelper，设计思路与ItemPlaceHelper几乎完全相同，只是将StartAction中的放置改为了摧毁，实际上摧毁的逻辑在替换物块时已经实现，这里就不多赘述。\n\n\n3.多人模式下的相关修改\n这部分主要集中在物块墙壁放置和摧毁时与游戏内其他玩家的同步问题上，于是我就在摧毁和放置的末尾加上：\n    if (Main.netMode == NetmodeID.MultiplayerClient)\n    {\n        NetMessage.SendData(MessageID.TileSquare, Main.myPlayer, -1, null, rect.X, rect.Y, rect.Width, rect.Height);\n    }\n\n这样一次性同步范围内的所有方块。但这时也遇到了个问题，虽然方块同步了，但却没有掉落物。摧毁物块和墙壁调用的是WorldGen.KillTile和WorldGen.KillWall，仔细查看源码才发现当游戏处于多人模式时，这两个方法禁用了物块的正常掉落。\n\n这时我注意到另一个函数player.PickTile(x, y, 10000)在进行破坏物块时可以在多人模式下掉落，于是我进入Player的PickTile方法中查看了一下，如下图所示：\n\n仿照这个方法，我重新写了一下破坏物块和墙壁的代码，注意墙壁和物块的SendData第五个参数不同：\n    public static class WallUtils\n    {\n        public static void KillWall(int x, int y, bool fail = false)\n        {\n            WorldGen.KillWall(x, y, fail);\n            if (!fail && Main.netMode == NetmodeID.MultiplayerClient)\n            {\n                // Wall对应的SendData第5个参数值为2\n                NetMessage.SendData(MessageID.TileManipulation, -1, -1, null, 2, (float)x, (float)y, 0f, 0, 0, 0);\n            }\n        }\n\n    }\n\n    public static class TileUtils\n    {\n        public static void KillTile(int x, int y, bool fail = false, bool effectOnly = false, bool noItem = false)\n        {\n            WorldGen.KillTile(x, y, fail, effectOnly, noItem);\n            if (!fail && Main.netMode == NetmodeID.MultiplayerClient)\n            {\n                // Tile对应的SendData第5个参数值为0\n                NetMessage.SendData(MessageID.TileManipulation, -1, -1, null, 0, (float)x, (float)y, 0f, 0, 0, 0);\n            }\n        }\n\n    }\n\n\n4.开发过程中的其他问题\n1.使用语言文件时遇到的问题\n将模组中需要用到的文字信息的不同语言版本放在XXX.hjson如en-US.hjson中，再通过Language.GetTextValue(“Mods.XXX.XXX”)来获取对应语言的文字。但在我使用时遇到一个小问题，在设置物品的DisplayName和Tooltip的名称时，以下代码并不能正常获取到对应语言的文字信息：\n    DisplayName.SetDefault(Language.GetTextValue(\"Mods.XXX.XXX\"));\n    Tooltip.SetDefault(Language.GetTextValue(\"Mods.XXX.XXX\"));\n\n在游戏运行时有时能正常显示，有时则直接显示了“Mods.XXXXXX”这个字符串。推测是语言文件与物品静态信息加载顺序关。后面参考了官方的ExampleMod，解决方法是在语言文件hjson中直接写明物品或Buff的DisplayName和Tooltip，会自动读取到游戏中。\n    Mods.XXXMod.ItemName: {\n        物品类名: 物品名称\n    }\n    Mods.XXXMod.ItemTooltip: {\n        物品类名: 物品Tooltip\n    }\n    Mods.XXXMod.BuffName: {\n        Buff类名: Buff名称\n    }\n    Mods.XXXMod.BuffDescription: {\n        Buff类名: Buff描述\n    }\n\n2.获取物块或墙壁对应的类型\n判断位于x,y处的物块对应的item的类型，也就是itemId。这个方法我找了很久，最后也是成功从掉落物块的相关源码中找到了直接想要的内容：Terraria.WorldGen.KillTile_DropItems是用于破坏物块后进行掉落用的，不过它是私有方法，而它调用的KillTile_GetItemDrops刚好是public方法，所以在判断物块时就使用了这种方法。但是奇怪的是KillWall_GetItemDrops却是私有方法，所以这里直接将源码中的代码复制过来，如下图所示：\n\n由于是反编译得到的源码，所以有大量的switch-case和if分支。唯一要注意的是图中*tileCache.wall是Tile的internal属性：\n\n图中可以看到实际上wall对应的实际就是公有属性WallType，故将源码中的*tileCache.wall全改为tileCache.WallType即可。\n\n3.按钮的点击问题\n当鼠标上已经有物块时，点击按钮如果鼠标上的物块可以被正确放在按钮所在的原位置，则系统会优先将物块放置再触发按钮的点击事件。这个由于不是非常影响体验，将鼠标离玩家远一点即可，暂时没去研究解决方法。\n\n4.待解决的bug\n多人模式下，有时会出现突然摧毁一大片区域的情况，比如一个玩家正在使用物块摧毁助手的区域选择，此时另一个玩家使用回忆药水或者返回药水，就会导致两名玩家之间的大片区域被摧毁。有点类似于灾厄模组中多人游戏下召唤幻海妖龙失败但是在召唤后使用回忆药水就会突然生成。这个bug暂时还没有时间去研究。\n\n"
  },
  {
    "title": "Axios delete传递数组问题",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/03/22/Axios-delete%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98.html",
    "date": "2023-03-22 23:20:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17246117.html\n现在转移到 github pages 上。\n\nAxios delete传递数组的注意点\n后端接口如下:\n  @DeleteMapping(\"/deleteUser\")\n  public ResponseVO<Integer> deleteUser(@RequestParam(value = \"userIdList\", required = true) List<Integer> userIdList) \n\n在发送请求时如果向下面这样写会报400 bad request错误：\naxios.delete(url, { params: {userIdList: userIdList} })\n\n检查其请求的url，可以看到参数的格式有一定问题：\n\n所以需要对其格式进行处理。\n\n  可以引入import qs from 'qs'用qs.stringfy模块进行处理：\n    const params = {\n  params: {\n userIdList: userIdList\n  },\n  paramsSerializer: params => {\n return qs.stringify(params, { indices: false })\n  }\n}\naxios.delete(url, params)\n    \n    也可以直接拼接在url后：\n    const url = '/users/user/deleteUser?' + qs.stringify({ userIdList: userIdList }, { indices: false })\naxios.delete(url)\n    \n  \n  也可以不使用qs，直接手动拼接参数:\n    const url = '/users/user/deleteUser?' + userIdList.map(item => 'userIdList=' + item).join('&')\naxios.delete(url)\n    \n    或者:\n    const params = new URLSearchParams()\nuserIdList.forEach(item => {\n  params.append('userIdList', item)\n})\naxios.delete(url, { data: params })\n    \n  \n\n"
  },
  {
    "title": "Linux无root权限conda初始化",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/03/15/Linux%E6%97%A0root%E6%9D%83%E9%99%90conda%E5%88%9D%E5%A7%8B%E5%8C%96.html",
    "date": "2023-03-15 04:00:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17218011.html\n现在转移到 github pages 上。\n\n1. 给anaconda文件写入权限\nsudo chmod a+w .conda\n\n如果没有权限则会在创建环境时报以下错误\nNoWritableEnvsDirError: No writeable envs directories configured.\n  - /home/ubuntu/.conda/envs\n  - /usr/local/miniconda3\n\n\n2. 创建环境\n  conda create -n myenv\n  # 若服务器已经预装了相关的环境（比如某些市场镜像已预装了tensorflow或PyTorch），则可以直接克隆环境\n  conda create -n myenv --clone base\n\n\n3. 激活环境\n  conda activate myenv\n\n如果出现以下报错:\nCommandNotFoundError: Your shell has not been properly configured to use 'conda activate'.\nTo initialize your shell, run\n\n    $ conda init <SHELL_NAME>\n\nCurrently supported shells are:\n  - bash\n  - fish\n  - tcsh\n  - xonsh\n  - zsh\n  - powershell\n\nSee 'conda init --help' for more information and options.\n\nIMPORTANT: You may need to close and restart your shell after running 'conda init'.\n\n则说明当前的shell没有配置使用conda activate，需要初始化\n先获取当前shell类型\n  echo $0\n\n再初始化shell\n  conda init <shell type>\n\n然后重启shell之后再conda activate即可。\n"
  },
  {
    "title": "tModLoader随机掉落模组编写",
    "url": "/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2023/03/12/tModLoader%E9%9A%8F%E6%9C%BA%E6%8E%89%E8%90%BD%E6%A8%A1%E7%BB%84%E7%BC%96%E5%86%99.html",
    "date": "2023-03-12 02:00:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/p/17207420.html\n现在转移到 github pages 上。\n\n1. 整体思路\n目标是实现击杀低敌怪后有概率掉落任意物品，包括其他模组中的内容，数量取决于该物品的最大堆叠数，同时保留原本可能的掉落物。\n随机掉落的思路比较简单，重写GlobalNPC中的死亡或者掉落方法即可。在1.4以前的tModLoader可以重写NPCLoot方法，换成一个随机物品即可。1.4之后看了下源码，GLobalNPC下没有NPCLoot方法了，有可能其他的方法可以重写比如ModifyNPCLoot(看着比较像，但没试过)。我这边采用的是重写PreKill(NPC)方法。\n获取最大堆叠数则是要获取id对应的Item，这里有个坑，我一开始用的是ItemLoader.GetItem().Item.maxStack，没注意到ItemLoader.GetItem()这个方法获取的是非原版的物品，然后一直返回null，运行之后的报错又恰好行号跟我代码对不上，然后折腾了好久才发现。最后用的是item.SetDefaults(itemId)来获取Item。\n\n2. 核心代码\nusing Terraria;\nusing Terraria.ID;\nusing Terraria.ModLoader;\nusing System;\n\nnamespace RandomDropMod\n{\n    public class RandomDropModNPC : GlobalNPC\n    {\n        private static Random random = new Random();\n        public override bool PreKill(NPC npc)\n        {\n            if (random.Next(100) > ModContent.GetInstance<RandomDropModConfig>().DropProbability)\n            {\n                return base.PreKill(npc);\n            }\n            // 随机生成物品\n            int itemId = random.Next(ItemLoader.ItemCount);\n            Item item = new Item();\n            item.SetDefaults(itemId);\n            // 随机生成物品的数量\n            int maxStack = item.maxStack;\n            /*\n                最大堆叠, 生成数量\n                1, 1\n                2~10, 1~(maxStack-1)\n                11~30, 5~(maxStack-5)\n                31~100, 15~(maxStack-15)\n                >100, 30~60\n            */\n            int count = 1;\n            if (maxStack > 1)\n            {\n                if (maxStack < 10)\n                {\n                    count = random.Next(maxStack - 1) + 1;\n                }\n                else if (maxStack < 30)\n                {\n                    count = random.Next(maxStack - 5) + 5;\n                }\n                else if (maxStack < 100)\n                {\n                    count = random.Next(maxStack - 15) + 15;\n                }\n                else\n                {\n                    count = random.Next(30) + 30;\n                }\n            }\n            // 生成物品\n            Item.NewItem(null, npc.position, itemId, count);\n            return base.PreKill(npc);\n        }\n    }\n}\n\n\n3. 设置用户可调整掉落概率\n参考官方提供的ExampleMod，添加一个Config即可。\nusing System.ComponentModel;\nusing Terraria.ModLoader.Config;\n\nnamespace RandomDropMod\n{\n    public class RandomDropModConfig : ModConfig\n    {\n        public override ConfigScope Mode => ConfigScope.ServerSide;\n        \n        [Label(\"Chance to drop item\")]\n        [Slider]\n        [SliderColor(255, 255, 50)]\n        [Range(0, 100)]\n        [Increment(1)]\n        [DefaultValue(20)]\n        public int DropProbability { get; set; }\n    }\n}\n\n"
  },
  {
    "title": "Alibaba Cloud Linux 2(Centos7)安装mysql8.0.md",
    "url": "/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/2023/03/09/Alibaba-Cloud-Linux-2(Centos7)%E5%AE%89%E8%A3%85mysql8.0.html",
    "date": "2023-03-09 18:30:00 +0000",
    "content": "本文首次发布于博客园：https://www.cnblogs.com/lxm-cnblog/articles/17202074.html\n现在转移到 github pages 上。\n\n1. 检查是否安装历史版本，如果有则删除相关文件\n\n  查找并删除历史版本mysql\n    rpm -qa|grep mysql\n# 如果存在则删除\nrpm -ev [组件名称]\n# 查找残留文件\nfind / -name mysql\n    \n  \n  删除配置以及数据\n    # 删除配置\nrm -rf /etc/my.cnf\n# 删除数据目录\ncd /var/lib/mysql\nrm -rf *\n    \n  \n  查找并删除已有mysql依赖\n    # 查找依赖\nrpm -qa | grep mysql\n# 如果有则删除\nrpm -e [mysql_libs]\n# 若删除失败则强力删除\nrpm -e --nodeps [mysql_libs]\n    \n  \n  查看并删除mariadb\n    rpm -qa | grep mariadb\nrpm -e --nodeps [mariadb]\n    \n  \n\n\n2. 下载mysql8.0\n  wget http://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql80-community-el7/mysql80-community-release-el7-1.noarch.rpm\n\n\n  如果以下出现404错误\n    failure: repodata/repomd.xml from xxx: [Errno 256] No more mirrors to try.\n  https://download.xxx.com/linux/centos/2.1903/x86_64/stable/repodata/repomd.xml: [Errno 14] HTTPS Error 404 - Not Found\n    \n  \n  这有可能是Alibaba Cloud Linux 2 的Centos版本的问题，可以有以下两种解决方法:\n    \n      下载Centos7 yum源\n        wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\nyum clean all \nyum list \nyum makecache\n        \n      \n      找到/etc/yum.repos.d下的repo文件, 将其中的所有$releasever替换成7\n    \n  \n\n\n3. 安装mysql\n  # 安装mysql依赖包\n  yum install -y libaio\n  # 安装mysql\n  rpm -ivh mysql80-community-release-el7-1.noarch.rpm\n  yum install mysql-server\n\n\n  若出现Public key for mysql-community-server-5.7.37-1.el7.x86_64.rpm is not installed则需要更新mysql的GPA\n    rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022\n# 然后再安装\nyum install mysql-server\n    \n  \n\n\n4. 配置并启动mysql\n\n  设为开机启动\n      # 检查是否开机启动\n  systemctl list-unit-files|grep mysqld\n  # 若没有则设为开机启动\n  systemctl enable mysqld.service\n    \n  \n  初始化mysql\n      mysqld --initialize\n  # 查看初始化密码\n  grep 'temporary password' /var/log/mysqld.log\n  # 登录mysql\n  mysql -uroot -p\n    \n    \n      可能会出现的报错:\n    \n    \n      如果出现Can't connect to local MySQL server through socket '/var/lib   /mysql/mysql.sock' (111)\n         # 进入报错路径并删除mysql.sock，再重启服务\n cd /var/lib/mysql/ \n rm -rf mysql.sock \n systemctl stop mysqld \n systemctl start mysqld \n // 然后登入mysql查看是否正常 \n mysql -u root -p \n        \n      \n      如果启动报错\n         service mysqld start\n Redirecting to /bin/systemctl start mysqld.service\n Job for mysqld.service failed because the control process exited with error code. See \"systemctl status mysqld.service\" and \"journalctl -xe\" for details.\n        \n        \n          执行以下指令\n               chown mysql:mysql -R /var/lib/mysql\n            \n          \n        \n      \n      如果出现Failed to start mysqld.service: Unit not found\n           yum -y install mariadb  mariadb-devel  mariadb-server\n        \n      \n    \n  \n  修改密码\n      alter user 'root'@'localhost' identified by '12345678';\n    \n    \n      如果提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements\n        set global validate_password.policy=0;\n        \n      \n    \n  \n  远程授权\n      grant all privileges on *.* to 'root'@'%' identified by '12345678' with grant option;\n    \n    \n      如果出现check the manual that corresponds to your MySQL server version for the right syntax to\n      原因是我采用的mysql版本是8.0.13，给新用户授权时有所变化\n         -- 创建账户\n create user 'root'@'xxx.xxx.xxx.xxx' identified by 'password'\n -- 授权，with grant option指该用户可以将自己拥有的权限授权给别人\n grant all privileges on *.* to 'root'@'xxx.xxx.xxx.xxx' with grant option\n        \n      \n      刷新权限\n        flush privileges;\n        \n      \n    \n  \n\n\n"
  }
]